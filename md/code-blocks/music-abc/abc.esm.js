// deno-fmt-ignore-file

/**
 * abcjs and linkedom bundled with esbuild
 * 
 * https://paulrosen.github.io/abcjs/
 * https://github.com/WebReflection/linkedom
 * https://esbuild.github.io
 */

var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/linkedom/cjs/shared/symbols.js
var require_symbols = __commonJS({
  "node_modules/linkedom/cjs/shared/symbols.js"(exports) {
    "use strict";
    var CHANGED = Symbol("changed");
    exports.CHANGED = CHANGED;
    var CLASS_LIST = Symbol("classList");
    exports.CLASS_LIST = CLASS_LIST;
    var CUSTOM_ELEMENTS = Symbol("CustomElements");
    exports.CUSTOM_ELEMENTS = CUSTOM_ELEMENTS;
    var CONTENT = Symbol("content");
    exports.CONTENT = CONTENT;
    var DATASET = Symbol("dataset");
    exports.DATASET = DATASET;
    var DOCTYPE = Symbol("doctype");
    exports.DOCTYPE = DOCTYPE;
    var DOM_PARSER = Symbol("DOMParser");
    exports.DOM_PARSER = DOM_PARSER;
    var END = Symbol("end");
    exports.END = END;
    var EVENT_TARGET = Symbol("EventTarget");
    exports.EVENT_TARGET = EVENT_TARGET;
    var GLOBALS = Symbol("globals");
    exports.GLOBALS = GLOBALS;
    var IMAGE = Symbol("image");
    exports.IMAGE = IMAGE;
    var MIME = Symbol("mime");
    exports.MIME = MIME;
    var MUTATION_OBSERVER = Symbol("MutationObserver");
    exports.MUTATION_OBSERVER = MUTATION_OBSERVER;
    var NEXT = Symbol("next");
    exports.NEXT = NEXT;
    var OWNER_ELEMENT = Symbol("ownerElement");
    exports.OWNER_ELEMENT = OWNER_ELEMENT;
    var PREV = Symbol("prev");
    exports.PREV = PREV;
    var PRIVATE = Symbol("private");
    exports.PRIVATE = PRIVATE;
    var SHEET = Symbol("sheet");
    exports.SHEET = SHEET;
    var START = Symbol("start");
    exports.START = START;
    var STYLE = Symbol("style");
    exports.STYLE = STYLE;
    var UPGRADE = Symbol("upgrade");
    exports.UPGRADE = UPGRADE;
    var VALUE = Symbol("value");
    exports.VALUE = VALUE;
  }
});

// node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "node_modules/entities/lib/generated/decode-data-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array([7489, 60, 213, 305, 650, 1181, 1403, 1488, 1653, 1758, 1954, 2006, 2063, 2634, 2705, 3489, 3693, 3849, 3878, 4298, 4648, 4833, 5141, 5277, 5315, 5343, 5413, 0, 0, 0, 0, 0, 0, 5483, 5837, 6541, 7186, 7645, 8062, 8288, 8624, 8845, 9152, 9211, 9282, 10276, 10514, 11528, 11848, 12238, 12310, 12986, 13881, 14252, 14590, 14888, 14961, 15072, 15150, 2048, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 92, 98, 102, 109, 115, 127, 132, 139, 144, 149, 152, 166, 179, 185, 200, 207, 108, 105, 103, 32827, 198, 16582, 80, 32827, 38, 16422, 99, 117, 116, 101, 32827, 193, 16577, 114, 101, 118, 101, 59, 16642, 256, 105, 121, 120, 125, 114, 99, 32827, 194, 16578, 59, 17424, 114, 59, 49152, 55349, 56580, 114, 97, 118, 101, 32827, 192, 16576, 112, 104, 97, 59, 17297, 97, 99, 114, 59, 16640, 100, 59, 27219, 256, 103, 112, 157, 161, 111, 110, 59, 16644, 102, 59, 49152, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 24673, 105, 110, 103, 32827, 197, 16581, 256, 99, 115, 190, 195, 114, 59, 49152, 55349, 56476, 105, 103, 110, 59, 25172, 105, 108, 100, 101, 32827, 195, 16579, 109, 108, 32827, 196, 16580, 1024, 97, 99, 101, 102, 111, 114, 115, 117, 229, 251, 254, 279, 284, 290, 295, 298, 256, 99, 114, 234, 242, 107, 115, 108, 97, 115, 104, 59, 25110, 374, 246, 248, 59, 27367, 101, 100, 59, 25350, 121, 59, 17425, 384, 99, 114, 116, 261, 267, 276, 97, 117, 115, 101, 59, 25141, 110, 111, 117, 108, 108, 105, 115, 59, 24876, 97, 59, 17298, 114, 59, 49152, 55349, 56581, 112, 102, 59, 49152, 55349, 56633, 101, 118, 101, 59, 17112, 99, 242, 275, 109, 112, 101, 113, 59, 25166, 1792, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 333, 337, 342, 384, 414, 418, 437, 439, 442, 476, 533, 627, 632, 638, 99, 121, 59, 17447, 80, 89, 32827, 169, 16553, 384, 99, 112, 121, 349, 354, 378, 117, 116, 101, 59, 16646, 256, 59, 105, 359, 360, 25298, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 24901, 108, 101, 121, 115, 59, 24877, 512, 97, 101, 105, 111, 393, 398, 404, 408, 114, 111, 110, 59, 16652, 100, 105, 108, 32827, 199, 16583, 114, 99, 59, 16648, 110, 105, 110, 116, 59, 25136, 111, 116, 59, 16650, 256, 100, 110, 423, 429, 105, 108, 108, 97, 59, 16568, 116, 101, 114, 68, 111, 116, 59, 16567, 242, 383, 105, 59, 17319, 114, 99, 108, 101, 512, 68, 77, 80, 84, 455, 459, 465, 470, 111, 116, 59, 25241, 105, 110, 117, 115, 59, 25238, 108, 117, 115, 59, 25237, 105, 109, 101, 115, 59, 25239, 111, 256, 99, 115, 482, 504, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 25138, 101, 67, 117, 114, 108, 121, 256, 68, 81, 515, 527, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 24605, 117, 111, 116, 101, 59, 24601, 512, 108, 110, 112, 117, 542, 552, 583, 597, 111, 110, 256, 59, 101, 549, 550, 25143, 59, 27252, 384, 103, 105, 116, 559, 566, 570, 114, 117, 101, 110, 116, 59, 25185, 110, 116, 59, 25135, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 25134, 256, 102, 114, 588, 590, 59, 24834, 111, 100, 117, 99, 116, 59, 25104, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 25139, 111, 115, 115, 59, 27183, 99, 114, 59, 49152, 55349, 56478, 112, 256, 59, 67, 644, 645, 25299, 97, 112, 59, 25165, 1408, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 672, 684, 688, 692, 696, 715, 727, 737, 742, 819, 1165, 256, 59, 111, 377, 677, 116, 114, 97, 104, 100, 59, 26897, 99, 121, 59, 17410, 99, 121, 59, 17413, 99, 121, 59, 17423, 384, 103, 114, 115, 703, 708, 711, 103, 101, 114, 59, 24609, 114, 59, 24993, 104, 118, 59, 27364, 256, 97, 121, 720, 725, 114, 111, 110, 59, 16654, 59, 17428, 108, 256, 59, 116, 733, 734, 25095, 97, 59, 17300, 114, 59, 49152, 55349, 56583, 256, 97, 102, 747, 807, 256, 99, 109, 752, 802, 114, 105, 116, 105, 99, 97, 108, 512, 65, 68, 71, 84, 768, 774, 790, 796, 99, 117, 116, 101, 59, 16564, 111, 372, 779, 781, 59, 17113, 98, 108, 101, 65, 99, 117, 116, 101, 59, 17117, 114, 97, 118, 101, 59, 16480, 105, 108, 100, 101, 59, 17116, 111, 110, 100, 59, 25284, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 24902, 1136, 829, 0, 0, 0, 834, 852, 0, 1029, 102, 59, 49152, 55349, 56635, 384, 59, 68, 69, 840, 841, 845, 16552, 111, 116, 59, 24796, 113, 117, 97, 108, 59, 25168, 98, 108, 101, 768, 67, 68, 76, 82, 85, 86, 867, 882, 898, 975, 994, 1016, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 236, 569, 111, 628, 889, 0, 0, 891, 187, 841, 110, 65, 114, 114, 111, 119, 59, 25043, 256, 101, 111, 903, 932, 102, 116, 384, 65, 82, 84, 912, 918, 929, 114, 114, 111, 119, 59, 25040, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 25044, 101, 229, 714, 110, 103, 256, 76, 82, 939, 964, 101, 102, 116, 256, 65, 82, 947, 953, 114, 114, 111, 119, 59, 26616, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 26618, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 26617, 105, 103, 104, 116, 256, 65, 84, 984, 990, 114, 114, 111, 119, 59, 25042, 101, 101, 59, 25256, 112, 577, 1001, 0, 0, 1007, 114, 114, 111, 119, 59, 25041, 111, 119, 110, 65, 114, 114, 111, 119, 59, 25045, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 25125, 110, 768, 65, 66, 76, 82, 84, 97, 1042, 1066, 1072, 1118, 1151, 892, 114, 114, 111, 119, 384, 59, 66, 85, 1053, 1054, 1058, 24979, 97, 114, 59, 26899, 112, 65, 114, 114, 111, 119, 59, 25077, 114, 101, 118, 101, 59, 17169, 101, 102, 116, 722, 1082, 0, 1094, 0, 1104, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 26960, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26974, 101, 99, 116, 111, 114, 256, 59, 66, 1113, 1114, 25021, 97, 114, 59, 26966, 105, 103, 104, 116, 468, 1127, 0, 1137, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26975, 101, 99, 116, 111, 114, 256, 59, 66, 1146, 1147, 25025, 97, 114, 59, 26967, 101, 101, 256, 59, 65, 1158, 1159, 25252, 114, 114, 111, 119, 59, 24999, 256, 99, 116, 1170, 1175, 114, 59, 49152, 55349, 56479, 114, 111, 107, 59, 16656, 2048, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1213, 1216, 1220, 1227, 1246, 1250, 1255, 1262, 1269, 1313, 1327, 1334, 1362, 1373, 1376, 1381, 71, 59, 16714, 72, 32827, 208, 16592, 99, 117, 116, 101, 32827, 201, 16585, 384, 97, 105, 121, 1234, 1239, 1244, 114, 111, 110, 59, 16666, 114, 99, 32827, 202, 16586, 59, 17453, 111, 116, 59, 16662, 114, 59, 49152, 55349, 56584, 114, 97, 118, 101, 32827, 200, 16584, 101, 109, 101, 110, 116, 59, 25096, 256, 97, 112, 1274, 1278, 99, 114, 59, 16658, 116, 121, 595, 1286, 0, 0, 1298, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 26107, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 26027, 256, 103, 112, 1318, 1322, 111, 110, 59, 16664, 102, 59, 49152, 55349, 56636, 115, 105, 108, 111, 110, 59, 17301, 117, 256, 97, 105, 1340, 1353, 108, 256, 59, 84, 1346, 1347, 27253, 105, 108, 100, 101, 59, 25154, 108, 105, 98, 114, 105, 117, 109, 59, 25036, 256, 99, 105, 1367, 1370, 114, 59, 24880, 109, 59, 27251, 97, 59, 17303, 109, 108, 32827, 203, 16587, 256, 105, 112, 1386, 1391, 115, 116, 115, 59, 25091, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 24903, 640, 99, 102, 105, 111, 115, 1413, 1416, 1421, 1458, 1484, 121, 59, 17444, 114, 59, 49152, 55349, 56585, 108, 108, 101, 100, 595, 1431, 0, 0, 1443, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 26108, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 26026, 880, 1466, 0, 1471, 0, 0, 1476, 102, 59, 49152, 55349, 56637, 65, 108, 108, 59, 25088, 114, 105, 101, 114, 116, 114, 102, 59, 24881, 99, 242, 1483, 1536, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1512, 1516, 1519, 1530, 1536, 1554, 1558, 1563, 1565, 1571, 1644, 1650, 99, 121, 59, 17411, 32827, 62, 16446, 109, 109, 97, 256, 59, 100, 1527, 1528, 17299, 59, 17372, 114, 101, 118, 101, 59, 16670, 384, 101, 105, 121, 1543, 1548, 1552, 100, 105, 108, 59, 16674, 114, 99, 59, 16668, 59, 17427, 111, 116, 59, 16672, 114, 59, 49152, 55349, 56586, 59, 25305, 112, 102, 59, 49152, 55349, 56638, 101, 97, 116, 101, 114, 768, 69, 70, 71, 76, 83, 84, 1589, 1604, 1614, 1622, 1627, 1638, 113, 117, 97, 108, 256, 59, 76, 1598, 1599, 25189, 101, 115, 115, 59, 25307, 117, 108, 108, 69, 113, 117, 97, 108, 59, 25191, 114, 101, 97, 116, 101, 114, 59, 27298, 101, 115, 115, 59, 25207, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 27262, 105, 108, 100, 101, 59, 25203, 99, 114, 59, 49152, 55349, 56482, 59, 25195, 1024, 65, 97, 99, 102, 105, 111, 115, 117, 1669, 1675, 1686, 1691, 1694, 1706, 1726, 1738, 82, 68, 99, 121, 59, 17450, 256, 99, 116, 1680, 1684, 101, 107, 59, 17095, 59, 16478, 105, 114, 99, 59, 16676, 114, 59, 24844, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 24843, 496, 1711, 0, 1714, 102, 59, 24845, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 25856, 256, 99, 116, 1731, 1733, 242, 1705, 114, 111, 107, 59, 16678, 109, 112, 324, 1744, 1752, 111, 119, 110, 72, 117, 109, 240, 303, 113, 117, 97, 108, 59, 25167, 1792, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 1786, 1790, 1795, 1799, 1806, 1818, 1822, 1825, 1832, 1860, 1912, 1931, 1935, 1941, 99, 121, 59, 17429, 108, 105, 103, 59, 16690, 99, 121, 59, 17409, 99, 117, 116, 101, 32827, 205, 16589, 256, 105, 121, 1811, 1816, 114, 99, 32827, 206, 16590, 59, 17432, 111, 116, 59, 16688, 114, 59, 24849, 114, 97, 118, 101, 32827, 204, 16588, 384, 59, 97, 112, 1824, 1839, 1855, 256, 99, 103, 1844, 1847, 114, 59, 16682, 105, 110, 97, 114, 121, 73, 59, 24904, 108, 105, 101, 243, 989, 500, 1865, 0, 1890, 256, 59, 101, 1869, 1870, 25132, 256, 103, 114, 1875, 1880, 114, 97, 108, 59, 25131, 115, 101, 99, 116, 105, 111, 110, 59, 25282, 105, 115, 105, 98, 108, 101, 256, 67, 84, 1900, 1906, 111, 109, 109, 97, 59, 24675, 105, 109, 101, 115, 59, 24674, 384, 103, 112, 116, 1919, 1923, 1928, 111, 110, 59, 16686, 102, 59, 49152, 55349, 56640, 97, 59, 17305, 99, 114, 59, 24848, 105, 108, 100, 101, 59, 16680, 491, 1946, 0, 1950, 99, 121, 59, 17414, 108, 32827, 207, 16591, 640, 99, 102, 111, 115, 117, 1964, 1975, 1980, 1986, 2e3, 256, 105, 121, 1969, 1973, 114, 99, 59, 16692, 59, 17433, 114, 59, 49152, 55349, 56589, 112, 102, 59, 49152, 55349, 56641, 483, 1991, 0, 1996, 114, 59, 49152, 55349, 56485, 114, 99, 121, 59, 17416, 107, 99, 121, 59, 17412, 896, 72, 74, 97, 99, 102, 111, 115, 2020, 2024, 2028, 2033, 2045, 2050, 2056, 99, 121, 59, 17445, 99, 121, 59, 17420, 112, 112, 97, 59, 17306, 256, 101, 121, 2038, 2043, 100, 105, 108, 59, 16694, 59, 17434, 114, 59, 49152, 55349, 56590, 112, 102, 59, 49152, 55349, 56642, 99, 114, 59, 49152, 55349, 56486, 1408, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2085, 2089, 2092, 2128, 2147, 2483, 2488, 2503, 2509, 2615, 2631, 99, 121, 59, 17417, 32827, 60, 16444, 640, 99, 109, 110, 112, 114, 2103, 2108, 2113, 2116, 2125, 117, 116, 101, 59, 16697, 98, 100, 97, 59, 17307, 103, 59, 26602, 108, 97, 99, 101, 116, 114, 102, 59, 24850, 114, 59, 24990, 384, 97, 101, 121, 2135, 2140, 2145, 114, 111, 110, 59, 16701, 100, 105, 108, 59, 16699, 59, 17435, 256, 102, 115, 2152, 2416, 116, 1280, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2174, 2217, 2225, 2272, 2278, 2300, 2351, 2395, 912, 2410, 256, 110, 114, 2179, 2191, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 26600, 114, 111, 119, 384, 59, 66, 82, 2201, 2202, 2206, 24976, 97, 114, 59, 25060, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 25030, 101, 105, 108, 105, 110, 103, 59, 25352, 111, 501, 2231, 0, 2243, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 26598, 110, 468, 2248, 0, 2258, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26977, 101, 99, 116, 111, 114, 256, 59, 66, 2267, 2268, 25027, 97, 114, 59, 26969, 108, 111, 111, 114, 59, 25354, 105, 103, 104, 116, 256, 65, 86, 2287, 2293, 114, 114, 111, 119, 59, 24980, 101, 99, 116, 111, 114, 59, 26958, 256, 101, 114, 2305, 2327, 101, 384, 59, 65, 86, 2313, 2314, 2320, 25251, 114, 114, 111, 119, 59, 24996, 101, 99, 116, 111, 114, 59, 26970, 105, 97, 110, 103, 108, 101, 384, 59, 66, 69, 2340, 2341, 2345, 25266, 97, 114, 59, 27087, 113, 117, 97, 108, 59, 25268, 112, 384, 68, 84, 86, 2359, 2370, 2380, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 26961, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26976, 101, 99, 116, 111, 114, 256, 59, 66, 2390, 2391, 25023, 97, 114, 59, 26968, 101, 99, 116, 111, 114, 256, 59, 66, 2405, 2406, 25020, 97, 114, 59, 26962, 105, 103, 104, 116, 225, 924, 115, 768, 69, 70, 71, 76, 83, 84, 2430, 2443, 2453, 2461, 2466, 2477, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 25306, 117, 108, 108, 69, 113, 117, 97, 108, 59, 25190, 114, 101, 97, 116, 101, 114, 59, 25206, 101, 115, 115, 59, 27297, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 27261, 105, 108, 100, 101, 59, 25202, 114, 59, 49152, 55349, 56591, 256, 59, 101, 2493, 2494, 25304, 102, 116, 97, 114, 114, 111, 119, 59, 25050, 105, 100, 111, 116, 59, 16703, 384, 110, 112, 119, 2516, 2582, 2587, 103, 512, 76, 82, 108, 114, 2526, 2551, 2562, 2576, 101, 102, 116, 256, 65, 82, 2534, 2540, 114, 114, 111, 119, 59, 26613, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 26615, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 26614, 101, 102, 116, 256, 97, 114, 947, 2570, 105, 103, 104, 116, 225, 959, 105, 103, 104, 116, 225, 970, 102, 59, 49152, 55349, 56643, 101, 114, 256, 76, 82, 2594, 2604, 101, 102, 116, 65, 114, 114, 111, 119, 59, 24985, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 24984, 384, 99, 104, 116, 2622, 2624, 2626, 242, 2124, 59, 25008, 114, 111, 107, 59, 16705, 59, 25194, 1024, 97, 99, 101, 102, 105, 111, 115, 117, 2650, 2653, 2656, 2679, 2684, 2693, 2699, 2702, 112, 59, 26885, 121, 59, 17436, 256, 100, 108, 2661, 2671, 105, 117, 109, 83, 112, 97, 99, 101, 59, 24671, 108, 105, 110, 116, 114, 102, 59, 24883, 114, 59, 49152, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 25107, 112, 102, 59, 49152, 55349, 56644, 99, 242, 2678, 59, 17308, 1152, 74, 97, 99, 101, 102, 111, 115, 116, 117, 2723, 2727, 2733, 2752, 2836, 2841, 3473, 3479, 3486, 99, 121, 59, 17418, 99, 117, 116, 101, 59, 16707, 384, 97, 101, 121, 2740, 2745, 2750, 114, 111, 110, 59, 16711, 100, 105, 108, 59, 16709, 59, 17437, 384, 103, 115, 119, 2759, 2800, 2830, 97, 116, 105, 118, 101, 384, 77, 84, 86, 2771, 2783, 2792, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 24587, 104, 105, 256, 99, 110, 2790, 2776, 235, 2777, 101, 114, 121, 84, 104, 105, 238, 2777, 116, 101, 100, 256, 71, 76, 2808, 2822, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 242, 1651, 101, 115, 115, 76, 101, 115, 243, 2632, 76, 105, 110, 101, 59, 16394, 114, 59, 49152, 55349, 56593, 512, 66, 110, 112, 116, 2850, 2856, 2871, 2874, 114, 101, 97, 107, 59, 24672, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 16544, 102, 59, 24853, 1664, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 2901, 2902, 2922, 2940, 2977, 3051, 3076, 3166, 3204, 3238, 3288, 3425, 3461, 27372, 256, 111, 117, 2907, 2916, 110, 103, 114, 117, 101, 110, 116, 59, 25186, 112, 67, 97, 112, 59, 25197, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 25126, 384, 108, 113, 120, 2947, 2954, 2971, 101, 109, 101, 110, 116, 59, 25097, 117, 97, 108, 256, 59, 84, 2962, 2963, 25184, 105, 108, 100, 101, 59, 49152, 8770, 824, 105, 115, 116, 115, 59, 25092, 114, 101, 97, 116, 101, 114, 896, 59, 69, 70, 71, 76, 83, 84, 2998, 2999, 3005, 3017, 3027, 3032, 3045, 25199, 113, 117, 97, 108, 59, 25201, 117, 108, 108, 69, 113, 117, 97, 108, 59, 49152, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 49152, 8811, 824, 101, 115, 115, 59, 25209, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 49152, 10878, 824, 105, 108, 100, 101, 59, 25205, 117, 109, 112, 324, 3058, 3069, 111, 119, 110, 72, 117, 109, 112, 59, 49152, 8782, 824, 113, 117, 97, 108, 59, 49152, 8783, 824, 101, 256, 102, 115, 3082, 3111, 116, 84, 114, 105, 97, 110, 103, 108, 101, 384, 59, 66, 69, 3098, 3099, 3105, 25322, 97, 114, 59, 49152, 10703, 824, 113, 117, 97, 108, 59, 25324, 115, 768, 59, 69, 71, 76, 83, 84, 3125, 3126, 3132, 3140, 3147, 3160, 25198, 113, 117, 97, 108, 59, 25200, 114, 101, 97, 116, 101, 114, 59, 25208, 101, 115, 115, 59, 49152, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 49152, 10877, 824, 105, 108, 100, 101, 59, 25204, 101, 115, 116, 101, 100, 256, 71, 76, 3176, 3193, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 49152, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 49152, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 384, 59, 69, 83, 3218, 3219, 3227, 25216, 113, 117, 97, 108, 59, 49152, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 25312, 256, 101, 105, 3243, 3257, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 25100, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 384, 59, 66, 69, 3275, 3276, 3282, 25323, 97, 114, 59, 49152, 10704, 824, 113, 117, 97, 108, 59, 25325, 256, 113, 117, 3293, 3340, 117, 97, 114, 101, 83, 117, 256, 98, 112, 3304, 3321, 115, 101, 116, 256, 59, 69, 3312, 3315, 49152, 8847, 824, 113, 117, 97, 108, 59, 25314, 101, 114, 115, 101, 116, 256, 59, 69, 3331, 3334, 49152, 8848, 824, 113, 117, 97, 108, 59, 25315, 384, 98, 99, 112, 3347, 3364, 3406, 115, 101, 116, 256, 59, 69, 3355, 3358, 49152, 8834, 8402, 113, 117, 97, 108, 59, 25224, 99, 101, 101, 100, 115, 512, 59, 69, 83, 84, 3378, 3379, 3387, 3398, 25217, 113, 117, 97, 108, 59, 49152, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 25313, 105, 108, 100, 101, 59, 49152, 8831, 824, 101, 114, 115, 101, 116, 256, 59, 69, 3416, 3419, 49152, 8835, 8402, 113, 117, 97, 108, 59, 25225, 105, 108, 100, 101, 512, 59, 69, 70, 84, 3438, 3439, 3445, 3455, 25153, 113, 117, 97, 108, 59, 25156, 117, 108, 108, 69, 113, 117, 97, 108, 59, 25159, 105, 108, 100, 101, 59, 25161, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 25124, 99, 114, 59, 49152, 55349, 56489, 105, 108, 100, 101, 32827, 209, 16593, 59, 17309, 1792, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 3517, 3522, 3529, 3541, 3547, 3552, 3559, 3580, 3586, 3616, 3618, 3634, 3647, 3652, 108, 105, 103, 59, 16722, 99, 117, 116, 101, 32827, 211, 16595, 256, 105, 121, 3534, 3539, 114, 99, 32827, 212, 16596, 59, 17438, 98, 108, 97, 99, 59, 16720, 114, 59, 49152, 55349, 56594, 114, 97, 118, 101, 32827, 210, 16594, 384, 97, 101, 105, 3566, 3570, 3574, 99, 114, 59, 16716, 103, 97, 59, 17321, 99, 114, 111, 110, 59, 17311, 112, 102, 59, 49152, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 256, 68, 81, 3598, 3610, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 24604, 117, 111, 116, 101, 59, 24600, 59, 27220, 256, 99, 108, 3623, 3628, 114, 59, 49152, 55349, 56490, 97, 115, 104, 32827, 216, 16600, 105, 364, 3639, 3644, 100, 101, 32827, 213, 16597, 101, 115, 59, 27191, 109, 108, 32827, 214, 16598, 101, 114, 256, 66, 80, 3659, 3680, 256, 97, 114, 3664, 3667, 114, 59, 24638, 97, 99, 256, 101, 107, 3674, 3676, 59, 25566, 101, 116, 59, 25524, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 25564, 1152, 97, 99, 102, 104, 105, 108, 111, 114, 115, 3711, 3719, 3722, 3727, 3730, 3732, 3741, 3760, 3836, 114, 116, 105, 97, 108, 68, 59, 25090, 121, 59, 17439, 114, 59, 49152, 55349, 56595, 105, 59, 17318, 59, 17312, 117, 115, 77, 105, 110, 117, 115, 59, 16561, 256, 105, 112, 3746, 3757, 110, 99, 97, 114, 101, 112, 108, 97, 110, 229, 1693, 102, 59, 24857, 512, 59, 101, 105, 111, 3769, 3770, 3808, 3812, 27323, 99, 101, 100, 101, 115, 512, 59, 69, 83, 84, 3784, 3785, 3791, 3802, 25210, 113, 117, 97, 108, 59, 27311, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 25212, 105, 108, 100, 101, 59, 25214, 109, 101, 59, 24627, 256, 100, 112, 3817, 3822, 117, 99, 116, 59, 25103, 111, 114, 116, 105, 111, 110, 256, 59, 97, 549, 3833, 108, 59, 25117, 256, 99, 105, 3841, 3846, 114, 59, 49152, 55349, 56491, 59, 17320, 512, 85, 102, 111, 115, 3857, 3862, 3867, 3871, 79, 84, 32827, 34, 16418, 114, 59, 49152, 55349, 56596, 112, 102, 59, 24858, 99, 114, 59, 49152, 55349, 56492, 1536, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 3902, 3907, 3911, 3936, 3955, 4007, 4010, 4013, 4246, 4265, 4276, 4286, 97, 114, 114, 59, 26896, 71, 32827, 174, 16558, 384, 99, 110, 114, 3918, 3923, 3926, 117, 116, 101, 59, 16724, 103, 59, 26603, 114, 256, 59, 116, 3932, 3933, 24992, 108, 59, 26902, 384, 97, 101, 121, 3943, 3948, 3953, 114, 111, 110, 59, 16728, 100, 105, 108, 59, 16726, 59, 17440, 256, 59, 118, 3960, 3961, 24860, 101, 114, 115, 101, 256, 69, 85, 3970, 3993, 256, 108, 113, 3975, 3982, 101, 109, 101, 110, 116, 59, 25099, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 25035, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 26991, 114, 187, 3961, 111, 59, 17313, 103, 104, 116, 1024, 65, 67, 68, 70, 84, 85, 86, 97, 4033, 4075, 4083, 4130, 4136, 4187, 4231, 984, 256, 110, 114, 4038, 4050, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 26601, 114, 111, 119, 384, 59, 66, 76, 4060, 4061, 4065, 24978, 97, 114, 59, 25061, 101, 102, 116, 65, 114, 114, 111, 119, 59, 25028, 101, 105, 108, 105, 110, 103, 59, 25353, 111, 501, 4089, 0, 4101, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 26599, 110, 468, 4106, 0, 4116, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26973, 101, 99, 116, 111, 114, 256, 59, 66, 4125, 4126, 25026, 97, 114, 59, 26965, 108, 111, 111, 114, 59, 25355, 256, 101, 114, 4141, 4163, 101, 384, 59, 65, 86, 4149, 4150, 4156, 25250, 114, 114, 111, 119, 59, 24998, 101, 99, 116, 111, 114, 59, 26971, 105, 97, 110, 103, 108, 101, 384, 59, 66, 69, 4176, 4177, 4181, 25267, 97, 114, 59, 27088, 113, 117, 97, 108, 59, 25269, 112, 384, 68, 84, 86, 4195, 4206, 4216, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 26959, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26972, 101, 99, 116, 111, 114, 256, 59, 66, 4226, 4227, 25022, 97, 114, 59, 26964, 101, 99, 116, 111, 114, 256, 59, 66, 4241, 4242, 25024, 97, 114, 59, 26963, 256, 112, 117, 4251, 4254, 102, 59, 24861, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 26992, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 25051, 256, 99, 104, 4281, 4284, 114, 59, 24859, 59, 25009, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 27124, 1664, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 4324, 4337, 4343, 4349, 4377, 4382, 4433, 4438, 4449, 4455, 4533, 4539, 4543, 256, 67, 99, 4329, 4334, 72, 99, 121, 59, 17449, 121, 59, 17448, 70, 84, 99, 121, 59, 17452, 99, 117, 116, 101, 59, 16730, 640, 59, 97, 101, 105, 121, 4360, 4361, 4366, 4371, 4375, 27324, 114, 111, 110, 59, 16736, 100, 105, 108, 59, 16734, 114, 99, 59, 16732, 59, 17441, 114, 59, 49152, 55349, 56598, 111, 114, 116, 512, 68, 76, 82, 85, 4394, 4404, 4414, 4425, 111, 119, 110, 65, 114, 114, 111, 119, 187, 1054, 101, 102, 116, 65, 114, 114, 111, 119, 187, 2202, 105, 103, 104, 116, 65, 114, 114, 111, 119, 187, 4061, 112, 65, 114, 114, 111, 119, 59, 24977, 103, 109, 97, 59, 17315, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 25112, 112, 102, 59, 49152, 55349, 56650, 626, 4461, 0, 0, 4464, 116, 59, 25114, 97, 114, 101, 512, 59, 73, 83, 85, 4475, 4476, 4489, 4527, 26017, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 25235, 117, 256, 98, 112, 4495, 4510, 115, 101, 116, 256, 59, 69, 4503, 4504, 25231, 113, 117, 97, 108, 59, 25233, 101, 114, 115, 101, 116, 256, 59, 69, 4520, 4521, 25232, 113, 117, 97, 108, 59, 25234, 110, 105, 111, 110, 59, 25236, 99, 114, 59, 49152, 55349, 56494, 97, 114, 59, 25286, 512, 98, 99, 109, 112, 4552, 4571, 4617, 4619, 256, 59, 115, 4557, 4558, 25296, 101, 116, 256, 59, 69, 4557, 4565, 113, 117, 97, 108, 59, 25222, 256, 99, 104, 4576, 4613, 101, 101, 100, 115, 512, 59, 69, 83, 84, 4589, 4590, 4596, 4607, 25211, 113, 117, 97, 108, 59, 27312, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 25213, 105, 108, 100, 101, 59, 25215, 84, 104, 225, 3980, 59, 25105, 384, 59, 101, 115, 4626, 4627, 4643, 25297, 114, 115, 101, 116, 256, 59, 69, 4636, 4637, 25219, 113, 117, 97, 108, 59, 25223, 101, 116, 187, 4627, 1408, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 4670, 4676, 4681, 4693, 4702, 4721, 4726, 4767, 4802, 4808, 4817, 79, 82, 78, 32827, 222, 16606, 65, 68, 69, 59, 24866, 256, 72, 99, 4686, 4690, 99, 121, 59, 17419, 121, 59, 17446, 256, 98, 117, 4698, 4700, 59, 16393, 59, 17316, 384, 97, 101, 121, 4709, 4714, 4719, 114, 111, 110, 59, 16740, 100, 105, 108, 59, 16738, 59, 17442, 114, 59, 49152, 55349, 56599, 256, 101, 105, 4731, 4745, 498, 4736, 0, 4743, 101, 102, 111, 114, 101, 59, 25140, 97, 59, 17304, 256, 99, 110, 4750, 4760, 107, 83, 112, 97, 99, 101, 59, 49152, 8287, 8202, 83, 112, 97, 99, 101, 59, 24585, 108, 100, 101, 512, 59, 69, 70, 84, 4779, 4780, 4786, 4796, 25148, 113, 117, 97, 108, 59, 25155, 117, 108, 108, 69, 113, 117, 97, 108, 59, 25157, 105, 108, 100, 101, 59, 25160, 112, 102, 59, 49152, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 24795, 256, 99, 116, 4822, 4827, 114, 59, 49152, 55349, 56495, 114, 111, 107, 59, 16742, 2785, 4855, 4878, 4890, 4902, 0, 4908, 4913, 0, 0, 0, 0, 0, 4920, 4925, 4983, 4997, 0, 5119, 5124, 5130, 5136, 256, 99, 114, 4859, 4865, 117, 116, 101, 32827, 218, 16602, 114, 256, 59, 111, 4871, 4872, 24991, 99, 105, 114, 59, 26953, 114, 483, 4883, 0, 4886, 121, 59, 17422, 118, 101, 59, 16748, 256, 105, 121, 4894, 4899, 114, 99, 32827, 219, 16603, 59, 17443, 98, 108, 97, 99, 59, 16752, 114, 59, 49152, 55349, 56600, 114, 97, 118, 101, 32827, 217, 16601, 97, 99, 114, 59, 16746, 256, 100, 105, 4929, 4969, 101, 114, 256, 66, 80, 4936, 4957, 256, 97, 114, 4941, 4944, 114, 59, 16479, 97, 99, 256, 101, 107, 4951, 4953, 59, 25567, 101, 116, 59, 25525, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 25565, 111, 110, 256, 59, 80, 4976, 4977, 25283, 108, 117, 115, 59, 25230, 256, 103, 112, 4987, 4991, 111, 110, 59, 16754, 102, 59, 49152, 55349, 56652, 1024, 65, 68, 69, 84, 97, 100, 112, 115, 5013, 5038, 5048, 5060, 1e3, 5074, 5079, 5107, 114, 114, 111, 119, 384, 59, 66, 68, 4432, 5024, 5028, 97, 114, 59, 26898, 111, 119, 110, 65, 114, 114, 111, 119, 59, 25029, 111, 119, 110, 65, 114, 114, 111, 119, 59, 24981, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 26990, 101, 101, 256, 59, 65, 5067, 5068, 25253, 114, 114, 111, 119, 59, 24997, 111, 119, 110, 225, 1011, 101, 114, 256, 76, 82, 5086, 5096, 101, 102, 116, 65, 114, 114, 111, 119, 59, 24982, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 24983, 105, 256, 59, 108, 5113, 5114, 17362, 111, 110, 59, 17317, 105, 110, 103, 59, 16750, 99, 114, 59, 49152, 55349, 56496, 105, 108, 100, 101, 59, 16744, 109, 108, 32827, 220, 16604, 1152, 68, 98, 99, 100, 101, 102, 111, 115, 118, 5159, 5164, 5168, 5171, 5182, 5253, 5258, 5264, 5270, 97, 115, 104, 59, 25259, 97, 114, 59, 27371, 121, 59, 17426, 97, 115, 104, 256, 59, 108, 5179, 5180, 25257, 59, 27366, 256, 101, 114, 5187, 5189, 59, 25281, 384, 98, 116, 121, 5196, 5200, 5242, 97, 114, 59, 24598, 256, 59, 105, 5199, 5205, 99, 97, 108, 512, 66, 76, 83, 84, 5217, 5221, 5226, 5236, 97, 114, 59, 25123, 105, 110, 101, 59, 16508, 101, 112, 97, 114, 97, 116, 111, 114, 59, 26456, 105, 108, 100, 101, 59, 25152, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 24586, 114, 59, 49152, 55349, 56601, 112, 102, 59, 49152, 55349, 56653, 99, 114, 59, 49152, 55349, 56497, 100, 97, 115, 104, 59, 25258, 640, 99, 101, 102, 111, 115, 5287, 5292, 5297, 5302, 5308, 105, 114, 99, 59, 16756, 100, 103, 101, 59, 25280, 114, 59, 49152, 55349, 56602, 112, 102, 59, 49152, 55349, 56654, 99, 114, 59, 49152, 55349, 56498, 512, 102, 105, 111, 115, 5323, 5328, 5330, 5336, 114, 59, 49152, 55349, 56603, 59, 17310, 112, 102, 59, 49152, 55349, 56655, 99, 114, 59, 49152, 55349, 56499, 1152, 65, 73, 85, 97, 99, 102, 111, 115, 117, 5361, 5365, 5369, 5373, 5380, 5391, 5396, 5402, 5408, 99, 121, 59, 17455, 99, 121, 59, 17415, 99, 121, 59, 17454, 99, 117, 116, 101, 32827, 221, 16605, 256, 105, 121, 5385, 5389, 114, 99, 59, 16758, 59, 17451, 114, 59, 49152, 55349, 56604, 112, 102, 59, 49152, 55349, 56656, 99, 114, 59, 49152, 55349, 56500, 109, 108, 59, 16760, 1024, 72, 97, 99, 100, 101, 102, 111, 115, 5429, 5433, 5439, 5451, 5455, 5469, 5472, 5476, 99, 121, 59, 17430, 99, 117, 116, 101, 59, 16761, 256, 97, 121, 5444, 5449, 114, 111, 110, 59, 16765, 59, 17431, 111, 116, 59, 16763, 498, 5460, 0, 5467, 111, 87, 105, 100, 116, 232, 2777, 97, 59, 17302, 114, 59, 24872, 112, 102, 59, 24868, 99, 114, 59, 49152, 55349, 56501, 3041, 5507, 5514, 5520, 0, 5552, 5558, 5567, 0, 0, 0, 0, 5574, 5595, 5611, 5727, 5741, 0, 5781, 5787, 5810, 5817, 0, 5822, 99, 117, 116, 101, 32827, 225, 16609, 114, 101, 118, 101, 59, 16643, 768, 59, 69, 100, 105, 117, 121, 5532, 5533, 5537, 5539, 5544, 5549, 25150, 59, 49152, 8766, 819, 59, 25151, 114, 99, 32827, 226, 16610, 116, 101, 32955, 180, 774, 59, 17456, 108, 105, 103, 32827, 230, 16614, 256, 59, 114, 178, 5562, 59, 49152, 55349, 56606, 114, 97, 118, 101, 32827, 224, 16608, 256, 101, 112, 5578, 5590, 256, 102, 112, 5583, 5588, 115, 121, 109, 59, 24885, 232, 5587, 104, 97, 59, 17329, 256, 97, 112, 5599, 99, 256, 99, 108, 5604, 5607, 114, 59, 16641, 103, 59, 27199, 612, 5616, 0, 0, 5642, 640, 59, 97, 100, 115, 118, 5626, 5627, 5631, 5633, 5639, 25127, 110, 100, 59, 27221, 59, 27228, 108, 111, 112, 101, 59, 27224, 59, 27226, 896, 59, 101, 108, 109, 114, 115, 122, 5656, 5657, 5659, 5662, 5695, 5711, 5721, 25120, 59, 27044, 101, 187, 5657, 115, 100, 256, 59, 97, 5669, 5670, 25121, 1121, 5680, 5682, 5684, 5686, 5688, 5690, 5692, 5694, 59, 27048, 59, 27049, 59, 27050, 59, 27051, 59, 27052, 59, 27053, 59, 27054, 59, 27055, 116, 256, 59, 118, 5701, 5702, 25119, 98, 256, 59, 100, 5708, 5709, 25278, 59, 27037, 256, 112, 116, 5716, 5719, 104, 59, 25122, 187, 185, 97, 114, 114, 59, 25468, 256, 103, 112, 5731, 5735, 111, 110, 59, 16645, 102, 59, 49152, 55349, 56658, 896, 59, 69, 97, 101, 105, 111, 112, 4801, 5755, 5757, 5762, 5764, 5767, 5770, 59, 27248, 99, 105, 114, 59, 27247, 59, 25162, 100, 59, 25163, 115, 59, 16423, 114, 111, 120, 256, 59, 101, 4801, 5778, 241, 5763, 105, 110, 103, 32827, 229, 16613, 384, 99, 116, 121, 5793, 5798, 5800, 114, 59, 49152, 55349, 56502, 59, 16426, 109, 112, 256, 59, 101, 4801, 5807, 241, 648, 105, 108, 100, 101, 32827, 227, 16611, 109, 108, 32827, 228, 16612, 256, 99, 105, 5826, 5832, 111, 110, 105, 110, 244, 626, 110, 116, 59, 27153, 2048, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 5869, 5873, 5936, 5948, 5955, 5960, 6008, 6013, 6112, 6118, 6201, 6224, 5901, 6461, 6472, 6512, 111, 116, 59, 27373, 256, 99, 114, 5878, 5918, 107, 512, 99, 101, 112, 115, 5888, 5893, 5901, 5907, 111, 110, 103, 59, 25164, 112, 115, 105, 108, 111, 110, 59, 17398, 114, 105, 109, 101, 59, 24629, 105, 109, 256, 59, 101, 5914, 5915, 25149, 113, 59, 25293, 374, 5922, 5926, 101, 101, 59, 25277, 101, 100, 256, 59, 103, 5932, 5933, 25349, 101, 187, 5933, 114, 107, 256, 59, 116, 4956, 5943, 98, 114, 107, 59, 25526, 256, 111, 121, 5889, 5953, 59, 17457, 113, 117, 111, 59, 24606, 640, 99, 109, 112, 114, 116, 5971, 5979, 5985, 5988, 5992, 97, 117, 115, 256, 59, 101, 266, 265, 112, 116, 121, 118, 59, 27056, 115, 233, 5900, 110, 111, 245, 275, 384, 97, 104, 119, 5999, 6001, 6003, 59, 17330, 59, 24886, 101, 101, 110, 59, 25196, 114, 59, 49152, 55349, 56607, 103, 896, 99, 111, 115, 116, 117, 118, 119, 6029, 6045, 6067, 6081, 6101, 6107, 6110, 384, 97, 105, 117, 6036, 6038, 6042, 240, 1888, 114, 99, 59, 26095, 112, 187, 4977, 384, 100, 112, 116, 6052, 6056, 6061, 111, 116, 59, 27136, 108, 117, 115, 59, 27137, 105, 109, 101, 115, 59, 27138, 625, 6073, 0, 0, 6078, 99, 117, 112, 59, 27142, 97, 114, 59, 26117, 114, 105, 97, 110, 103, 108, 101, 256, 100, 117, 6093, 6098, 111, 119, 110, 59, 26045, 112, 59, 26035, 112, 108, 117, 115, 59, 27140, 101, 229, 5188, 229, 5293, 97, 114, 111, 119, 59, 26893, 384, 97, 107, 111, 6125, 6182, 6197, 256, 99, 110, 6130, 6179, 107, 384, 108, 115, 116, 6138, 1451, 6146, 111, 122, 101, 110, 103, 101, 59, 27115, 114, 105, 97, 110, 103, 108, 101, 512, 59, 100, 108, 114, 6162, 6163, 6168, 6173, 26036, 111, 119, 110, 59, 26046, 101, 102, 116, 59, 26050, 105, 103, 104, 116, 59, 26040, 107, 59, 25635, 433, 6187, 0, 6195, 434, 6191, 0, 6193, 59, 26002, 59, 26001, 52, 59, 26003, 99, 107, 59, 25992, 256, 101, 111, 6206, 6221, 256, 59, 113, 6211, 6214, 49152, 61, 8421, 117, 105, 118, 59, 49152, 8801, 8421, 116, 59, 25360, 512, 112, 116, 119, 120, 6233, 6238, 6247, 6252, 102, 59, 49152, 55349, 56659, 256, 59, 116, 5067, 6243, 111, 109, 187, 5068, 116, 105, 101, 59, 25288, 1536, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 6277, 6294, 6314, 6331, 6359, 6363, 6380, 6399, 6405, 6410, 6416, 6433, 512, 76, 82, 108, 114, 6286, 6288, 6290, 6292, 59, 25943, 59, 25940, 59, 25942, 59, 25939, 640, 59, 68, 85, 100, 117, 6305, 6306, 6308, 6310, 6312, 25936, 59, 25958, 59, 25961, 59, 25956, 59, 25959, 512, 76, 82, 108, 114, 6323, 6325, 6327, 6329, 59, 25949, 59, 25946, 59, 25948, 59, 25945, 896, 59, 72, 76, 82, 104, 108, 114, 6346, 6347, 6349, 6351, 6353, 6355, 6357, 25937, 59, 25964, 59, 25955, 59, 25952, 59, 25963, 59, 25954, 59, 25951, 111, 120, 59, 27081, 512, 76, 82, 108, 114, 6372, 6374, 6376, 6378, 59, 25941, 59, 25938, 59, 25872, 59, 25868, 640, 59, 68, 85, 100, 117, 1725, 6391, 6393, 6395, 6397, 59, 25957, 59, 25960, 59, 25900, 59, 25908, 105, 110, 117, 115, 59, 25247, 108, 117, 115, 59, 25246, 105, 109, 101, 115, 59, 25248, 512, 76, 82, 108, 114, 6425, 6427, 6429, 6431, 59, 25947, 59, 25944, 59, 25880, 59, 25876, 896, 59, 72, 76, 82, 104, 108, 114, 6448, 6449, 6451, 6453, 6455, 6457, 6459, 25858, 59, 25962, 59, 25953, 59, 25950, 59, 25916, 59, 25892, 59, 25884, 256, 101, 118, 291, 6466, 98, 97, 114, 32827, 166, 16550, 512, 99, 101, 105, 111, 6481, 6486, 6490, 6496, 114, 59, 49152, 55349, 56503, 109, 105, 59, 24655, 109, 256, 59, 101, 5914, 5916, 108, 384, 59, 98, 104, 6504, 6505, 6507, 16476, 59, 27077, 115, 117, 98, 59, 26568, 364, 6516, 6526, 108, 256, 59, 101, 6521, 6522, 24610, 116, 187, 6522, 112, 384, 59, 69, 101, 303, 6533, 6535, 59, 27310, 256, 59, 113, 1756, 1755, 3297, 6567, 0, 6632, 6673, 6677, 6706, 0, 6711, 6736, 0, 0, 6836, 0, 0, 6849, 0, 0, 6945, 6958, 6989, 6994, 0, 7165, 0, 7180, 384, 99, 112, 114, 6573, 6578, 6621, 117, 116, 101, 59, 16647, 768, 59, 97, 98, 99, 100, 115, 6591, 6592, 6596, 6602, 6613, 6617, 25129, 110, 100, 59, 27204, 114, 99, 117, 112, 59, 27209, 256, 97, 117, 6607, 6610, 112, 59, 27211, 112, 59, 27207, 111, 116, 59, 27200, 59, 49152, 8745, 65024, 256, 101, 111, 6626, 6629, 116, 59, 24641, 238, 1683, 512, 97, 101, 105, 117, 6640, 6651, 6657, 6661, 496, 6645, 0, 6648, 115, 59, 27213, 111, 110, 59, 16653, 100, 105, 108, 32827, 231, 16615, 114, 99, 59, 16649, 112, 115, 256, 59, 115, 6668, 6669, 27212, 109, 59, 27216, 111, 116, 59, 16651, 384, 100, 109, 110, 6683, 6688, 6694, 105, 108, 32955, 184, 429, 112, 116, 121, 118, 59, 27058, 116, 33024, 162, 59, 101, 6701, 6702, 16546, 114, 228, 434, 114, 59, 49152, 55349, 56608, 384, 99, 101, 105, 6717, 6720, 6733, 121, 59, 17479, 99, 107, 256, 59, 109, 6727, 6728, 26387, 97, 114, 107, 187, 6728, 59, 17351, 114, 896, 59, 69, 99, 101, 102, 109, 115, 6751, 6752, 6754, 6763, 6820, 6826, 6830, 26059, 59, 27075, 384, 59, 101, 108, 6761, 6762, 6765, 17094, 113, 59, 25175, 101, 609, 6772, 0, 0, 6792, 114, 114, 111, 119, 256, 108, 114, 6780, 6785, 101, 102, 116, 59, 25018, 105, 103, 104, 116, 59, 25019, 640, 82, 83, 97, 99, 100, 6802, 6804, 6806, 6810, 6815, 187, 3911, 59, 25800, 115, 116, 59, 25243, 105, 114, 99, 59, 25242, 97, 115, 104, 59, 25245, 110, 105, 110, 116, 59, 27152, 105, 100, 59, 27375, 99, 105, 114, 59, 27074, 117, 98, 115, 256, 59, 117, 6843, 6844, 26211, 105, 116, 187, 6844, 748, 6855, 6868, 6906, 0, 6922, 111, 110, 256, 59, 101, 6861, 6862, 16442, 256, 59, 113, 199, 198, 621, 6873, 0, 0, 6882, 97, 256, 59, 116, 6878, 6879, 16428, 59, 16448, 384, 59, 102, 108, 6888, 6889, 6891, 25089, 238, 4448, 101, 256, 109, 120, 6897, 6902, 101, 110, 116, 187, 6889, 101, 243, 589, 487, 6910, 0, 6919, 256, 59, 100, 4795, 6914, 111, 116, 59, 27245, 110, 244, 582, 384, 102, 114, 121, 6928, 6932, 6935, 59, 49152, 55349, 56660, 111, 228, 596, 33024, 169, 59, 115, 341, 6941, 114, 59, 24855, 256, 97, 111, 6949, 6953, 114, 114, 59, 25013, 115, 115, 59, 26391, 256, 99, 117, 6962, 6967, 114, 59, 49152, 55349, 56504, 256, 98, 112, 6972, 6980, 256, 59, 101, 6977, 6978, 27343, 59, 27345, 256, 59, 101, 6985, 6986, 27344, 59, 27346, 100, 111, 116, 59, 25327, 896, 100, 101, 108, 112, 114, 118, 119, 7008, 7020, 7031, 7042, 7084, 7124, 7161, 97, 114, 114, 256, 108, 114, 7016, 7018, 59, 26936, 59, 26933, 624, 7026, 0, 0, 7029, 114, 59, 25310, 99, 59, 25311, 97, 114, 114, 256, 59, 112, 7039, 7040, 25014, 59, 26941, 768, 59, 98, 99, 100, 111, 115, 7055, 7056, 7062, 7073, 7077, 7080, 25130, 114, 99, 97, 112, 59, 27208, 256, 97, 117, 7067, 7070, 112, 59, 27206, 112, 59, 27210, 111, 116, 59, 25229, 114, 59, 27205, 59, 49152, 8746, 65024, 512, 97, 108, 114, 118, 7093, 7103, 7134, 7139, 114, 114, 256, 59, 109, 7100, 7101, 25015, 59, 26940, 121, 384, 101, 118, 119, 7111, 7124, 7128, 113, 624, 7118, 0, 0, 7122, 114, 101, 227, 7027, 117, 227, 7029, 101, 101, 59, 25294, 101, 100, 103, 101, 59, 25295, 101, 110, 32827, 164, 16548, 101, 97, 114, 114, 111, 119, 256, 108, 114, 7150, 7155, 101, 102, 116, 187, 7040, 105, 103, 104, 116, 187, 7101, 101, 228, 7133, 256, 99, 105, 7169, 7175, 111, 110, 105, 110, 244, 503, 110, 116, 59, 25137, 108, 99, 116, 121, 59, 25389, 2432, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 7224, 7227, 7231, 7261, 7273, 7285, 7306, 7326, 7340, 7351, 7419, 7423, 7437, 7547, 7569, 7595, 7611, 7622, 7629, 114, 242, 897, 97, 114, 59, 26981, 512, 103, 108, 114, 115, 7240, 7245, 7250, 7252, 103, 101, 114, 59, 24608, 101, 116, 104, 59, 24888, 242, 4403, 104, 256, 59, 118, 7258, 7259, 24592, 187, 2314, 363, 7265, 7271, 97, 114, 111, 119, 59, 26895, 97, 227, 789, 256, 97, 121, 7278, 7283, 114, 111, 110, 59, 16655, 59, 17460, 384, 59, 97, 111, 818, 7292, 7300, 256, 103, 114, 703, 7297, 114, 59, 25034, 116, 115, 101, 113, 59, 27255, 384, 103, 108, 109, 7313, 7316, 7320, 32827, 176, 16560, 116, 97, 59, 17332, 112, 116, 121, 118, 59, 27057, 256, 105, 114, 7331, 7336, 115, 104, 116, 59, 27007, 59, 49152, 55349, 56609, 97, 114, 256, 108, 114, 7347, 7349, 187, 2268, 187, 4126, 640, 97, 101, 103, 115, 118, 7362, 888, 7382, 7388, 7392, 109, 384, 59, 111, 115, 806, 7370, 7380, 110, 100, 256, 59, 115, 806, 7377, 117, 105, 116, 59, 26214, 97, 109, 109, 97, 59, 17373, 105, 110, 59, 25330, 384, 59, 105, 111, 7399, 7400, 7416, 16631, 100, 101, 33024, 247, 59, 111, 7399, 7408, 110, 116, 105, 109, 101, 115, 59, 25287, 110, 248, 7415, 99, 121, 59, 17490, 99, 623, 7430, 0, 0, 7434, 114, 110, 59, 25374, 111, 112, 59, 25357, 640, 108, 112, 116, 117, 119, 7448, 7453, 7458, 7497, 7509, 108, 97, 114, 59, 16420, 102, 59, 49152, 55349, 56661, 640, 59, 101, 109, 112, 115, 779, 7469, 7479, 7485, 7490, 113, 256, 59, 100, 850, 7475, 111, 116, 59, 25169, 105, 110, 117, 115, 59, 25144, 108, 117, 115, 59, 25108, 113, 117, 97, 114, 101, 59, 25249, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 229, 250, 110, 384, 97, 100, 104, 4398, 7517, 7527, 111, 119, 110, 97, 114, 114, 111, 119, 243, 7299, 97, 114, 112, 111, 111, 110, 256, 108, 114, 7538, 7542, 101, 102, 244, 7348, 105, 103, 104, 244, 7350, 354, 7551, 7557, 107, 97, 114, 111, 247, 3906, 623, 7562, 0, 0, 7566, 114, 110, 59, 25375, 111, 112, 59, 25356, 384, 99, 111, 116, 7576, 7587, 7590, 256, 114, 121, 7581, 7585, 59, 49152, 55349, 56505, 59, 17493, 108, 59, 27126, 114, 111, 107, 59, 16657, 256, 100, 114, 7600, 7604, 111, 116, 59, 25329, 105, 256, 59, 102, 7610, 6166, 26047, 256, 97, 104, 7616, 7619, 114, 242, 1065, 97, 242, 4006, 97, 110, 103, 108, 101, 59, 27046, 256, 99, 105, 7634, 7637, 121, 59, 17503, 103, 114, 97, 114, 114, 59, 26623, 2304, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 7681, 7689, 7705, 7736, 1400, 7740, 7753, 7777, 7806, 7845, 7855, 7869, 7905, 7978, 7991, 8004, 8014, 8026, 256, 68, 111, 7686, 7476, 111, 244, 7305, 256, 99, 115, 7694, 7700, 117, 116, 101, 32827, 233, 16617, 116, 101, 114, 59, 27246, 512, 97, 105, 111, 121, 7714, 7719, 7729, 7734, 114, 111, 110, 59, 16667, 114, 256, 59, 99, 7725, 7726, 25174, 32827, 234, 16618, 108, 111, 110, 59, 25173, 59, 17485, 111, 116, 59, 16663, 256, 68, 114, 7745, 7749, 111, 116, 59, 25170, 59, 49152, 55349, 56610, 384, 59, 114, 115, 7760, 7761, 7767, 27290, 97, 118, 101, 32827, 232, 16616, 256, 59, 100, 7772, 7773, 27286, 111, 116, 59, 27288, 512, 59, 105, 108, 115, 7786, 7787, 7794, 7796, 27289, 110, 116, 101, 114, 115, 59, 25575, 59, 24851, 256, 59, 100, 7801, 7802, 27285, 111, 116, 59, 27287, 384, 97, 112, 115, 7813, 7817, 7831, 99, 114, 59, 16659, 116, 121, 384, 59, 115, 118, 7826, 7827, 7829, 25093, 101, 116, 187, 7827, 112, 256, 49, 59, 7837, 7844, 307, 7841, 7843, 59, 24580, 59, 24581, 24579, 256, 103, 115, 7850, 7852, 59, 16715, 112, 59, 24578, 256, 103, 112, 7860, 7864, 111, 110, 59, 16665, 102, 59, 49152, 55349, 56662, 384, 97, 108, 115, 7876, 7886, 7890, 114, 256, 59, 115, 7882, 7883, 25301, 108, 59, 27107, 117, 115, 59, 27249, 105, 384, 59, 108, 118, 7898, 7899, 7903, 17333, 111, 110, 187, 7899, 59, 17397, 512, 99, 115, 117, 118, 7914, 7923, 7947, 7971, 256, 105, 111, 7919, 7729, 114, 99, 187, 7726, 617, 7929, 0, 0, 7931, 237, 1352, 97, 110, 116, 256, 103, 108, 7938, 7942, 116, 114, 187, 7773, 101, 115, 115, 187, 7802, 384, 97, 101, 105, 7954, 7958, 7962, 108, 115, 59, 16445, 115, 116, 59, 25183, 118, 256, 59, 68, 565, 7968, 68, 59, 27256, 112, 97, 114, 115, 108, 59, 27109, 256, 68, 97, 7983, 7987, 111, 116, 59, 25171, 114, 114, 59, 26993, 384, 99, 100, 105, 7998, 8001, 7928, 114, 59, 24879, 111, 244, 850, 256, 97, 104, 8009, 8011, 59, 17335, 32827, 240, 16624, 256, 109, 114, 8019, 8023, 108, 32827, 235, 16619, 111, 59, 24748, 384, 99, 105, 112, 8033, 8036, 8039, 108, 59, 16417, 115, 244, 1390, 256, 101, 111, 8044, 8052, 99, 116, 97, 116, 105, 111, 238, 1369, 110, 101, 110, 116, 105, 97, 108, 229, 1401, 2529, 8082, 0, 8094, 0, 8097, 8103, 0, 0, 8134, 8140, 0, 8147, 0, 8166, 8170, 8192, 0, 8200, 8282, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 241, 7748, 121, 59, 17476, 109, 97, 108, 101, 59, 26176, 384, 105, 108, 114, 8109, 8115, 8129, 108, 105, 103, 59, 32768, 64259, 617, 8121, 0, 0, 8125, 103, 59, 32768, 64256, 105, 103, 59, 32768, 64260, 59, 49152, 55349, 56611, 108, 105, 103, 59, 32768, 64257, 108, 105, 103, 59, 49152, 102, 106, 384, 97, 108, 116, 8153, 8156, 8161, 116, 59, 26221, 105, 103, 59, 32768, 64258, 110, 115, 59, 26033, 111, 102, 59, 16786, 496, 8174, 0, 8179, 102, 59, 49152, 55349, 56663, 256, 97, 107, 1471, 8183, 256, 59, 118, 8188, 8189, 25300, 59, 27353, 97, 114, 116, 105, 110, 116, 59, 27149, 256, 97, 111, 8204, 8277, 256, 99, 115, 8209, 8274, 945, 8218, 8240, 8248, 8261, 8264, 0, 8272, 946, 8226, 8229, 8231, 8234, 8236, 0, 8238, 32827, 189, 16573, 59, 24915, 32827, 188, 16572, 59, 24917, 59, 24921, 59, 24923, 435, 8244, 0, 8246, 59, 24916, 59, 24918, 692, 8254, 8257, 0, 0, 8259, 32827, 190, 16574, 59, 24919, 59, 24924, 53, 59, 24920, 438, 8268, 0, 8270, 59, 24922, 59, 24925, 56, 59, 24926, 108, 59, 24644, 119, 110, 59, 25378, 99, 114, 59, 49152, 55349, 56507, 2176, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 8322, 8329, 8351, 8357, 8368, 8372, 8432, 8437, 8442, 8447, 8451, 8466, 8504, 791, 8510, 8530, 8606, 256, 59, 108, 1613, 8327, 59, 27276, 384, 99, 109, 112, 8336, 8341, 8349, 117, 116, 101, 59, 16885, 109, 97, 256, 59, 100, 8348, 7386, 17331, 59, 27270, 114, 101, 118, 101, 59, 16671, 256, 105, 121, 8362, 8366, 114, 99, 59, 16669, 59, 17459, 111, 116, 59, 16673, 512, 59, 108, 113, 115, 1598, 1602, 8381, 8393, 384, 59, 113, 115, 1598, 1612, 8388, 108, 97, 110, 244, 1637, 512, 59, 99, 100, 108, 1637, 8402, 8405, 8421, 99, 59, 27305, 111, 116, 256, 59, 111, 8412, 8413, 27264, 256, 59, 108, 8418, 8419, 27266, 59, 27268, 256, 59, 101, 8426, 8429, 49152, 8923, 65024, 115, 59, 27284, 114, 59, 49152, 55349, 56612, 256, 59, 103, 1651, 1563, 109, 101, 108, 59, 24887, 99, 121, 59, 17491, 512, 59, 69, 97, 106, 1626, 8460, 8462, 8464, 59, 27282, 59, 27301, 59, 27300, 512, 69, 97, 101, 115, 8475, 8477, 8489, 8500, 59, 25193, 112, 256, 59, 112, 8483, 8484, 27274, 114, 111, 120, 187, 8484, 256, 59, 113, 8494, 8495, 27272, 256, 59, 113, 8494, 8475, 105, 109, 59, 25319, 112, 102, 59, 49152, 55349, 56664, 256, 99, 105, 8515, 8518, 114, 59, 24842, 109, 384, 59, 101, 108, 1643, 8526, 8528, 59, 27278, 59, 27280, 33536, 62, 59, 99, 100, 108, 113, 114, 1518, 8544, 8554, 8558, 8563, 8569, 256, 99, 105, 8549, 8551, 59, 27303, 114, 59, 27258, 111, 116, 59, 25303, 80, 97, 114, 59, 27029, 117, 101, 115, 116, 59, 27260, 640, 97, 100, 101, 108, 115, 8580, 8554, 8592, 1622, 8603, 496, 8585, 0, 8590, 112, 114, 111, 248, 8350, 114, 59, 27e3, 113, 256, 108, 113, 1599, 8598, 108, 101, 115, 243, 8328, 105, 237, 1643, 256, 101, 110, 8611, 8621, 114, 116, 110, 101, 113, 113, 59, 49152, 8809, 65024, 197, 8618, 1280, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 8644, 8647, 8689, 8693, 8698, 8728, 8733, 8751, 8808, 8829, 114, 242, 928, 512, 105, 108, 109, 114, 8656, 8660, 8663, 8667, 114, 115, 240, 5252, 102, 187, 8228, 105, 108, 244, 1705, 256, 100, 114, 8672, 8676, 99, 121, 59, 17482, 384, 59, 99, 119, 2292, 8683, 8687, 105, 114, 59, 26952, 59, 25005, 97, 114, 59, 24847, 105, 114, 99, 59, 16677, 384, 97, 108, 114, 8705, 8718, 8723, 114, 116, 115, 256, 59, 117, 8713, 8714, 26213, 105, 116, 187, 8714, 108, 105, 112, 59, 24614, 99, 111, 110, 59, 25273, 114, 59, 49152, 55349, 56613, 115, 256, 101, 119, 8739, 8745, 97, 114, 111, 119, 59, 26917, 97, 114, 111, 119, 59, 26918, 640, 97, 109, 111, 112, 114, 8762, 8766, 8771, 8798, 8803, 114, 114, 59, 25087, 116, 104, 116, 59, 25147, 107, 256, 108, 114, 8777, 8787, 101, 102, 116, 97, 114, 114, 111, 119, 59, 25001, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 25002, 102, 59, 49152, 55349, 56665, 98, 97, 114, 59, 24597, 384, 99, 108, 116, 8815, 8820, 8824, 114, 59, 49152, 55349, 56509, 97, 115, 232, 8692, 114, 111, 107, 59, 16679, 256, 98, 112, 8834, 8839, 117, 108, 108, 59, 24643, 104, 101, 110, 187, 7259, 2785, 8867, 0, 8874, 0, 8888, 8901, 8910, 0, 8917, 8947, 0, 0, 8952, 8994, 9063, 9058, 9087, 0, 9094, 9130, 9140, 99, 117, 116, 101, 32827, 237, 16621, 384, 59, 105, 121, 1905, 8880, 8885, 114, 99, 32827, 238, 16622, 59, 17464, 256, 99, 120, 8892, 8895, 121, 59, 17461, 99, 108, 32827, 161, 16545, 256, 102, 114, 927, 8905, 59, 49152, 55349, 56614, 114, 97, 118, 101, 32827, 236, 16620, 512, 59, 105, 110, 111, 1854, 8925, 8937, 8942, 256, 105, 110, 8930, 8934, 110, 116, 59, 27148, 116, 59, 25133, 102, 105, 110, 59, 27100, 116, 97, 59, 24873, 108, 105, 103, 59, 16691, 384, 97, 111, 112, 8958, 8986, 8989, 384, 99, 103, 116, 8965, 8968, 8983, 114, 59, 16683, 384, 101, 108, 112, 1823, 8975, 8979, 105, 110, 229, 1934, 97, 114, 244, 1824, 104, 59, 16689, 102, 59, 25271, 101, 100, 59, 16821, 640, 59, 99, 102, 111, 116, 1268, 9004, 9009, 9021, 9025, 97, 114, 101, 59, 24837, 105, 110, 256, 59, 116, 9016, 9017, 25118, 105, 101, 59, 27101, 100, 111, 244, 8985, 640, 59, 99, 101, 108, 112, 1879, 9036, 9040, 9051, 9057, 97, 108, 59, 25274, 256, 103, 114, 9045, 9049, 101, 114, 243, 5475, 227, 9037, 97, 114, 104, 107, 59, 27159, 114, 111, 100, 59, 27196, 512, 99, 103, 112, 116, 9071, 9074, 9078, 9083, 121, 59, 17489, 111, 110, 59, 16687, 102, 59, 49152, 55349, 56666, 97, 59, 17337, 117, 101, 115, 116, 32827, 191, 16575, 256, 99, 105, 9098, 9103, 114, 59, 49152, 55349, 56510, 110, 640, 59, 69, 100, 115, 118, 1268, 9115, 9117, 9121, 1267, 59, 25337, 111, 116, 59, 25333, 256, 59, 118, 9126, 9127, 25332, 59, 25331, 256, 59, 105, 1911, 9134, 108, 100, 101, 59, 16681, 491, 9144, 0, 9148, 99, 121, 59, 17494, 108, 32827, 239, 16623, 768, 99, 102, 109, 111, 115, 117, 9164, 9175, 9180, 9185, 9191, 9205, 256, 105, 121, 9169, 9173, 114, 99, 59, 16693, 59, 17465, 114, 59, 49152, 55349, 56615, 97, 116, 104, 59, 16951, 112, 102, 59, 49152, 55349, 56667, 483, 9196, 0, 9201, 114, 59, 49152, 55349, 56511, 114, 99, 121, 59, 17496, 107, 99, 121, 59, 17492, 1024, 97, 99, 102, 103, 104, 106, 111, 115, 9227, 9238, 9250, 9255, 9261, 9265, 9269, 9275, 112, 112, 97, 256, 59, 118, 9235, 9236, 17338, 59, 17392, 256, 101, 121, 9243, 9248, 100, 105, 108, 59, 16695, 59, 17466, 114, 59, 49152, 55349, 56616, 114, 101, 101, 110, 59, 16696, 99, 121, 59, 17477, 99, 121, 59, 17500, 112, 102, 59, 49152, 55349, 56668, 99, 114, 59, 49152, 55349, 56512, 2944, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 9328, 9345, 9350, 9357, 9361, 9486, 9533, 9562, 9600, 9806, 9822, 9829, 9849, 9853, 9882, 9906, 9944, 10077, 10088, 10123, 10176, 10241, 10258, 384, 97, 114, 116, 9335, 9338, 9340, 114, 242, 2502, 242, 917, 97, 105, 108, 59, 26907, 97, 114, 114, 59, 26894, 256, 59, 103, 2452, 9355, 59, 27275, 97, 114, 59, 26978, 2403, 9381, 0, 9386, 0, 9393, 0, 0, 0, 0, 0, 9397, 9402, 0, 9414, 9416, 9421, 0, 9465, 117, 116, 101, 59, 16698, 109, 112, 116, 121, 118, 59, 27060, 114, 97, 238, 2124, 98, 100, 97, 59, 17339, 103, 384, 59, 100, 108, 2190, 9409, 9411, 59, 27025, 229, 2190, 59, 27269, 117, 111, 32827, 171, 16555, 114, 1024, 59, 98, 102, 104, 108, 112, 115, 116, 2201, 9438, 9446, 9449, 9451, 9454, 9457, 9461, 256, 59, 102, 2205, 9443, 115, 59, 26911, 115, 59, 26909, 235, 8786, 112, 59, 25003, 108, 59, 26937, 105, 109, 59, 26995, 108, 59, 24994, 384, 59, 97, 101, 9471, 9472, 9476, 27307, 105, 108, 59, 26905, 256, 59, 115, 9481, 9482, 27309, 59, 49152, 10925, 65024, 384, 97, 98, 114, 9493, 9497, 9501, 114, 114, 59, 26892, 114, 107, 59, 26482, 256, 97, 107, 9506, 9516, 99, 256, 101, 107, 9512, 9514, 59, 16507, 59, 16475, 256, 101, 115, 9521, 9523, 59, 27019, 108, 256, 100, 117, 9529, 9531, 59, 27023, 59, 27021, 512, 97, 101, 117, 121, 9542, 9547, 9558, 9560, 114, 111, 110, 59, 16702, 256, 100, 105, 9552, 9556, 105, 108, 59, 16700, 236, 2224, 226, 9513, 59, 17467, 512, 99, 113, 114, 115, 9571, 9574, 9581, 9597, 97, 59, 26934, 117, 111, 256, 59, 114, 3609, 5958, 256, 100, 117, 9586, 9591, 104, 97, 114, 59, 26983, 115, 104, 97, 114, 59, 26955, 104, 59, 25010, 640, 59, 102, 103, 113, 115, 9611, 9612, 2441, 9715, 9727, 25188, 116, 640, 97, 104, 108, 114, 116, 9624, 9636, 9655, 9666, 9704, 114, 114, 111, 119, 256, 59, 116, 2201, 9633, 97, 233, 9462, 97, 114, 112, 111, 111, 110, 256, 100, 117, 9647, 9652, 111, 119, 110, 187, 1114, 112, 187, 2406, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 25031, 105, 103, 104, 116, 384, 97, 104, 115, 9677, 9686, 9694, 114, 114, 111, 119, 256, 59, 115, 2292, 2215, 97, 114, 112, 111, 111, 110, 243, 3992, 113, 117, 105, 103, 97, 114, 114, 111, 247, 8688, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 25291, 384, 59, 113, 115, 9611, 2451, 9722, 108, 97, 110, 244, 2476, 640, 59, 99, 100, 103, 115, 2476, 9738, 9741, 9757, 9768, 99, 59, 27304, 111, 116, 256, 59, 111, 9748, 9749, 27263, 256, 59, 114, 9754, 9755, 27265, 59, 27267, 256, 59, 101, 9762, 9765, 49152, 8922, 65024, 115, 59, 27283, 640, 97, 100, 101, 103, 115, 9779, 9785, 9789, 9801, 9803, 112, 112, 114, 111, 248, 9414, 111, 116, 59, 25302, 113, 256, 103, 113, 9795, 9797, 244, 2441, 103, 116, 242, 9356, 244, 2459, 105, 237, 2482, 384, 105, 108, 114, 9813, 2273, 9818, 115, 104, 116, 59, 27004, 59, 49152, 55349, 56617, 256, 59, 69, 2460, 9827, 59, 27281, 353, 9833, 9846, 114, 256, 100, 117, 9650, 9838, 256, 59, 108, 2405, 9843, 59, 26986, 108, 107, 59, 25988, 99, 121, 59, 17497, 640, 59, 97, 99, 104, 116, 2632, 9864, 9867, 9873, 9878, 114, 242, 9665, 111, 114, 110, 101, 242, 7432, 97, 114, 100, 59, 26987, 114, 105, 59, 26106, 256, 105, 111, 9887, 9892, 100, 111, 116, 59, 16704, 117, 115, 116, 256, 59, 97, 9900, 9901, 25520, 99, 104, 101, 187, 9901, 512, 69, 97, 101, 115, 9915, 9917, 9929, 9940, 59, 25192, 112, 256, 59, 112, 9923, 9924, 27273, 114, 111, 120, 187, 9924, 256, 59, 113, 9934, 9935, 27271, 256, 59, 113, 9934, 9915, 105, 109, 59, 25318, 1024, 97, 98, 110, 111, 112, 116, 119, 122, 9961, 9972, 9975, 10010, 10031, 10049, 10055, 10064, 256, 110, 114, 9966, 9969, 103, 59, 26604, 114, 59, 25085, 114, 235, 2241, 103, 384, 108, 109, 114, 9983, 9997, 10004, 101, 102, 116, 256, 97, 114, 2534, 9991, 105, 103, 104, 116, 225, 2546, 97, 112, 115, 116, 111, 59, 26620, 105, 103, 104, 116, 225, 2557, 112, 97, 114, 114, 111, 119, 256, 108, 114, 10021, 10025, 101, 102, 244, 9453, 105, 103, 104, 116, 59, 25004, 384, 97, 102, 108, 10038, 10041, 10045, 114, 59, 27013, 59, 49152, 55349, 56669, 117, 115, 59, 27181, 105, 109, 101, 115, 59, 27188, 353, 10059, 10063, 115, 116, 59, 25111, 225, 4942, 384, 59, 101, 102, 10071, 10072, 6144, 26058, 110, 103, 101, 187, 10072, 97, 114, 256, 59, 108, 10084, 10085, 16424, 116, 59, 27027, 640, 97, 99, 104, 109, 116, 10099, 10102, 10108, 10117, 10119, 114, 242, 2216, 111, 114, 110, 101, 242, 7564, 97, 114, 256, 59, 100, 3992, 10115, 59, 26989, 59, 24590, 114, 105, 59, 25279, 768, 97, 99, 104, 105, 113, 116, 10136, 10141, 2624, 10146, 10158, 10171, 113, 117, 111, 59, 24633, 114, 59, 49152, 55349, 56513, 109, 384, 59, 101, 103, 2482, 10154, 10156, 59, 27277, 59, 27279, 256, 98, 117, 9514, 10163, 111, 256, 59, 114, 3615, 10169, 59, 24602, 114, 111, 107, 59, 16706, 33792, 60, 59, 99, 100, 104, 105, 108, 113, 114, 2091, 10194, 9785, 10204, 10208, 10213, 10218, 10224, 256, 99, 105, 10199, 10201, 59, 27302, 114, 59, 27257, 114, 101, 229, 9714, 109, 101, 115, 59, 25289, 97, 114, 114, 59, 26998, 117, 101, 115, 116, 59, 27259, 256, 80, 105, 10229, 10233, 97, 114, 59, 27030, 384, 59, 101, 102, 10240, 2349, 6171, 26051, 114, 256, 100, 117, 10247, 10253, 115, 104, 97, 114, 59, 26954, 104, 97, 114, 59, 26982, 256, 101, 110, 10263, 10273, 114, 116, 110, 101, 113, 113, 59, 49152, 8808, 65024, 197, 10270, 1792, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 10304, 10309, 10370, 10382, 10387, 10400, 10405, 10408, 10458, 10466, 10468, 2691, 10483, 10498, 68, 111, 116, 59, 25146, 512, 99, 108, 112, 114, 10318, 10322, 10339, 10365, 114, 32827, 175, 16559, 256, 101, 116, 10327, 10329, 59, 26178, 256, 59, 101, 10334, 10335, 26400, 115, 101, 187, 10335, 256, 59, 115, 4155, 10344, 116, 111, 512, 59, 100, 108, 117, 4155, 10355, 10359, 10363, 111, 119, 238, 1164, 101, 102, 244, 2319, 240, 5073, 107, 101, 114, 59, 26030, 256, 111, 121, 10375, 10380, 109, 109, 97, 59, 27177, 59, 17468, 97, 115, 104, 59, 24596, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 187, 5670, 114, 59, 49152, 55349, 56618, 111, 59, 24871, 384, 99, 100, 110, 10415, 10420, 10441, 114, 111, 32827, 181, 16565, 512, 59, 97, 99, 100, 5220, 10429, 10432, 10436, 115, 244, 5799, 105, 114, 59, 27376, 111, 116, 32955, 183, 437, 117, 115, 384, 59, 98, 100, 10450, 6403, 10451, 25106, 256, 59, 117, 7484, 10456, 59, 27178, 355, 10462, 10465, 112, 59, 27355, 242, 8722, 240, 2689, 256, 100, 112, 10473, 10478, 101, 108, 115, 59, 25255, 102, 59, 49152, 55349, 56670, 256, 99, 116, 10488, 10493, 114, 59, 49152, 55349, 56514, 112, 111, 115, 187, 5533, 384, 59, 108, 109, 10505, 10506, 10509, 17340, 116, 105, 109, 97, 112, 59, 25272, 3072, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 10562, 10579, 10622, 10633, 10648, 10714, 10729, 10773, 10778, 10840, 10845, 10883, 10901, 10916, 10920, 11012, 11015, 11076, 11135, 11182, 11316, 11367, 11388, 11497, 256, 103, 116, 10567, 10571, 59, 49152, 8921, 824, 256, 59, 118, 10576, 3023, 49152, 8811, 8402, 384, 101, 108, 116, 10586, 10610, 10614, 102, 116, 256, 97, 114, 10593, 10599, 114, 114, 111, 119, 59, 25037, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 25038, 59, 49152, 8920, 824, 256, 59, 118, 10619, 3143, 49152, 8810, 8402, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 25039, 256, 68, 100, 10638, 10643, 97, 115, 104, 59, 25263, 97, 115, 104, 59, 25262, 640, 98, 99, 110, 112, 116, 10659, 10663, 10668, 10673, 10700, 108, 97, 187, 734, 117, 116, 101, 59, 16708, 103, 59, 49152, 8736, 8402, 640, 59, 69, 105, 111, 112, 3460, 10684, 10688, 10693, 10696, 59, 49152, 10864, 824, 100, 59, 49152, 8779, 824, 115, 59, 16713, 114, 111, 248, 3460, 117, 114, 256, 59, 97, 10707, 10708, 26222, 108, 256, 59, 115, 10707, 2872, 499, 10719, 0, 10723, 112, 32955, 160, 2871, 109, 112, 256, 59, 101, 3065, 3072, 640, 97, 101, 111, 117, 121, 10740, 10750, 10755, 10768, 10771, 496, 10745, 0, 10747, 59, 27203, 111, 110, 59, 16712, 100, 105, 108, 59, 16710, 110, 103, 256, 59, 100, 3454, 10762, 111, 116, 59, 49152, 10861, 824, 112, 59, 27202, 59, 17469, 97, 115, 104, 59, 24595, 896, 59, 65, 97, 100, 113, 115, 120, 2962, 10793, 10797, 10811, 10817, 10821, 10832, 114, 114, 59, 25047, 114, 256, 104, 114, 10803, 10806, 107, 59, 26916, 256, 59, 111, 5106, 5104, 111, 116, 59, 49152, 8784, 824, 117, 105, 246, 2915, 256, 101, 105, 10826, 10830, 97, 114, 59, 26920, 237, 2968, 105, 115, 116, 256, 59, 115, 2976, 2975, 114, 59, 49152, 55349, 56619, 512, 69, 101, 115, 116, 3013, 10854, 10873, 10876, 384, 59, 113, 115, 3004, 10861, 3041, 384, 59, 113, 115, 3004, 3013, 10868, 108, 97, 110, 244, 3042, 105, 237, 3050, 256, 59, 114, 2998, 10881, 187, 2999, 384, 65, 97, 112, 10890, 10893, 10897, 114, 242, 10609, 114, 114, 59, 25006, 97, 114, 59, 27378, 384, 59, 115, 118, 3981, 10908, 3980, 256, 59, 100, 10913, 10914, 25340, 59, 25338, 99, 121, 59, 17498, 896, 65, 69, 97, 100, 101, 115, 116, 10935, 10938, 10942, 10946, 10949, 10998, 11001, 114, 242, 10598, 59, 49152, 8806, 824, 114, 114, 59, 24986, 114, 59, 24613, 512, 59, 102, 113, 115, 3131, 10958, 10979, 10991, 116, 256, 97, 114, 10964, 10969, 114, 114, 111, 247, 10945, 105, 103, 104, 116, 97, 114, 114, 111, 247, 10896, 384, 59, 113, 115, 3131, 10938, 10986, 108, 97, 110, 244, 3157, 256, 59, 115, 3157, 10996, 187, 3126, 105, 237, 3165, 256, 59, 114, 3125, 11006, 105, 256, 59, 101, 3098, 3109, 105, 228, 3472, 256, 112, 116, 11020, 11025, 102, 59, 49152, 55349, 56671, 33152, 172, 59, 105, 110, 11033, 11034, 11062, 16556, 110, 512, 59, 69, 100, 118, 2953, 11044, 11048, 11054, 59, 49152, 8953, 824, 111, 116, 59, 49152, 8949, 824, 481, 2953, 11059, 11061, 59, 25335, 59, 25334, 105, 256, 59, 118, 3256, 11068, 481, 3256, 11073, 11075, 59, 25342, 59, 25341, 384, 97, 111, 114, 11083, 11107, 11113, 114, 512, 59, 97, 115, 116, 2939, 11093, 11098, 11103, 108, 108, 101, 236, 2939, 108, 59, 49152, 11005, 8421, 59, 49152, 8706, 824, 108, 105, 110, 116, 59, 27156, 384, 59, 99, 101, 3218, 11120, 11123, 117, 229, 3237, 256, 59, 99, 3224, 11128, 256, 59, 101, 3218, 11133, 241, 3224, 512, 65, 97, 105, 116, 11144, 11147, 11165, 11175, 114, 242, 10632, 114, 114, 384, 59, 99, 119, 11156, 11157, 11161, 24987, 59, 49152, 10547, 824, 59, 49152, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 187, 11157, 114, 105, 256, 59, 101, 3275, 3286, 896, 99, 104, 105, 109, 112, 113, 117, 11197, 11213, 11225, 11012, 2936, 11236, 11247, 512, 59, 99, 101, 114, 3378, 11206, 3383, 11209, 117, 229, 3397, 59, 49152, 55349, 56515, 111, 114, 116, 621, 11013, 0, 0, 11222, 97, 114, 225, 11094, 109, 256, 59, 101, 3438, 11231, 256, 59, 113, 3444, 3443, 115, 117, 256, 98, 112, 11243, 11245, 229, 3320, 229, 3339, 384, 98, 99, 112, 11254, 11281, 11289, 512, 59, 69, 101, 115, 11263, 11264, 3362, 11268, 25220, 59, 49152, 10949, 824, 101, 116, 256, 59, 101, 3355, 11275, 113, 256, 59, 113, 3363, 11264, 99, 256, 59, 101, 3378, 11287, 241, 3384, 512, 59, 69, 101, 115, 11298, 11299, 3423, 11303, 25221, 59, 49152, 10950, 824, 101, 116, 256, 59, 101, 3416, 11310, 113, 256, 59, 113, 3424, 11299, 512, 103, 105, 108, 114, 11325, 11327, 11333, 11335, 236, 3031, 108, 100, 101, 32827, 241, 16625, 231, 3139, 105, 97, 110, 103, 108, 101, 256, 108, 114, 11346, 11356, 101, 102, 116, 256, 59, 101, 3098, 11354, 241, 3110, 105, 103, 104, 116, 256, 59, 101, 3275, 11365, 241, 3287, 256, 59, 109, 11372, 11373, 17341, 384, 59, 101, 115, 11380, 11381, 11385, 16419, 114, 111, 59, 24854, 112, 59, 24583, 1152, 68, 72, 97, 100, 103, 105, 108, 114, 115, 11407, 11412, 11417, 11422, 11427, 11440, 11446, 11475, 11491, 97, 115, 104, 59, 25261, 97, 114, 114, 59, 26884, 112, 59, 49152, 8781, 8402, 97, 115, 104, 59, 25260, 256, 101, 116, 11432, 11436, 59, 49152, 8805, 8402, 59, 49152, 62, 8402, 110, 102, 105, 110, 59, 27102, 384, 65, 101, 116, 11453, 11457, 11461, 114, 114, 59, 26882, 59, 49152, 8804, 8402, 256, 59, 114, 11466, 11469, 49152, 60, 8402, 105, 101, 59, 49152, 8884, 8402, 256, 65, 116, 11480, 11484, 114, 114, 59, 26883, 114, 105, 101, 59, 49152, 8885, 8402, 105, 109, 59, 49152, 8764, 8402, 384, 65, 97, 110, 11504, 11508, 11522, 114, 114, 59, 25046, 114, 256, 104, 114, 11514, 11517, 107, 59, 26915, 256, 59, 111, 5095, 5093, 101, 97, 114, 59, 26919, 4691, 6805, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11565, 0, 11576, 11592, 11616, 11621, 11634, 11652, 6919, 0, 0, 11661, 11691, 0, 11720, 11726, 0, 11740, 11801, 11819, 11838, 11843, 256, 99, 115, 11569, 6807, 117, 116, 101, 32827, 243, 16627, 256, 105, 121, 11580, 11589, 114, 256, 59, 99, 6814, 11586, 32827, 244, 16628, 59, 17470, 640, 97, 98, 105, 111, 115, 6816, 11602, 11607, 456, 11610, 108, 97, 99, 59, 16721, 118, 59, 27192, 111, 108, 100, 59, 27068, 108, 105, 103, 59, 16723, 256, 99, 114, 11625, 11629, 105, 114, 59, 27071, 59, 49152, 55349, 56620, 879, 11641, 0, 0, 11644, 0, 11650, 110, 59, 17115, 97, 118, 101, 32827, 242, 16626, 59, 27073, 256, 98, 109, 11656, 3572, 97, 114, 59, 27061, 512, 97, 99, 105, 116, 11669, 11672, 11685, 11688, 114, 242, 6784, 256, 105, 114, 11677, 11680, 114, 59, 27070, 111, 115, 115, 59, 27067, 110, 229, 3666, 59, 27072, 384, 97, 101, 105, 11697, 11701, 11705, 99, 114, 59, 16717, 103, 97, 59, 17353, 384, 99, 100, 110, 11712, 11717, 461, 114, 111, 110, 59, 17343, 59, 27062, 112, 102, 59, 49152, 55349, 56672, 384, 97, 101, 108, 11732, 11735, 466, 114, 59, 27063, 114, 112, 59, 27065, 896, 59, 97, 100, 105, 111, 115, 118, 11754, 11755, 11758, 11784, 11789, 11792, 11798, 25128, 114, 242, 6790, 512, 59, 101, 102, 109, 11767, 11768, 11778, 11781, 27229, 114, 256, 59, 111, 11774, 11775, 24884, 102, 187, 11775, 32827, 170, 16554, 32827, 186, 16570, 103, 111, 102, 59, 25270, 114, 59, 27222, 108, 111, 112, 101, 59, 27223, 59, 27227, 384, 99, 108, 111, 11807, 11809, 11815, 242, 11777, 97, 115, 104, 32827, 248, 16632, 108, 59, 25240, 105, 364, 11823, 11828, 100, 101, 32827, 245, 16629, 101, 115, 256, 59, 97, 475, 11834, 115, 59, 27190, 109, 108, 32827, 246, 16630, 98, 97, 114, 59, 25405, 2785, 11870, 0, 11901, 0, 11904, 11933, 0, 11938, 11961, 0, 0, 11979, 3740, 0, 12051, 0, 0, 12075, 12220, 0, 12232, 114, 512, 59, 97, 115, 116, 1027, 11879, 11890, 3717, 33024, 182, 59, 108, 11885, 11886, 16566, 108, 101, 236, 1027, 617, 11896, 0, 0, 11899, 109, 59, 27379, 59, 27389, 121, 59, 17471, 114, 640, 99, 105, 109, 112, 116, 11915, 11919, 11923, 6245, 11927, 110, 116, 59, 16421, 111, 100, 59, 16430, 105, 108, 59, 24624, 101, 110, 107, 59, 24625, 114, 59, 49152, 55349, 56621, 384, 105, 109, 111, 11944, 11952, 11956, 256, 59, 118, 11949, 11950, 17350, 59, 17365, 109, 97, 244, 2678, 110, 101, 59, 26126, 384, 59, 116, 118, 11967, 11968, 11976, 17344, 99, 104, 102, 111, 114, 107, 187, 8189, 59, 17366, 256, 97, 117, 11983, 11999, 110, 256, 99, 107, 11989, 11997, 107, 256, 59, 104, 8692, 11995, 59, 24846, 246, 8692, 115, 1152, 59, 97, 98, 99, 100, 101, 109, 115, 116, 12019, 12020, 6408, 12025, 12029, 12036, 12038, 12042, 12046, 16427, 99, 105, 114, 59, 27171, 105, 114, 59, 27170, 256, 111, 117, 7488, 12034, 59, 27173, 59, 27250, 110, 32955, 177, 3741, 105, 109, 59, 27174, 119, 111, 59, 27175, 384, 105, 112, 117, 12057, 12064, 12069, 110, 116, 105, 110, 116, 59, 27157, 102, 59, 49152, 55349, 56673, 110, 100, 32827, 163, 16547, 1280, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 3784, 12095, 12097, 12100, 12103, 12161, 12169, 12178, 12158, 12214, 59, 27315, 112, 59, 27319, 117, 229, 3801, 256, 59, 99, 3790, 12108, 768, 59, 97, 99, 101, 110, 115, 3784, 12121, 12127, 12134, 12136, 12158, 112, 112, 114, 111, 248, 12099, 117, 114, 108, 121, 101, 241, 3801, 241, 3790, 384, 97, 101, 115, 12143, 12150, 12154, 112, 112, 114, 111, 120, 59, 27321, 113, 113, 59, 27317, 105, 109, 59, 25320, 105, 237, 3807, 109, 101, 256, 59, 115, 12168, 3758, 24626, 384, 69, 97, 115, 12152, 12176, 12154, 240, 12149, 384, 100, 102, 112, 3820, 12185, 12207, 384, 97, 108, 115, 12192, 12197, 12202, 108, 97, 114, 59, 25390, 105, 110, 101, 59, 25362, 117, 114, 102, 59, 25363, 256, 59, 116, 3835, 12212, 239, 3835, 114, 101, 108, 59, 25264, 256, 99, 105, 12224, 12229, 114, 59, 49152, 55349, 56517, 59, 17352, 110, 99, 115, 112, 59, 24584, 768, 102, 105, 111, 112, 115, 117, 12250, 8930, 12255, 12261, 12267, 12273, 114, 59, 49152, 55349, 56622, 112, 102, 59, 49152, 55349, 56674, 114, 105, 109, 101, 59, 24663, 99, 114, 59, 49152, 55349, 56518, 384, 97, 101, 111, 12280, 12297, 12307, 116, 256, 101, 105, 12286, 12293, 114, 110, 105, 111, 110, 243, 1712, 110, 116, 59, 27158, 115, 116, 256, 59, 101, 12304, 12305, 16447, 241, 7961, 244, 3860, 2688, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 12352, 12369, 12373, 12377, 12512, 12558, 12587, 12615, 12642, 12658, 12686, 12806, 12821, 12836, 12841, 12888, 12910, 12914, 12944, 12976, 12983, 384, 97, 114, 116, 12359, 12362, 12364, 114, 242, 4275, 242, 989, 97, 105, 108, 59, 26908, 97, 114, 242, 7269, 97, 114, 59, 26980, 896, 99, 100, 101, 110, 113, 114, 116, 12392, 12405, 12408, 12415, 12431, 12436, 12492, 256, 101, 117, 12397, 12401, 59, 49152, 8765, 817, 116, 101, 59, 16725, 105, 227, 4462, 109, 112, 116, 121, 118, 59, 27059, 103, 512, 59, 100, 101, 108, 4049, 12425, 12427, 12429, 59, 27026, 59, 27045, 229, 4049, 117, 111, 32827, 187, 16571, 114, 1408, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 4060, 12460, 12463, 12471, 12473, 12476, 12478, 12480, 12483, 12487, 12490, 112, 59, 26997, 256, 59, 102, 4064, 12468, 115, 59, 26912, 59, 26931, 115, 59, 26910, 235, 8797, 240, 10030, 108, 59, 26949, 105, 109, 59, 26996, 108, 59, 24995, 59, 24989, 256, 97, 105, 12497, 12501, 105, 108, 59, 26906, 111, 256, 59, 110, 12507, 12508, 25142, 97, 108, 243, 3870, 384, 97, 98, 114, 12519, 12522, 12526, 114, 242, 6117, 114, 107, 59, 26483, 256, 97, 107, 12531, 12541, 99, 256, 101, 107, 12537, 12539, 59, 16509, 59, 16477, 256, 101, 115, 12546, 12548, 59, 27020, 108, 256, 100, 117, 12554, 12556, 59, 27022, 59, 27024, 512, 97, 101, 117, 121, 12567, 12572, 12583, 12585, 114, 111, 110, 59, 16729, 256, 100, 105, 12577, 12581, 105, 108, 59, 16727, 236, 4082, 226, 12538, 59, 17472, 512, 99, 108, 113, 115, 12596, 12599, 12605, 12612, 97, 59, 26935, 100, 104, 97, 114, 59, 26985, 117, 111, 256, 59, 114, 526, 525, 104, 59, 25011, 384, 97, 99, 103, 12622, 12639, 3908, 108, 512, 59, 105, 112, 115, 3960, 12632, 12635, 4252, 110, 229, 4283, 97, 114, 244, 4009, 116, 59, 26029, 384, 105, 108, 114, 12649, 4131, 12654, 115, 104, 116, 59, 27005, 59, 49152, 55349, 56623, 256, 97, 111, 12663, 12678, 114, 256, 100, 117, 12669, 12671, 187, 1147, 256, 59, 108, 4241, 12676, 59, 26988, 256, 59, 118, 12683, 12684, 17345, 59, 17393, 384, 103, 110, 115, 12693, 12793, 12796, 104, 116, 768, 97, 104, 108, 114, 115, 116, 12708, 12720, 12738, 12760, 12772, 12782, 114, 114, 111, 119, 256, 59, 116, 4060, 12717, 97, 233, 12488, 97, 114, 112, 111, 111, 110, 256, 100, 117, 12731, 12735, 111, 119, 238, 12670, 112, 187, 4242, 101, 102, 116, 256, 97, 104, 12746, 12752, 114, 114, 111, 119, 243, 4074, 97, 114, 112, 111, 111, 110, 243, 1361, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 25033, 113, 117, 105, 103, 97, 114, 114, 111, 247, 12491, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 25292, 103, 59, 17114, 105, 110, 103, 100, 111, 116, 115, 101, 241, 7986, 384, 97, 104, 109, 12813, 12816, 12819, 114, 242, 4074, 97, 242, 1361, 59, 24591, 111, 117, 115, 116, 256, 59, 97, 12830, 12831, 25521, 99, 104, 101, 187, 12831, 109, 105, 100, 59, 27374, 512, 97, 98, 112, 116, 12850, 12861, 12864, 12882, 256, 110, 114, 12855, 12858, 103, 59, 26605, 114, 59, 25086, 114, 235, 4099, 384, 97, 102, 108, 12871, 12874, 12878, 114, 59, 27014, 59, 49152, 55349, 56675, 117, 115, 59, 27182, 105, 109, 101, 115, 59, 27189, 256, 97, 112, 12893, 12903, 114, 256, 59, 103, 12899, 12900, 16425, 116, 59, 27028, 111, 108, 105, 110, 116, 59, 27154, 97, 114, 242, 12771, 512, 97, 99, 104, 113, 12923, 12928, 4284, 12933, 113, 117, 111, 59, 24634, 114, 59, 49152, 55349, 56519, 256, 98, 117, 12539, 12938, 111, 256, 59, 114, 532, 531, 384, 104, 105, 114, 12951, 12955, 12960, 114, 101, 229, 12792, 109, 101, 115, 59, 25290, 105, 512, 59, 101, 102, 108, 12970, 4185, 6177, 12971, 26041, 116, 114, 105, 59, 27086, 108, 117, 104, 97, 114, 59, 26984, 59, 24862, 3425, 13013, 13019, 13023, 13100, 13112, 13169, 0, 13178, 13220, 0, 0, 13292, 13296, 0, 13352, 13384, 13402, 13485, 13489, 13514, 13553, 0, 13846, 0, 0, 13875, 99, 117, 116, 101, 59, 16731, 113, 117, 239, 10170, 1280, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 4589, 13043, 13045, 13055, 13058, 13067, 13071, 13087, 13094, 13097, 59, 27316, 496, 13050, 0, 13052, 59, 27320, 111, 110, 59, 16737, 117, 229, 4606, 256, 59, 100, 4595, 13063, 105, 108, 59, 16735, 114, 99, 59, 16733, 384, 69, 97, 115, 13078, 13080, 13083, 59, 27318, 112, 59, 27322, 105, 109, 59, 25321, 111, 108, 105, 110, 116, 59, 27155, 105, 237, 4612, 59, 17473, 111, 116, 384, 59, 98, 101, 13108, 7495, 13109, 25285, 59, 27238, 896, 65, 97, 99, 109, 115, 116, 120, 13126, 13130, 13143, 13147, 13150, 13155, 13165, 114, 114, 59, 25048, 114, 256, 104, 114, 13136, 13138, 235, 8744, 256, 59, 111, 2614, 2612, 116, 32827, 167, 16551, 105, 59, 16443, 119, 97, 114, 59, 26921, 109, 256, 105, 110, 13161, 240, 110, 117, 243, 241, 116, 59, 26422, 114, 256, 59, 111, 13174, 8277, 49152, 55349, 56624, 512, 97, 99, 111, 121, 13186, 13190, 13201, 13216, 114, 112, 59, 26223, 256, 104, 121, 13195, 13199, 99, 121, 59, 17481, 59, 17480, 114, 116, 621, 13209, 0, 0, 13212, 105, 228, 5220, 97, 114, 97, 236, 11887, 32827, 173, 16557, 256, 103, 109, 13224, 13236, 109, 97, 384, 59, 102, 118, 13233, 13234, 13234, 17347, 59, 17346, 1024, 59, 100, 101, 103, 108, 110, 112, 114, 4779, 13253, 13257, 13262, 13270, 13278, 13281, 13286, 111, 116, 59, 27242, 256, 59, 113, 4785, 4784, 256, 59, 69, 13267, 13268, 27294, 59, 27296, 256, 59, 69, 13275, 13276, 27293, 59, 27295, 101, 59, 25158, 108, 117, 115, 59, 27172, 97, 114, 114, 59, 26994, 97, 114, 242, 4413, 512, 97, 101, 105, 116, 13304, 13320, 13327, 13335, 256, 108, 115, 13309, 13316, 108, 115, 101, 116, 109, 233, 13162, 104, 112, 59, 27187, 112, 97, 114, 115, 108, 59, 27108, 256, 100, 108, 5219, 13332, 101, 59, 25379, 256, 59, 101, 13340, 13341, 27306, 256, 59, 115, 13346, 13347, 27308, 59, 49152, 10924, 65024, 384, 102, 108, 112, 13358, 13363, 13378, 116, 99, 121, 59, 17484, 256, 59, 98, 13368, 13369, 16431, 256, 59, 97, 13374, 13375, 27076, 114, 59, 25407, 102, 59, 49152, 55349, 56676, 97, 256, 100, 114, 13389, 1026, 101, 115, 256, 59, 117, 13396, 13397, 26208, 105, 116, 187, 13397, 384, 99, 115, 117, 13408, 13433, 13471, 256, 97, 117, 13413, 13423, 112, 256, 59, 115, 4488, 13419, 59, 49152, 8851, 65024, 112, 256, 59, 115, 4532, 13429, 59, 49152, 8852, 65024, 117, 256, 98, 112, 13439, 13455, 384, 59, 101, 115, 4503, 4508, 13446, 101, 116, 256, 59, 101, 4503, 13453, 241, 4509, 384, 59, 101, 115, 4520, 4525, 13462, 101, 116, 256, 59, 101, 4520, 13469, 241, 4526, 384, 59, 97, 102, 4475, 13478, 1456, 114, 357, 13483, 1457, 187, 4476, 97, 114, 242, 4424, 512, 99, 101, 109, 116, 13497, 13502, 13506, 13509, 114, 59, 49152, 55349, 56520, 116, 109, 238, 241, 105, 236, 13333, 97, 114, 230, 4542, 256, 97, 114, 13518, 13525, 114, 256, 59, 102, 13524, 6079, 26118, 256, 97, 110, 13530, 13549, 105, 103, 104, 116, 256, 101, 112, 13539, 13546, 112, 115, 105, 108, 111, 238, 7904, 104, 233, 11951, 115, 187, 10322, 640, 98, 99, 109, 110, 112, 13563, 13662, 4617, 13707, 13710, 1152, 59, 69, 100, 101, 109, 110, 112, 114, 115, 13582, 13583, 13585, 13589, 13598, 13603, 13612, 13617, 13622, 25218, 59, 27333, 111, 116, 59, 27325, 256, 59, 100, 4570, 13594, 111, 116, 59, 27331, 117, 108, 116, 59, 27329, 256, 69, 101, 13608, 13610, 59, 27339, 59, 25226, 108, 117, 115, 59, 27327, 97, 114, 114, 59, 27001, 384, 101, 105, 117, 13629, 13650, 13653, 116, 384, 59, 101, 110, 13582, 13637, 13643, 113, 256, 59, 113, 4570, 13583, 101, 113, 256, 59, 113, 13611, 13608, 109, 59, 27335, 256, 98, 112, 13658, 13660, 59, 27349, 59, 27347, 99, 768, 59, 97, 99, 101, 110, 115, 4589, 13676, 13682, 13689, 13691, 13094, 112, 112, 114, 111, 248, 13050, 117, 114, 108, 121, 101, 241, 4606, 241, 4595, 384, 97, 101, 115, 13698, 13704, 13083, 112, 112, 114, 111, 248, 13082, 113, 241, 13079, 103, 59, 26218, 1664, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 13737, 13740, 13743, 4636, 13746, 13748, 13760, 13769, 13781, 13786, 13791, 13800, 13805, 32827, 185, 16569, 32827, 178, 16562, 32827, 179, 16563, 59, 27334, 256, 111, 115, 13753, 13756, 116, 59, 27326, 117, 98, 59, 27352, 256, 59, 100, 4642, 13765, 111, 116, 59, 27332, 115, 256, 111, 117, 13775, 13778, 108, 59, 26569, 98, 59, 27351, 97, 114, 114, 59, 27003, 117, 108, 116, 59, 27330, 256, 69, 101, 13796, 13798, 59, 27340, 59, 25227, 108, 117, 115, 59, 27328, 384, 101, 105, 117, 13812, 13833, 13836, 116, 384, 59, 101, 110, 4636, 13820, 13826, 113, 256, 59, 113, 4642, 13746, 101, 113, 256, 59, 113, 13799, 13796, 109, 59, 27336, 256, 98, 112, 13841, 13843, 59, 27348, 59, 27350, 384, 65, 97, 110, 13852, 13856, 13869, 114, 114, 59, 25049, 114, 256, 104, 114, 13862, 13864, 235, 8750, 256, 59, 111, 2603, 2601, 119, 97, 114, 59, 26922, 108, 105, 103, 32827, 223, 16607, 3041, 13905, 13917, 13920, 4814, 13939, 13945, 0, 13950, 14018, 0, 0, 0, 0, 0, 14043, 14083, 0, 14089, 14188, 0, 0, 0, 14215, 626, 13910, 0, 0, 13915, 103, 101, 116, 59, 25366, 59, 17348, 114, 235, 3679, 384, 97, 101, 121, 13926, 13931, 13936, 114, 111, 110, 59, 16741, 100, 105, 108, 59, 16739, 59, 17474, 108, 114, 101, 99, 59, 25365, 114, 59, 49152, 55349, 56625, 512, 101, 105, 107, 111, 13958, 13981, 14005, 14012, 498, 13963, 0, 13969, 101, 256, 52, 102, 4740, 4737, 97, 384, 59, 115, 118, 13976, 13977, 13979, 17336, 121, 109, 59, 17361, 256, 99, 110, 13986, 14002, 107, 256, 97, 115, 13992, 13998, 112, 112, 114, 111, 248, 4801, 105, 109, 187, 4780, 115, 240, 4766, 256, 97, 115, 14010, 13998, 240, 4801, 114, 110, 32827, 254, 16638, 492, 799, 14022, 8935, 101, 115, 33152, 215, 59, 98, 100, 14031, 14032, 14040, 16599, 256, 59, 97, 6415, 14037, 114, 59, 27185, 59, 27184, 384, 101, 112, 115, 14049, 14051, 14080, 225, 10829, 512, 59, 98, 99, 102, 1158, 14060, 14064, 14068, 111, 116, 59, 25398, 105, 114, 59, 27377, 256, 59, 111, 14073, 14076, 49152, 55349, 56677, 114, 107, 59, 27354, 225, 13154, 114, 105, 109, 101, 59, 24628, 384, 97, 105, 112, 14095, 14098, 14180, 100, 229, 4680, 896, 97, 100, 101, 109, 112, 115, 116, 14113, 14157, 14144, 14161, 14167, 14172, 14175, 110, 103, 108, 101, 640, 59, 100, 108, 113, 114, 14128, 14129, 14134, 14144, 14146, 26037, 111, 119, 110, 187, 7611, 101, 102, 116, 256, 59, 101, 10240, 14142, 241, 2350, 59, 25180, 105, 103, 104, 116, 256, 59, 101, 12970, 14155, 241, 4186, 111, 116, 59, 26092, 105, 110, 117, 115, 59, 27194, 108, 117, 115, 59, 27193, 98, 59, 27085, 105, 109, 101, 59, 27195, 101, 122, 105, 117, 109, 59, 25570, 384, 99, 104, 116, 14194, 14205, 14209, 256, 114, 121, 14199, 14203, 59, 49152, 55349, 56521, 59, 17478, 99, 121, 59, 17499, 114, 111, 107, 59, 16743, 256, 105, 111, 14219, 14222, 120, 244, 6007, 104, 101, 97, 100, 256, 108, 114, 14231, 14240, 101, 102, 116, 97, 114, 114, 111, 247, 2127, 105, 103, 104, 116, 97, 114, 114, 111, 119, 187, 3933, 2304, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 14288, 14291, 14295, 14308, 14320, 14332, 14350, 14364, 14371, 14388, 14417, 14429, 14443, 14505, 14540, 14546, 14570, 14582, 114, 242, 1005, 97, 114, 59, 26979, 256, 99, 114, 14300, 14306, 117, 116, 101, 32827, 250, 16634, 242, 4432, 114, 483, 14314, 0, 14317, 121, 59, 17502, 118, 101, 59, 16749, 256, 105, 121, 14325, 14330, 114, 99, 32827, 251, 16635, 59, 17475, 384, 97, 98, 104, 14339, 14342, 14347, 114, 242, 5037, 108, 97, 99, 59, 16753, 97, 242, 5059, 256, 105, 114, 14355, 14360, 115, 104, 116, 59, 27006, 59, 49152, 55349, 56626, 114, 97, 118, 101, 32827, 249, 16633, 353, 14375, 14385, 114, 256, 108, 114, 14380, 14382, 187, 2391, 187, 4227, 108, 107, 59, 25984, 256, 99, 116, 14393, 14413, 623, 14399, 0, 0, 14410, 114, 110, 256, 59, 101, 14405, 14406, 25372, 114, 187, 14406, 111, 112, 59, 25359, 114, 105, 59, 26104, 256, 97, 108, 14422, 14426, 99, 114, 59, 16747, 32955, 168, 841, 256, 103, 112, 14434, 14438, 111, 110, 59, 16755, 102, 59, 49152, 55349, 56678, 768, 97, 100, 104, 108, 115, 117, 4427, 14456, 14461, 4978, 14481, 14496, 111, 119, 110, 225, 5043, 97, 114, 112, 111, 111, 110, 256, 108, 114, 14472, 14476, 101, 102, 244, 14381, 105, 103, 104, 244, 14383, 105, 384, 59, 104, 108, 14489, 14490, 14492, 17349, 187, 5114, 111, 110, 187, 14490, 112, 97, 114, 114, 111, 119, 115, 59, 25032, 384, 99, 105, 116, 14512, 14532, 14536, 623, 14518, 0, 0, 14529, 114, 110, 256, 59, 101, 14524, 14525, 25373, 114, 187, 14525, 111, 112, 59, 25358, 110, 103, 59, 16751, 114, 105, 59, 26105, 99, 114, 59, 49152, 55349, 56522, 384, 100, 105, 114, 14553, 14557, 14562, 111, 116, 59, 25328, 108, 100, 101, 59, 16745, 105, 256, 59, 102, 14128, 14568, 187, 6163, 256, 97, 109, 14575, 14578, 114, 242, 14504, 108, 32827, 252, 16636, 97, 110, 103, 108, 101, 59, 27047, 1920, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 14620, 14623, 14633, 14637, 14773, 14776, 14781, 14815, 14820, 14824, 14835, 14841, 14845, 14849, 14880, 114, 242, 1015, 97, 114, 256, 59, 118, 14630, 14631, 27368, 59, 27369, 97, 115, 232, 993, 256, 110, 114, 14642, 14647, 103, 114, 116, 59, 27036, 896, 101, 107, 110, 112, 114, 115, 116, 13539, 14662, 14667, 14674, 14685, 14692, 14742, 97, 112, 112, 225, 9237, 111, 116, 104, 105, 110, 231, 7830, 384, 104, 105, 114, 13547, 11976, 14681, 111, 112, 244, 12213, 256, 59, 104, 5047, 14690, 239, 12685, 256, 105, 117, 14697, 14701, 103, 109, 225, 13235, 256, 98, 112, 14706, 14724, 115, 101, 116, 110, 101, 113, 256, 59, 113, 14717, 14720, 49152, 8842, 65024, 59, 49152, 10955, 65024, 115, 101, 116, 110, 101, 113, 256, 59, 113, 14735, 14738, 49152, 8843, 65024, 59, 49152, 10956, 65024, 256, 104, 114, 14747, 14751, 101, 116, 225, 13980, 105, 97, 110, 103, 108, 101, 256, 108, 114, 14762, 14767, 101, 102, 116, 187, 2341, 105, 103, 104, 116, 187, 4177, 121, 59, 17458, 97, 115, 104, 187, 4150, 384, 101, 108, 114, 14788, 14802, 14807, 384, 59, 98, 101, 11754, 14795, 14799, 97, 114, 59, 25275, 113, 59, 25178, 108, 105, 112, 59, 25326, 256, 98, 116, 14812, 5224, 97, 242, 5225, 114, 59, 49152, 55349, 56627, 116, 114, 233, 14766, 115, 117, 256, 98, 112, 14831, 14833, 187, 3356, 187, 3417, 112, 102, 59, 49152, 55349, 56679, 114, 111, 240, 3835, 116, 114, 233, 14772, 256, 99, 117, 14854, 14859, 114, 59, 49152, 55349, 56523, 256, 98, 112, 14864, 14872, 110, 256, 69, 101, 14720, 14870, 187, 14718, 110, 256, 69, 101, 14738, 14878, 187, 14736, 105, 103, 122, 97, 103, 59, 27034, 896, 99, 101, 102, 111, 112, 114, 115, 14902, 14907, 14934, 14939, 14932, 14945, 14954, 105, 114, 99, 59, 16757, 256, 100, 105, 14912, 14929, 256, 98, 103, 14917, 14921, 97, 114, 59, 27231, 101, 256, 59, 113, 5626, 14927, 59, 25177, 101, 114, 112, 59, 24856, 114, 59, 49152, 55349, 56628, 112, 102, 59, 49152, 55349, 56680, 256, 59, 101, 5241, 14950, 97, 116, 232, 5241, 99, 114, 59, 49152, 55349, 56524, 2787, 6030, 14983, 0, 14987, 0, 14992, 15003, 0, 0, 15005, 15016, 15019, 15023, 0, 0, 15043, 15054, 0, 15064, 6108, 6111, 116, 114, 233, 6097, 114, 59, 49152, 55349, 56629, 256, 65, 97, 14996, 14999, 114, 242, 963, 114, 242, 2550, 59, 17342, 256, 65, 97, 15009, 15012, 114, 242, 952, 114, 242, 2539, 97, 240, 10003, 105, 115, 59, 25339, 384, 100, 112, 116, 6052, 15029, 15038, 256, 102, 108, 15034, 6057, 59, 49152, 55349, 56681, 105, 109, 229, 6066, 256, 65, 97, 15047, 15050, 114, 242, 974, 114, 242, 2561, 256, 99, 113, 15058, 6072, 114, 59, 49152, 55349, 56525, 256, 112, 116, 6102, 15068, 114, 233, 6100, 1024, 97, 99, 101, 102, 105, 111, 115, 117, 15088, 15101, 15112, 15116, 15121, 15125, 15131, 15137, 99, 256, 117, 121, 15094, 15099, 116, 101, 32827, 253, 16637, 59, 17487, 256, 105, 121, 15106, 15110, 114, 99, 59, 16759, 59, 17483, 110, 32827, 165, 16549, 114, 59, 49152, 55349, 56630, 99, 121, 59, 17495, 112, 102, 59, 49152, 55349, 56682, 99, 114, 59, 49152, 55349, 56526, 256, 99, 109, 15142, 15145, 121, 59, 17486, 108, 32827, 255, 16639, 1280, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 15170, 15176, 15188, 15192, 15204, 15209, 15213, 15220, 15226, 15232, 99, 117, 116, 101, 59, 16762, 256, 97, 121, 15181, 15186, 114, 111, 110, 59, 16766, 59, 17463, 111, 116, 59, 16764, 256, 101, 116, 15197, 15201, 116, 114, 230, 5471, 97, 59, 17334, 114, 59, 49152, 55349, 56631, 99, 121, 59, 17462, 103, 114, 97, 114, 114, 59, 25053, 112, 102, 59, 49152, 55349, 56683, 99, 114, 59, 49152, 55349, 56527, 256, 106, 110, 15237, 15239, 59, 24589, 106, 59, 24588]);
  }
});

// node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "node_modules/entities/lib/generated/decode-data-xml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array([512, 97, 103, 108, 113, 9, 21, 24, 27, 621, 15, 0, 0, 18, 112, 59, 16422, 111, 115, 59, 16423, 116, 59, 16446, 116, 59, 16444, 117, 111, 116, 59, 16418]);
  }
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceCodePoint = exports.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports.fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint(codePoint) {
      var _a2;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
    }
    exports.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports.default = decodeCodePoint;
  }
});

// node_modules/entities/lib/decode.js
var require_decode = __commonJS({
  "node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTML = exports.determineBranch = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault(require_decode_data_html());
    exports.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
    exports.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importDefault(require_decode_codepoint());
    exports.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint();
    Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
      CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
      CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
      CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
      CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
      CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
      CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
      CharCodes2[CharCodes2["To_LOWER_BIT"] = 32] = "To_LOWER_BIT";
    })(CharCodes || (CharCodes = {}));
    var BinTrieFlags;
    (function(BinTrieFlags2) {
      BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
    function getDecoder(decodeTree) {
      return function decodeHTMLBinary(str, strict) {
        var ret = "";
        var lastIdx = 0;
        var strIdx = 0;
        while ((strIdx = str.indexOf("&", strIdx)) >= 0) {
          ret += str.slice(lastIdx, strIdx);
          lastIdx = strIdx;
          strIdx += 1;
          if (str.charCodeAt(strIdx) === CharCodes.NUM) {
            var start = strIdx + 1;
            var base = 10;
            var cp = str.charCodeAt(start);
            if ((cp | CharCodes.To_LOWER_BIT) === CharCodes.LOWER_X) {
              base = 16;
              strIdx += 1;
              start += 1;
            }
            do
              cp = str.charCodeAt(++strIdx);
            while (cp >= CharCodes.ZERO && cp <= CharCodes.NINE || base === 16 && (cp | CharCodes.To_LOWER_BIT) >= CharCodes.LOWER_A && (cp | CharCodes.To_LOWER_BIT) <= CharCodes.LOWER_F);
            if (start !== strIdx) {
              var entity = str.substring(start, strIdx);
              var parsed = parseInt(entity, base);
              if (str.charCodeAt(strIdx) === CharCodes.SEMI) {
                strIdx += 1;
              } else if (strict) {
                continue;
              }
              ret += (0, decode_codepoint_js_1.default)(parsed);
              lastIdx = strIdx;
            }
            continue;
          }
          var resultIdx = 0;
          var excess = 1;
          var treeIdx = 0;
          var current = decodeTree[treeIdx];
          for (; strIdx < str.length; strIdx++, excess++) {
            treeIdx = determineBranch(decodeTree, current, treeIdx + 1, str.charCodeAt(strIdx));
            if (treeIdx < 0)
              break;
            current = decodeTree[treeIdx];
            var masked = current & BinTrieFlags.VALUE_LENGTH;
            if (masked) {
              if (!strict || str.charCodeAt(strIdx) === CharCodes.SEMI) {
                resultIdx = treeIdx;
                excess = 0;
              }
              var valueLength = (masked >> 14) - 1;
              if (valueLength === 0)
                break;
              treeIdx += valueLength;
            }
          }
          if (resultIdx !== 0) {
            var valueLength = (decodeTree[resultIdx] & BinTrieFlags.VALUE_LENGTH) >> 14;
            ret += valueLength === 1 ? String.fromCharCode(decodeTree[resultIdx] & ~BinTrieFlags.VALUE_LENGTH) : valueLength === 2 ? String.fromCharCode(decodeTree[resultIdx + 1]) : String.fromCharCode(decodeTree[resultIdx + 1], decodeTree[resultIdx + 2]);
            lastIdx = strIdx - excess + 1;
          }
        }
        return ret + str.slice(lastIdx);
      };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value > branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str) {
      return htmlDecoder(str, false);
    }
    exports.decodeHTML = decodeHTML;
    function decodeHTMLStrict(str) {
      return htmlDecoder(str, true);
    }
    exports.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str) {
      return xmlDecoder(str, true);
    }
    exports.decodeXML = decodeXML;
  }
});

// node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS({
  "node_modules/htmlparser2/lib/Tokenizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QuoteType = void 0;
    var decode_js_1 = require_decode();
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
      CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
      CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
      CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
      CharCodes2[CharCodes2["Space"] = 32] = "Space";
      CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
      CharCodes2[CharCodes2["Num"] = 35] = "Num";
      CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
      CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
      CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
      CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
      CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
      CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
      CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
      CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
      CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
      CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
      CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
      CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
      CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
      CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
      CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
      CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
      CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
      CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
      CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
      CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
    })(CharCodes || (CharCodes = {}));
    var State;
    (function(State2) {
      State2[State2["Text"] = 1] = "Text";
      State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
      State2[State2["InTagName"] = 3] = "InTagName";
      State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
      State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
      State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
      State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
      State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
      State2[State2["InAttributeName"] = 9] = "InAttributeName";
      State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
      State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
      State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
      State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
      State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
      State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
      State2[State2["InDeclaration"] = 16] = "InDeclaration";
      State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
      State2[State2["BeforeComment"] = 18] = "BeforeComment";
      State2[State2["CDATASequence"] = 19] = "CDATASequence";
      State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
      State2[State2["InCommentLike"] = 21] = "InCommentLike";
      State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
      State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
      State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
      State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
      State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
      State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
      State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
      State2[State2["InHexEntity"] = 29] = "InHexEntity";
    })(State || (State = {}));
    function isWhitespace(c) {
      return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;
    }
    function isEndOfTagSection(c) {
      return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
    }
    function isNumber(c) {
      return c >= CharCodes.Zero && c <= CharCodes.Nine;
    }
    function isASCIIAlpha(c) {
      return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;
    }
    function isHexDigit(c) {
      return c >= CharCodes.UpperA && c <= CharCodes.UpperF || c >= CharCodes.LowerA && c <= CharCodes.LowerF;
    }
    var QuoteType;
    (function(QuoteType2) {
      QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
      QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
      QuoteType2[QuoteType2["Single"] = 2] = "Single";
      QuoteType2[QuoteType2["Double"] = 3] = "Double";
    })(QuoteType = exports.QuoteType || (exports.QuoteType = {}));
    var Sequences = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      CdataEnd: new Uint8Array([93, 93, 62]),
      CommentEnd: new Uint8Array([45, 45, 62]),
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
    };
    var Tokenizer = function() {
      function Tokenizer2(_a, cbs) {
        var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
        this.cbs = cbs;
        this.state = State.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State.Text;
        this.isSpecial = false;
        this.running = true;
        this.offset = 0;
        this.sequenceIndex = 0;
        this.trieIndex = 0;
        this.trieCurrent = 0;
        this.entityResult = 0;
        this.entityExcess = 0;
        this.xmlMode = xmlMode;
        this.decodeEntities = decodeEntities;
        this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
      }
      Tokenizer2.prototype.reset = function() {
        this.state = State.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State.Text;
        this.currentSequence = void 0;
        this.running = true;
        this.offset = 0;
      };
      Tokenizer2.prototype.write = function(chunk) {
        this.offset += this.buffer.length;
        this.buffer = chunk;
        this.parse();
      };
      Tokenizer2.prototype.end = function() {
        if (this.running)
          this.finish();
      };
      Tokenizer2.prototype.pause = function() {
        this.running = false;
      };
      Tokenizer2.prototype.resume = function() {
        this.running = true;
        if (this.index < this.buffer.length + this.offset) {
          this.parse();
        }
      };
      Tokenizer2.prototype.getIndex = function() {
        return this.index;
      };
      Tokenizer2.prototype.getSectionStart = function() {
        return this.sectionStart;
      };
      Tokenizer2.prototype.stateText = function(c) {
        if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
          if (this.index > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, this.index);
          }
          this.state = State.BeforeTagName;
          this.sectionStart = this.index;
        } else if (this.decodeEntities && c === CharCodes.Amp) {
          this.state = State.BeforeEntity;
        }
      };
      Tokenizer2.prototype.stateSpecialStartSequence = function(c) {
        var isEnd = this.sequenceIndex === this.currentSequence.length;
        var isMatch = isEnd ? isEndOfTagSection(c) : (c | 32) === this.currentSequence[this.sequenceIndex];
        if (!isMatch) {
          this.isSpecial = false;
        } else if (!isEnd) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0;
        this.state = State.InTagName;
        this.stateInTagName(c);
      };
      Tokenizer2.prototype.stateInSpecialTag = function(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (c === CharCodes.Gt || isWhitespace(c)) {
            var endOfText = this.index - this.currentSequence.length;
            if (this.sectionStart < endOfText) {
              var actualIndex = this.index;
              this.index = endOfText;
              this.cbs.ontext(this.sectionStart, endOfText);
              this.index = actualIndex;
            }
            this.isSpecial = false;
            this.sectionStart = endOfText + 2;
            this.stateInClosingTagName(c);
            return;
          }
          this.sequenceIndex = 0;
        }
        if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
          this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
          if (this.currentSequence === Sequences.TitleEnd) {
            if (this.decodeEntities && c === CharCodes.Amp) {
              this.state = State.BeforeEntity;
            }
          } else if (this.fastForwardTo(CharCodes.Lt)) {
            this.sequenceIndex = 1;
          }
        } else {
          this.sequenceIndex = Number(c === CharCodes.Lt);
        }
      };
      Tokenizer2.prototype.stateCDATASequence = function(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
          if (++this.sequenceIndex === Sequences.Cdata.length) {
            this.state = State.InCommentLike;
            this.currentSequence = Sequences.CdataEnd;
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
          }
        } else {
          this.sequenceIndex = 0;
          this.state = State.InDeclaration;
          this.stateInDeclaration(c);
        }
      };
      Tokenizer2.prototype.fastForwardTo = function(c) {
        while (++this.index < this.buffer.length + this.offset) {
          if (this.buffer.charCodeAt(this.index - this.offset) === c) {
            return true;
          }
        }
        this.index = this.buffer.length + this.offset - 1;
        return false;
      };
      Tokenizer2.prototype.stateInCommentLike = function(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
          if (++this.sequenceIndex === this.currentSequence.length) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, this.index, 2);
            } else {
              this.cbs.oncomment(this.sectionStart, this.index, 2);
            }
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
            this.state = State.Text;
          }
        } else if (this.sequenceIndex === 0) {
          if (this.fastForwardTo(this.currentSequence[0])) {
            this.sequenceIndex = 1;
          }
        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
          this.sequenceIndex = 0;
        }
      };
      Tokenizer2.prototype.isTagStartChar = function(c) {
        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
      };
      Tokenizer2.prototype.startSpecial = function(sequence, offset) {
        this.isSpecial = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
        this.state = State.SpecialStartSequence;
      };
      Tokenizer2.prototype.stateBeforeTagName = function(c) {
        if (c === CharCodes.ExclamationMark) {
          this.state = State.BeforeDeclaration;
          this.sectionStart = this.index + 1;
        } else if (c === CharCodes.Questionmark) {
          this.state = State.InProcessingInstruction;
          this.sectionStart = this.index + 1;
        } else if (this.isTagStartChar(c)) {
          var lower = c | 32;
          this.sectionStart = this.index;
          if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
            this.startSpecial(Sequences.TitleEnd, 3);
          } else {
            this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
          }
        } else if (c === CharCodes.Slash) {
          this.state = State.BeforeClosingTagName;
        } else {
          this.state = State.Text;
          this.stateText(c);
        }
      };
      Tokenizer2.prototype.stateInTagName = function(c) {
        if (isEndOfTagSection(c)) {
          this.cbs.onopentagname(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = State.BeforeAttributeName;
          this.stateBeforeAttributeName(c);
        }
      };
      Tokenizer2.prototype.stateBeforeClosingTagName = function(c) {
        if (isWhitespace(c)) {
        } else if (c === CharCodes.Gt) {
          this.state = State.Text;
        } else {
          this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
          this.sectionStart = this.index;
        }
      };
      Tokenizer2.prototype.stateInClosingTagName = function(c) {
        if (c === CharCodes.Gt || isWhitespace(c)) {
          this.cbs.onclosetag(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = State.AfterClosingTagName;
          this.stateAfterClosingTagName(c);
        }
      };
      Tokenizer2.prototype.stateAfterClosingTagName = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.state = State.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer2.prototype.stateBeforeAttributeName = function(c) {
        if (c === CharCodes.Gt) {
          this.cbs.onopentagend(this.index);
          if (this.isSpecial) {
            this.state = State.InSpecialTag;
            this.sequenceIndex = 0;
          } else {
            this.state = State.Text;
          }
          this.baseState = this.state;
          this.sectionStart = this.index + 1;
        } else if (c === CharCodes.Slash) {
          this.state = State.InSelfClosingTag;
        } else if (!isWhitespace(c)) {
          this.state = State.InAttributeName;
          this.sectionStart = this.index;
        }
      };
      Tokenizer2.prototype.stateInSelfClosingTag = function(c) {
        if (c === CharCodes.Gt) {
          this.cbs.onselfclosingtag(this.index);
          this.state = State.Text;
          this.baseState = State.Text;
          this.sectionStart = this.index + 1;
          this.isSpecial = false;
        } else if (!isWhitespace(c)) {
          this.state = State.BeforeAttributeName;
          this.stateBeforeAttributeName(c);
        }
      };
      Tokenizer2.prototype.stateInAttributeName = function(c) {
        if (c === CharCodes.Eq || isEndOfTagSection(c)) {
          this.cbs.onattribname(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = State.AfterAttributeName;
          this.stateAfterAttributeName(c);
        }
      };
      Tokenizer2.prototype.stateAfterAttributeName = function(c) {
        if (c === CharCodes.Eq) {
          this.state = State.BeforeAttributeValue;
        } else if (c === CharCodes.Slash || c === CharCodes.Gt) {
          this.cbs.onattribend(QuoteType.NoValue, this.index);
          this.state = State.BeforeAttributeName;
          this.stateBeforeAttributeName(c);
        } else if (!isWhitespace(c)) {
          this.cbs.onattribend(QuoteType.NoValue, this.index);
          this.state = State.InAttributeName;
          this.sectionStart = this.index;
        }
      };
      Tokenizer2.prototype.stateBeforeAttributeValue = function(c) {
        if (c === CharCodes.DoubleQuote) {
          this.state = State.InAttributeValueDq;
          this.sectionStart = this.index + 1;
        } else if (c === CharCodes.SingleQuote) {
          this.state = State.InAttributeValueSq;
          this.sectionStart = this.index + 1;
        } else if (!isWhitespace(c)) {
          this.sectionStart = this.index;
          this.state = State.InAttributeValueNq;
          this.stateInAttributeValueNoQuotes(c);
        }
      };
      Tokenizer2.prototype.handleInAttributeValue = function(c, quote) {
        if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
          this.state = State.BeforeAttributeName;
        } else if (this.decodeEntities && c === CharCodes.Amp) {
          this.baseState = this.state;
          this.state = State.BeforeEntity;
        }
      };
      Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c) {
        this.handleInAttributeValue(c, CharCodes.DoubleQuote);
      };
      Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c) {
        this.handleInAttributeValue(c, CharCodes.SingleQuote);
      };
      Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c) {
        if (isWhitespace(c) || c === CharCodes.Gt) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(QuoteType.Unquoted, this.index);
          this.state = State.BeforeAttributeName;
          this.stateBeforeAttributeName(c);
        } else if (this.decodeEntities && c === CharCodes.Amp) {
          this.baseState = this.state;
          this.state = State.BeforeEntity;
        }
      };
      Tokenizer2.prototype.stateBeforeDeclaration = function(c) {
        if (c === CharCodes.OpeningSquareBracket) {
          this.state = State.CDATASequence;
          this.sequenceIndex = 0;
        } else {
          this.state = c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
        }
      };
      Tokenizer2.prototype.stateInDeclaration = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.cbs.ondeclaration(this.sectionStart, this.index);
          this.state = State.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer2.prototype.stateInProcessingInstruction = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.cbs.onprocessinginstruction(this.sectionStart, this.index);
          this.state = State.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer2.prototype.stateBeforeComment = function(c) {
        if (c === CharCodes.Dash) {
          this.state = State.InCommentLike;
          this.currentSequence = Sequences.CommentEnd;
          this.sequenceIndex = 2;
          this.sectionStart = this.index + 1;
        } else {
          this.state = State.InDeclaration;
        }
      };
      Tokenizer2.prototype.stateInSpecialComment = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.cbs.oncomment(this.sectionStart, this.index, 0);
          this.state = State.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer2.prototype.stateBeforeSpecialS = function(c) {
        var lower = c | 32;
        if (lower === Sequences.ScriptEnd[3]) {
          this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (lower === Sequences.StyleEnd[3]) {
          this.startSpecial(Sequences.StyleEnd, 4);
        } else {
          this.state = State.InTagName;
          this.stateInTagName(c);
        }
      };
      Tokenizer2.prototype.stateBeforeEntity = function(c) {
        this.entityExcess = 1;
        this.entityResult = 0;
        if (c === CharCodes.Num) {
          this.state = State.BeforeNumericEntity;
        } else if (c === CharCodes.Amp) {
        } else {
          this.trieIndex = 0;
          this.trieCurrent = this.entityTrie[0];
          this.state = State.InNamedEntity;
          this.stateInNamedEntity(c);
        }
      };
      Tokenizer2.prototype.stateInNamedEntity = function(c) {
        this.entityExcess += 1;
        this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
        if (this.trieIndex < 0) {
          this.emitNamedEntity();
          this.index--;
          return;
        }
        this.trieCurrent = this.entityTrie[this.trieIndex];
        var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
        if (masked) {
          var valueLength = (masked >> 14) - 1;
          if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
            this.trieIndex += valueLength;
          } else {
            var entityStart = this.index - this.entityExcess + 1;
            if (entityStart > this.sectionStart) {
              this.emitPartial(this.sectionStart, entityStart);
            }
            this.entityResult = this.trieIndex;
            this.trieIndex += valueLength;
            this.entityExcess = 0;
            this.sectionStart = this.index + 1;
            if (valueLength === 0) {
              this.emitNamedEntity();
            }
          }
        }
      };
      Tokenizer2.prototype.emitNamedEntity = function() {
        this.state = this.baseState;
        if (this.entityResult === 0) {
          return;
        }
        var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >> 14;
        switch (valueLength) {
          case 1:
            this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
            break;
          case 2:
            this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
            break;
          case 3: {
            this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
            this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
          }
        }
      };
      Tokenizer2.prototype.stateBeforeNumericEntity = function(c) {
        if ((c | 32) === CharCodes.LowerX) {
          this.entityExcess++;
          this.state = State.InHexEntity;
        } else {
          this.state = State.InNumericEntity;
          this.stateInNumericEntity(c);
        }
      };
      Tokenizer2.prototype.emitNumericEntity = function(strict) {
        var entityStart = this.index - this.entityExcess - 1;
        var numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
        if (numberStart !== this.index) {
          if (entityStart > this.sectionStart) {
            this.emitPartial(this.sectionStart, entityStart);
          }
          this.sectionStart = this.index + Number(strict);
          this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
        }
        this.state = this.baseState;
      };
      Tokenizer2.prototype.stateInNumericEntity = function(c) {
        if (c === CharCodes.Semi) {
          this.emitNumericEntity(true);
        } else if (isNumber(c)) {
          this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
          this.entityExcess++;
        } else {
          if (this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else {
            this.state = this.baseState;
          }
          this.index--;
        }
      };
      Tokenizer2.prototype.stateInHexEntity = function(c) {
        if (c === CharCodes.Semi) {
          this.emitNumericEntity(true);
        } else if (isNumber(c)) {
          this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
          this.entityExcess++;
        } else if (isHexDigit(c)) {
          this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes.LowerA + 10);
          this.entityExcess++;
        } else {
          if (this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else {
            this.state = this.baseState;
          }
          this.index--;
        }
      };
      Tokenizer2.prototype.allowLegacyEntity = function() {
        return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
      };
      Tokenizer2.prototype.cleanup = function() {
        if (this.running && this.sectionStart !== this.index) {
          if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
            this.cbs.ontext(this.sectionStart, this.index);
            this.sectionStart = this.index;
          } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = this.index;
          }
        }
      };
      Tokenizer2.prototype.shouldContinue = function() {
        return this.index < this.buffer.length + this.offset && this.running;
      };
      Tokenizer2.prototype.parse = function() {
        while (this.shouldContinue()) {
          var c = this.buffer.charCodeAt(this.index - this.offset);
          if (this.state === State.Text) {
            this.stateText(c);
          } else if (this.state === State.SpecialStartSequence) {
            this.stateSpecialStartSequence(c);
          } else if (this.state === State.InSpecialTag) {
            this.stateInSpecialTag(c);
          } else if (this.state === State.CDATASequence) {
            this.stateCDATASequence(c);
          } else if (this.state === State.InAttributeValueDq) {
            this.stateInAttributeValueDoubleQuotes(c);
          } else if (this.state === State.InAttributeName) {
            this.stateInAttributeName(c);
          } else if (this.state === State.InCommentLike) {
            this.stateInCommentLike(c);
          } else if (this.state === State.InSpecialComment) {
            this.stateInSpecialComment(c);
          } else if (this.state === State.BeforeAttributeName) {
            this.stateBeforeAttributeName(c);
          } else if (this.state === State.InTagName) {
            this.stateInTagName(c);
          } else if (this.state === State.InClosingTagName) {
            this.stateInClosingTagName(c);
          } else if (this.state === State.BeforeTagName) {
            this.stateBeforeTagName(c);
          } else if (this.state === State.AfterAttributeName) {
            this.stateAfterAttributeName(c);
          } else if (this.state === State.InAttributeValueSq) {
            this.stateInAttributeValueSingleQuotes(c);
          } else if (this.state === State.BeforeAttributeValue) {
            this.stateBeforeAttributeValue(c);
          } else if (this.state === State.BeforeClosingTagName) {
            this.stateBeforeClosingTagName(c);
          } else if (this.state === State.AfterClosingTagName) {
            this.stateAfterClosingTagName(c);
          } else if (this.state === State.BeforeSpecialS) {
            this.stateBeforeSpecialS(c);
          } else if (this.state === State.InAttributeValueNq) {
            this.stateInAttributeValueNoQuotes(c);
          } else if (this.state === State.InSelfClosingTag) {
            this.stateInSelfClosingTag(c);
          } else if (this.state === State.InDeclaration) {
            this.stateInDeclaration(c);
          } else if (this.state === State.BeforeDeclaration) {
            this.stateBeforeDeclaration(c);
          } else if (this.state === State.BeforeComment) {
            this.stateBeforeComment(c);
          } else if (this.state === State.InProcessingInstruction) {
            this.stateInProcessingInstruction(c);
          } else if (this.state === State.InNamedEntity) {
            this.stateInNamedEntity(c);
          } else if (this.state === State.BeforeEntity) {
            this.stateBeforeEntity(c);
          } else if (this.state === State.InHexEntity) {
            this.stateInHexEntity(c);
          } else if (this.state === State.InNumericEntity) {
            this.stateInNumericEntity(c);
          } else {
            this.stateBeforeNumericEntity(c);
          }
          this.index++;
        }
        this.cleanup();
      };
      Tokenizer2.prototype.finish = function() {
        if (this.state === State.InNamedEntity) {
          this.emitNamedEntity();
        }
        if (this.sectionStart < this.index) {
          this.handleTrailingData();
        }
        this.cbs.onend();
      };
      Tokenizer2.prototype.handleTrailingData = function() {
        var endIndex = this.buffer.length + this.offset;
        if (this.state === State.InCommentLike) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, endIndex, 0);
          } else {
            this.cbs.oncomment(this.sectionStart, endIndex, 0);
          }
        } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
        } else {
          this.cbs.ontext(this.sectionStart, endIndex);
        }
      };
      Tokenizer2.prototype.emitPartial = function(start, endIndex) {
        if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
          this.cbs.onattribdata(start, endIndex);
        } else {
          this.cbs.ontext(start, endIndex);
        }
      };
      Tokenizer2.prototype.emitCodePoint = function(cp) {
        if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
          this.cbs.onattribentity(cp);
        } else {
          this.cbs.ontextentity(cp);
        }
      };
      return Tokenizer2;
    }();
    exports.default = Tokenizer;
  }
});

// node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/htmlparser2/lib/Parser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var Tokenizer_js_1 = __importStar(require_Tokenizer());
    var decode_js_1 = require_decode();
    var formTags = /* @__PURE__ */ new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea"
    ]);
    var pTag = /* @__PURE__ */ new Set(["p"]);
    var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
    var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
    var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
    var openImpliesClose = /* @__PURE__ */ new Map([
      ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
      ["th", /* @__PURE__ */ new Set(["th"])],
      ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
      ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
      ["li", /* @__PURE__ */ new Set(["li"])],
      ["p", pTag],
      ["h1", pTag],
      ["h2", pTag],
      ["h3", pTag],
      ["h4", pTag],
      ["h5", pTag],
      ["h6", pTag],
      ["select", formTags],
      ["input", formTags],
      ["output", formTags],
      ["button", formTags],
      ["datalist", formTags],
      ["textarea", formTags],
      ["option", /* @__PURE__ */ new Set(["option"])],
      ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
      ["dd", ddtTags],
      ["dt", ddtTags],
      ["address", pTag],
      ["article", pTag],
      ["aside", pTag],
      ["blockquote", pTag],
      ["details", pTag],
      ["div", pTag],
      ["dl", pTag],
      ["fieldset", pTag],
      ["figcaption", pTag],
      ["figure", pTag],
      ["footer", pTag],
      ["form", pTag],
      ["header", pTag],
      ["hr", pTag],
      ["main", pTag],
      ["nav", pTag],
      ["ol", pTag],
      ["pre", pTag],
      ["section", pTag],
      ["table", pTag],
      ["ul", pTag],
      ["rt", rtpTags],
      ["rp", rtpTags],
      ["tbody", tableSectionTags],
      ["tfoot", tableSectionTags]
    ]);
    var voidElements = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
    var htmlIntegrationElements = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignobject",
      "desc",
      "title"
    ]);
    var reNameEnd = /\s|\//;
    var Parser = function() {
      function Parser2(cbs, options) {
        if (options === void 0) {
          options = {};
        }
        var _a, _b, _c, _d, _e;
        this.options = options;
        this.startIndex = 0;
        this.endIndex = 0;
        this.openTagStart = 0;
        this.tagname = "";
        this.attribname = "";
        this.attribvalue = "";
        this.attribs = null;
        this.stack = [];
        this.foreignContext = [];
        this.buffers = [];
        this.bufferOffset = 0;
        this.writeIndex = 0;
        this.ended = false;
        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
        this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
      }
      Parser2.prototype.ontext = function(start, endIndex) {
        var _a, _b;
        var data = this.getSlice(start, endIndex);
        this.endIndex = endIndex - 1;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
        this.startIndex = endIndex;
      };
      Parser2.prototype.ontextentity = function(cp) {
        var _a, _b;
        var idx = this.tokenizer.getSectionStart();
        this.endIndex = idx - 1;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
        this.startIndex = idx;
      };
      Parser2.prototype.isVoidElement = function(name) {
        return !this.options.xmlMode && voidElements.has(name);
      };
      Parser2.prototype.onopentagname = function(start, endIndex) {
        this.endIndex = endIndex;
        var name = this.getSlice(start, endIndex);
        if (this.lowerCaseTagNames) {
          name = name.toLowerCase();
        }
        this.emitOpenTag(name);
      };
      Parser2.prototype.emitOpenTag = function(name) {
        var _a, _b, _c, _d;
        this.openTagStart = this.startIndex;
        this.tagname = name;
        var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
        if (impliesClose) {
          while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
            var el = this.stack.pop();
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, el, true);
          }
        }
        if (!this.isVoidElement(name)) {
          this.stack.push(name);
          if (foreignContextElements.has(name)) {
            this.foreignContext.push(true);
          } else if (htmlIntegrationElements.has(name)) {
            this.foreignContext.push(false);
          }
        }
        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
        if (this.cbs.onopentag)
          this.attribs = {};
      };
      Parser2.prototype.endOpenTag = function(isImplied) {
        var _a, _b;
        this.startIndex = this.openTagStart;
        if (this.attribs) {
          (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
          this.attribs = null;
        }
        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
          this.cbs.onclosetag(this.tagname, true);
        }
        this.tagname = "";
      };
      Parser2.prototype.onopentagend = function(endIndex) {
        this.endIndex = endIndex;
        this.endOpenTag(false);
        this.startIndex = endIndex + 1;
      };
      Parser2.prototype.onclosetag = function(start, endIndex) {
        var _a, _b, _c, _d, _e, _f;
        this.endIndex = endIndex;
        var name = this.getSlice(start, endIndex);
        if (this.lowerCaseTagNames) {
          name = name.toLowerCase();
        }
        if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
          this.foreignContext.pop();
        }
        if (!this.isVoidElement(name)) {
          var pos = this.stack.lastIndexOf(name);
          if (pos !== -1) {
            if (this.cbs.onclosetag) {
              var count = this.stack.length - pos;
              while (count--) {
                this.cbs.onclosetag(this.stack.pop(), count !== 0);
              }
            } else
              this.stack.length = pos;
          } else if (!this.options.xmlMode && name === "p") {
            this.emitOpenTag("p");
            this.closeCurrentTag(true);
          }
        } else if (!this.options.xmlMode && name === "br") {
          (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
          (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
          (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
        }
        this.startIndex = endIndex + 1;
      };
      Parser2.prototype.onselfclosingtag = function(endIndex) {
        this.endIndex = endIndex;
        if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
          this.closeCurrentTag(false);
          this.startIndex = endIndex + 1;
        } else {
          this.onopentagend(endIndex);
        }
      };
      Parser2.prototype.closeCurrentTag = function(isOpenImplied) {
        var _a, _b;
        var name = this.tagname;
        this.endOpenTag(isOpenImplied);
        if (this.stack[this.stack.length - 1] === name) {
          (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
          this.stack.pop();
        }
      };
      Parser2.prototype.onattribname = function(start, endIndex) {
        this.startIndex = start;
        var name = this.getSlice(start, endIndex);
        this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
      };
      Parser2.prototype.onattribdata = function(start, endIndex) {
        this.attribvalue += this.getSlice(start, endIndex);
      };
      Parser2.prototype.onattribentity = function(cp) {
        this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
      };
      Parser2.prototype.onattribend = function(quote, endIndex) {
        var _a, _b;
        this.endIndex = endIndex;
        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? void 0 : null);
        if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
          this.attribs[this.attribname] = this.attribvalue;
        }
        this.attribvalue = "";
      };
      Parser2.prototype.getInstructionName = function(value) {
        var idx = value.search(reNameEnd);
        var name = idx < 0 ? value : value.substr(0, idx);
        if (this.lowerCaseTagNames) {
          name = name.toLowerCase();
        }
        return name;
      };
      Parser2.prototype.ondeclaration = function(start, endIndex) {
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex);
        if (this.cbs.onprocessinginstruction) {
          var name = this.getInstructionName(value);
          this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
        }
        this.startIndex = endIndex + 1;
      };
      Parser2.prototype.onprocessinginstruction = function(start, endIndex) {
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex);
        if (this.cbs.onprocessinginstruction) {
          var name = this.getInstructionName(value);
          this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
        }
        this.startIndex = endIndex + 1;
      };
      Parser2.prototype.oncomment = function(start, endIndex, offset) {
        var _a, _b, _c, _d;
        this.endIndex = endIndex;
        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
        this.startIndex = endIndex + 1;
      };
      Parser2.prototype.oncdata = function(start, endIndex, offset) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex - offset);
        if (this.options.xmlMode || this.options.recognizeCDATA) {
          (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
          (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
          (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
        } else {
          (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
          (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
        }
        this.startIndex = endIndex + 1;
      };
      Parser2.prototype.onend = function() {
        var _a, _b;
        if (this.cbs.onclosetag) {
          this.endIndex = this.startIndex;
          for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i], true))
            ;
        }
        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
      };
      Parser2.prototype.reset = function() {
        var _a, _b, _c, _d;
        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.tokenizer.reset();
        this.tagname = "";
        this.attribname = "";
        this.attribs = null;
        this.stack.length = 0;
        this.startIndex = 0;
        this.endIndex = 0;
        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        this.buffers.length = 0;
        this.bufferOffset = 0;
        this.writeIndex = 0;
        this.ended = false;
      };
      Parser2.prototype.parseComplete = function(data) {
        this.reset();
        this.end(data);
      };
      Parser2.prototype.getSlice = function(start, end) {
        while (start - this.bufferOffset >= this.buffers[0].length) {
          this.shiftBuffer();
        }
        var str = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
        while (end - this.bufferOffset > this.buffers[0].length) {
          this.shiftBuffer();
          str += this.buffers[0].slice(0, end - this.bufferOffset);
        }
        return str;
      };
      Parser2.prototype.shiftBuffer = function() {
        this.bufferOffset += this.buffers[0].length;
        this.writeIndex--;
        this.buffers.shift();
      };
      Parser2.prototype.write = function(chunk) {
        var _a, _b;
        if (this.ended) {
          (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
          return;
        }
        this.buffers.push(chunk);
        if (this.tokenizer.running) {
          this.tokenizer.write(chunk);
          this.writeIndex++;
        }
      };
      Parser2.prototype.end = function(chunk) {
        var _a, _b;
        if (this.ended) {
          (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, Error(".end() after done!"));
          return;
        }
        if (chunk)
          this.write(chunk);
        this.ended = true;
        this.tokenizer.end();
      };
      Parser2.prototype.pause = function() {
        this.tokenizer.pause();
      };
      Parser2.prototype.resume = function() {
        this.tokenizer.resume();
        while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
          this.tokenizer.write(this.buffers[this.writeIndex++]);
        }
        if (this.ended)
          this.tokenizer.end();
      };
      Parser2.prototype.parseChunk = function(chunk) {
        this.write(chunk);
      };
      Parser2.prototype.done = function(chunk) {
        this.end(chunk);
      };
      return Parser2;
    }();
    exports.Parser = Parser;
  }
});

// node_modules/domelementtype/lib/index.js
var require_lib = __commonJS({
  "node_modules/domelementtype/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })(ElementType = exports.ElementType || (exports.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports.isTag = isTag;
    exports.Root = ElementType.Root;
    exports.Text = ElementType.Text;
    exports.Directive = ElementType.Directive;
    exports.Comment = ElementType.Comment;
    exports.Script = ElementType.Script;
    exports.Style = ElementType.Style;
    exports.Tag = ElementType.Tag;
    exports.CDATA = ElementType.CDATA;
    exports.Doctype = ElementType.Doctype;
  }
});

// node_modules/domhandler/lib/node.js
var require_node = __commonJS({
  "node_modules/domhandler/lib/node.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
    var domelementtype_1 = require_lib();
    var Node = function() {
      function Node2() {
        this.parent = null;
        this.prev = null;
        this.next = null;
        this.startIndex = null;
        this.endIndex = null;
      }
      Object.defineProperty(Node2.prototype, "parentNode", {
        get: function() {
          return this.parent;
        },
        set: function(parent) {
          this.parent = parent;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "previousSibling", {
        get: function() {
          return this.prev;
        },
        set: function(prev) {
          this.prev = prev;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "nextSibling", {
        get: function() {
          return this.next;
        },
        set: function(next) {
          this.next = next;
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype.cloneNode = function(recursive) {
        if (recursive === void 0) {
          recursive = false;
        }
        return cloneNode(this, recursive);
      };
      return Node2;
    }();
    exports.Node = Node;
    var DataNode = function(_super) {
      __extends(DataNode2, _super);
      function DataNode2(data) {
        var _this = _super.call(this) || this;
        _this.data = data;
        return _this;
      }
      Object.defineProperty(DataNode2.prototype, "nodeValue", {
        get: function() {
          return this.data;
        },
        set: function(data) {
          this.data = data;
        },
        enumerable: false,
        configurable: true
      });
      return DataNode2;
    }(Node);
    exports.DataNode = DataNode;
    var Text = function(_super) {
      __extends(Text2, _super);
      function Text2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Text;
        return _this;
      }
      Object.defineProperty(Text2.prototype, "nodeType", {
        get: function() {
          return 3;
        },
        enumerable: false,
        configurable: true
      });
      return Text2;
    }(DataNode);
    exports.Text = Text;
    var Comment = function(_super) {
      __extends(Comment2, _super);
      function Comment2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Comment;
        return _this;
      }
      Object.defineProperty(Comment2.prototype, "nodeType", {
        get: function() {
          return 8;
        },
        enumerable: false,
        configurable: true
      });
      return Comment2;
    }(DataNode);
    exports.Comment = Comment;
    var ProcessingInstruction = function(_super) {
      __extends(ProcessingInstruction2, _super);
      function ProcessingInstruction2(name, data) {
        var _this = _super.call(this, data) || this;
        _this.name = name;
        _this.type = domelementtype_1.ElementType.Directive;
        return _this;
      }
      Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
        get: function() {
          return 1;
        },
        enumerable: false,
        configurable: true
      });
      return ProcessingInstruction2;
    }(DataNode);
    exports.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = function(_super) {
      __extends(NodeWithChildren2, _super);
      function NodeWithChildren2(children) {
        var _this = _super.call(this) || this;
        _this.children = children;
        return _this;
      }
      Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
        get: function() {
          var _a;
          return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
        get: function() {
          return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
        get: function() {
          return this.children;
        },
        set: function(children) {
          this.children = children;
        },
        enumerable: false,
        configurable: true
      });
      return NodeWithChildren2;
    }(Node);
    exports.NodeWithChildren = NodeWithChildren;
    var CDATA = function(_super) {
      __extends(CDATA2, _super);
      function CDATA2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.CDATA;
        return _this;
      }
      Object.defineProperty(CDATA2.prototype, "nodeType", {
        get: function() {
          return 4;
        },
        enumerable: false,
        configurable: true
      });
      return CDATA2;
    }(NodeWithChildren);
    exports.CDATA = CDATA;
    var Document = function(_super) {
      __extends(Document2, _super);
      function Document2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Root;
        return _this;
      }
      Object.defineProperty(Document2.prototype, "nodeType", {
        get: function() {
          return 9;
        },
        enumerable: false,
        configurable: true
      });
      return Document2;
    }(NodeWithChildren);
    exports.Document = Document;
    var Element2 = function(_super) {
      __extends(Element3, _super);
      function Element3(name, attribs, children, type) {
        if (children === void 0) {
          children = [];
        }
        if (type === void 0) {
          type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
        }
        var _this = _super.call(this, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        _this.type = type;
        return _this;
      }
      Object.defineProperty(Element3.prototype, "nodeType", {
        get: function() {
          return 1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "tagName", {
        get: function() {
          return this.name;
        },
        set: function(name) {
          this.name = name;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "attributes", {
        get: function() {
          var _this = this;
          return Object.keys(this.attribs).map(function(name) {
            var _a, _b;
            return {
              name,
              value: _this.attribs[name],
              namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
              prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
            };
          });
        },
        enumerable: false,
        configurable: true
      });
      return Element3;
    }(NodeWithChildren);
    exports.Element = Element2;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText(node)) {
        result = new Text(node.data);
      } else if (isComment(node)) {
        result = new Comment(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element2(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
      }
      return children;
    }
  }
});

// node_modules/domhandler/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/domhandler/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;
    var domelementtype_1 = require_lib();
    var node_js_1 = require_node();
    __exportStar(require_node(), exports);
    var defaultOpts = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = function() {
      function DomHandler2(callback, options, elementCB) {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options === "function") {
          elementCB = options;
          options = defaultOpts;
        }
        if (typeof callback === "object") {
          options = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser) {
        this.parser = parser;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
        var element = new node_js_1.Element(name, attribs, void 0, type);
        this.addNode(element);
        this.tagStack.push(element);
      };
      DomHandler2.prototype.ontext = function(data) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
          lastNode.data += data;
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          var node = new node_js_1.Text(data);
          this.addNode(node);
          this.lastNode = node;
        }
      };
      DomHandler2.prototype.oncomment = function(data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
          this.lastNode.data += data;
          return;
        }
        var node = new node_js_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text = new node_js_1.Text("");
        var node = new node_js_1.CDATA([text]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name, data) {
        var node = new node_js_1.ProcessingInstruction(name, data);
        this.addNode(node);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
          node.prev = previousSibling;
          previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }();
    exports.DomHandler = DomHandler;
    exports.default = DomHandler;
  }
});

// node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS({
  "node_modules/entities/lib/generated/encode-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = /* @__PURE__ */ new Map([[9, "&Tab;"], [10, "&NewLine;"], [33, "&excl;"], [34, "&quot;"], [35, "&num;"], [36, "&dollar;"], [37, "&percnt;"], [38, "&amp;"], [39, "&apos;"], [40, "&lpar;"], [41, "&rpar;"], [42, "&ast;"], [43, "&plus;"], [44, "&comma;"], [46, "&period;"], [47, "&sol;"], [58, "&colon;"], [59, "&semi;"], [60, { v: "&lt;", n: 8402, o: "&nvlt;" }], [61, { v: "&equals;", n: 8421, o: "&bne;" }], [62, { v: "&gt;", n: 8402, o: "&nvgt;" }], [63, "&quest;"], [64, "&commat;"], [91, "&lbrack;"], [92, "&bsol;"], [93, "&rbrack;"], [94, "&Hat;"], [95, "&lowbar;"], [96, "&DiacriticalGrave;"], [102, { n: 106, o: "&fjlig;" }], [123, "&lbrace;"], [124, "&verbar;"], [125, "&rbrace;"], [160, "&nbsp;"], [161, "&iexcl;"], [162, "&cent;"], [163, "&pound;"], [164, "&curren;"], [165, "&yen;"], [166, "&brvbar;"], [167, "&sect;"], [168, "&die;"], [169, "&copy;"], [170, "&ordf;"], [171, "&laquo;"], [172, "&not;"], [173, "&shy;"], [174, "&circledR;"], [175, "&macr;"], [176, "&deg;"], [177, "&PlusMinus;"], [178, "&sup2;"], [179, "&sup3;"], [180, "&acute;"], [181, "&micro;"], [182, "&para;"], [183, "&centerdot;"], [184, "&cedil;"], [185, "&sup1;"], [186, "&ordm;"], [187, "&raquo;"], [188, "&frac14;"], [189, "&frac12;"], [190, "&frac34;"], [191, "&iquest;"], [192, "&Agrave;"], [193, "&Aacute;"], [194, "&Acirc;"], [195, "&Atilde;"], [196, "&Auml;"], [197, "&angst;"], [198, "&AElig;"], [199, "&Ccedil;"], [200, "&Egrave;"], [201, "&Eacute;"], [202, "&Ecirc;"], [203, "&Euml;"], [204, "&Igrave;"], [205, "&Iacute;"], [206, "&Icirc;"], [207, "&Iuml;"], [208, "&ETH;"], [209, "&Ntilde;"], [210, "&Ograve;"], [211, "&Oacute;"], [212, "&Ocirc;"], [213, "&Otilde;"], [214, "&Ouml;"], [215, "&times;"], [216, "&Oslash;"], [217, "&Ugrave;"], [218, "&Uacute;"], [219, "&Ucirc;"], [220, "&Uuml;"], [221, "&Yacute;"], [222, "&THORN;"], [223, "&szlig;"], [224, "&agrave;"], [225, "&aacute;"], [226, "&acirc;"], [227, "&atilde;"], [228, "&auml;"], [229, "&aring;"], [230, "&aelig;"], [231, "&ccedil;"], [232, "&egrave;"], [233, "&eacute;"], [234, "&ecirc;"], [235, "&euml;"], [236, "&igrave;"], [237, "&iacute;"], [238, "&icirc;"], [239, "&iuml;"], [240, "&eth;"], [241, "&ntilde;"], [242, "&ograve;"], [243, "&oacute;"], [244, "&ocirc;"], [245, "&otilde;"], [246, "&ouml;"], [247, "&div;"], [248, "&oslash;"], [249, "&ugrave;"], [250, "&uacute;"], [251, "&ucirc;"], [252, "&uuml;"], [253, "&yacute;"], [254, "&thorn;"], [255, "&yuml;"], [256, "&Amacr;"], [257, "&amacr;"], [258, "&Abreve;"], [259, "&abreve;"], [260, "&Aogon;"], [261, "&aogon;"], [262, "&Cacute;"], [263, "&cacute;"], [264, "&Ccirc;"], [265, "&ccirc;"], [266, "&Cdot;"], [267, "&cdot;"], [268, "&Ccaron;"], [269, "&ccaron;"], [270, "&Dcaron;"], [271, "&dcaron;"], [272, "&Dstrok;"], [273, "&dstrok;"], [274, "&Emacr;"], [275, "&emacr;"], [278, "&Edot;"], [279, "&edot;"], [280, "&Eogon;"], [281, "&eogon;"], [282, "&Ecaron;"], [283, "&ecaron;"], [284, "&Gcirc;"], [285, "&gcirc;"], [286, "&Gbreve;"], [287, "&gbreve;"], [288, "&Gdot;"], [289, "&gdot;"], [290, "&Gcedil;"], [292, "&Hcirc;"], [293, "&hcirc;"], [294, "&Hstrok;"], [295, "&hstrok;"], [296, "&Itilde;"], [297, "&itilde;"], [298, "&Imacr;"], [299, "&imacr;"], [302, "&Iogon;"], [303, "&iogon;"], [304, "&Idot;"], [305, "&imath;"], [306, "&IJlig;"], [307, "&ijlig;"], [308, "&Jcirc;"], [309, "&jcirc;"], [310, "&Kcedil;"], [311, "&kcedil;"], [312, "&kgreen;"], [313, "&Lacute;"], [314, "&lacute;"], [315, "&Lcedil;"], [316, "&lcedil;"], [317, "&Lcaron;"], [318, "&lcaron;"], [319, "&Lmidot;"], [320, "&lmidot;"], [321, "&Lstrok;"], [322, "&lstrok;"], [323, "&Nacute;"], [324, "&nacute;"], [325, "&Ncedil;"], [326, "&ncedil;"], [327, "&Ncaron;"], [328, "&ncaron;"], [329, "&napos;"], [330, "&ENG;"], [331, "&eng;"], [332, "&Omacr;"], [333, "&omacr;"], [336, "&Odblac;"], [337, "&odblac;"], [338, "&OElig;"], [339, "&oelig;"], [340, "&Racute;"], [341, "&racute;"], [342, "&Rcedil;"], [343, "&rcedil;"], [344, "&Rcaron;"], [345, "&rcaron;"], [346, "&Sacute;"], [347, "&sacute;"], [348, "&Scirc;"], [349, "&scirc;"], [350, "&Scedil;"], [351, "&scedil;"], [352, "&Scaron;"], [353, "&scaron;"], [354, "&Tcedil;"], [355, "&tcedil;"], [356, "&Tcaron;"], [357, "&tcaron;"], [358, "&Tstrok;"], [359, "&tstrok;"], [360, "&Utilde;"], [361, "&utilde;"], [362, "&Umacr;"], [363, "&umacr;"], [364, "&Ubreve;"], [365, "&ubreve;"], [366, "&Uring;"], [367, "&uring;"], [368, "&Udblac;"], [369, "&udblac;"], [370, "&Uogon;"], [371, "&uogon;"], [372, "&Wcirc;"], [373, "&wcirc;"], [374, "&Ycirc;"], [375, "&ycirc;"], [376, "&Yuml;"], [377, "&Zacute;"], [378, "&zacute;"], [379, "&Zdot;"], [380, "&zdot;"], [381, "&Zcaron;"], [382, "&zcaron;"], [402, "&fnof;"], [437, "&imped;"], [501, "&gacute;"], [567, "&jmath;"], [710, "&circ;"], [711, "&caron;"], [728, "&breve;"], [729, "&DiacriticalDot;"], [730, "&ring;"], [731, "&ogon;"], [732, "&DiacriticalTilde;"], [733, "&dblac;"], [785, "&DownBreve;"], [913, "&Alpha;"], [914, "&Beta;"], [915, "&Gamma;"], [916, "&Delta;"], [917, "&Epsilon;"], [918, "&Zeta;"], [919, "&Eta;"], [920, "&Theta;"], [921, "&Iota;"], [922, "&Kappa;"], [923, "&Lambda;"], [924, "&Mu;"], [925, "&Nu;"], [926, "&Xi;"], [927, "&Omicron;"], [928, "&Pi;"], [929, "&Rho;"], [931, "&Sigma;"], [932, "&Tau;"], [933, "&Upsilon;"], [934, "&Phi;"], [935, "&Chi;"], [936, "&Psi;"], [937, "&ohm;"], [945, "&alpha;"], [946, "&beta;"], [947, "&gamma;"], [948, "&delta;"], [949, "&epsi;"], [950, "&zeta;"], [951, "&eta;"], [952, "&theta;"], [953, "&iota;"], [954, "&kappa;"], [955, "&lambda;"], [956, "&mu;"], [957, "&nu;"], [958, "&xi;"], [959, "&omicron;"], [960, "&pi;"], [961, "&rho;"], [962, "&sigmaf;"], [963, "&sigma;"], [964, "&tau;"], [965, "&upsi;"], [966, "&phi;"], [967, "&chi;"], [968, "&psi;"], [969, "&omega;"], [977, "&thetasym;"], [978, "&Upsi;"], [981, "&phiv;"], [982, "&piv;"], [988, "&Gammad;"], [989, "&digamma;"], [1008, "&kappav;"], [1009, "&rhov;"], [1013, "&epsiv;"], [1014, "&backepsilon;"], [1025, "&IOcy;"], [1026, "&DJcy;"], [1027, "&GJcy;"], [1028, "&Jukcy;"], [1029, "&DScy;"], [1030, "&Iukcy;"], [1031, "&YIcy;"], [1032, "&Jsercy;"], [1033, "&LJcy;"], [1034, "&NJcy;"], [1035, "&TSHcy;"], [1036, "&KJcy;"], [1038, "&Ubrcy;"], [1039, "&DZcy;"], [1040, "&Acy;"], [1041, "&Bcy;"], [1042, "&Vcy;"], [1043, "&Gcy;"], [1044, "&Dcy;"], [1045, "&IEcy;"], [1046, "&ZHcy;"], [1047, "&Zcy;"], [1048, "&Icy;"], [1049, "&Jcy;"], [1050, "&Kcy;"], [1051, "&Lcy;"], [1052, "&Mcy;"], [1053, "&Ncy;"], [1054, "&Ocy;"], [1055, "&Pcy;"], [1056, "&Rcy;"], [1057, "&Scy;"], [1058, "&Tcy;"], [1059, "&Ucy;"], [1060, "&Fcy;"], [1061, "&KHcy;"], [1062, "&TScy;"], [1063, "&CHcy;"], [1064, "&SHcy;"], [1065, "&SHCHcy;"], [1066, "&HARDcy;"], [1067, "&Ycy;"], [1068, "&SOFTcy;"], [1069, "&Ecy;"], [1070, "&YUcy;"], [1071, "&YAcy;"], [1072, "&acy;"], [1073, "&bcy;"], [1074, "&vcy;"], [1075, "&gcy;"], [1076, "&dcy;"], [1077, "&iecy;"], [1078, "&zhcy;"], [1079, "&zcy;"], [1080, "&icy;"], [1081, "&jcy;"], [1082, "&kcy;"], [1083, "&lcy;"], [1084, "&mcy;"], [1085, "&ncy;"], [1086, "&ocy;"], [1087, "&pcy;"], [1088, "&rcy;"], [1089, "&scy;"], [1090, "&tcy;"], [1091, "&ucy;"], [1092, "&fcy;"], [1093, "&khcy;"], [1094, "&tscy;"], [1095, "&chcy;"], [1096, "&shcy;"], [1097, "&shchcy;"], [1098, "&hardcy;"], [1099, "&ycy;"], [1100, "&softcy;"], [1101, "&ecy;"], [1102, "&yucy;"], [1103, "&yacy;"], [1105, "&iocy;"], [1106, "&djcy;"], [1107, "&gjcy;"], [1108, "&jukcy;"], [1109, "&dscy;"], [1110, "&iukcy;"], [1111, "&yicy;"], [1112, "&jsercy;"], [1113, "&ljcy;"], [1114, "&njcy;"], [1115, "&tshcy;"], [1116, "&kjcy;"], [1118, "&ubrcy;"], [1119, "&dzcy;"], [8194, "&ensp;"], [8195, "&emsp;"], [8196, "&emsp13;"], [8197, "&emsp14;"], [8199, "&numsp;"], [8200, "&puncsp;"], [8201, "&ThinSpace;"], [8202, "&hairsp;"], [8203, "&NegativeMediumSpace;"], [8204, "&zwnj;"], [8205, "&zwj;"], [8206, "&lrm;"], [8207, "&rlm;"], [8208, "&dash;"], [8211, "&ndash;"], [8212, "&mdash;"], [8213, "&horbar;"], [8214, "&Verbar;"], [8216, "&lsquo;"], [8217, "&CloseCurlyQuote;"], [8218, "&lsquor;"], [8220, "&ldquo;"], [8221, "&CloseCurlyDoubleQuote;"], [8222, "&bdquo;"], [8224, "&dagger;"], [8225, "&Dagger;"], [8226, "&bull;"], [8229, "&nldr;"], [8230, "&hellip;"], [8240, "&permil;"], [8241, "&pertenk;"], [8242, "&prime;"], [8243, "&Prime;"], [8244, "&tprime;"], [8245, "&backprime;"], [8249, "&lsaquo;"], [8250, "&rsaquo;"], [8254, "&oline;"], [8257, "&caret;"], [8259, "&hybull;"], [8260, "&frasl;"], [8271, "&bsemi;"], [8279, "&qprime;"], [8287, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [8288, "&NoBreak;"], [8289, "&af;"], [8290, "&InvisibleTimes;"], [8291, "&ic;"], [8364, "&euro;"], [8411, "&tdot;"], [8412, "&DotDot;"], [8450, "&complexes;"], [8453, "&incare;"], [8458, "&gscr;"], [8459, "&hamilt;"], [8460, "&Hfr;"], [8461, "&Hopf;"], [8462, "&planckh;"], [8463, "&hbar;"], [8464, "&imagline;"], [8465, "&Ifr;"], [8466, "&lagran;"], [8467, "&ell;"], [8469, "&naturals;"], [8470, "&numero;"], [8471, "&copysr;"], [8472, "&weierp;"], [8473, "&Popf;"], [8474, "&Qopf;"], [8475, "&realine;"], [8476, "&real;"], [8477, "&reals;"], [8478, "&rx;"], [8482, "&trade;"], [8484, "&integers;"], [8487, "&mho;"], [8488, "&zeetrf;"], [8489, "&iiota;"], [8492, "&bernou;"], [8493, "&Cayleys;"], [8495, "&escr;"], [8496, "&Escr;"], [8497, "&Fouriertrf;"], [8499, "&Mellintrf;"], [8500, "&order;"], [8501, "&alefsym;"], [8502, "&beth;"], [8503, "&gimel;"], [8504, "&daleth;"], [8517, "&CapitalDifferentialD;"], [8518, "&dd;"], [8519, "&ee;"], [8520, "&ii;"], [8531, "&frac13;"], [8532, "&frac23;"], [8533, "&frac15;"], [8534, "&frac25;"], [8535, "&frac35;"], [8536, "&frac45;"], [8537, "&frac16;"], [8538, "&frac56;"], [8539, "&frac18;"], [8540, "&frac38;"], [8541, "&frac58;"], [8542, "&frac78;"], [8592, "&larr;"], [8593, "&ShortUpArrow;"], [8594, "&rarr;"], [8595, "&darr;"], [8596, "&harr;"], [8597, "&updownarrow;"], [8598, "&nwarr;"], [8599, "&nearr;"], [8600, "&LowerRightArrow;"], [8601, "&LowerLeftArrow;"], [8602, "&nlarr;"], [8603, "&nrarr;"], [8605, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [8606, "&Larr;"], [8607, "&Uarr;"], [8608, "&Rarr;"], [8609, "&Darr;"], [8610, "&larrtl;"], [8611, "&rarrtl;"], [8612, "&LeftTeeArrow;"], [8613, "&mapstoup;"], [8614, "&map;"], [8615, "&DownTeeArrow;"], [8617, "&hookleftarrow;"], [8618, "&hookrightarrow;"], [8619, "&larrlp;"], [8620, "&looparrowright;"], [8621, "&harrw;"], [8622, "&nharr;"], [8624, "&lsh;"], [8625, "&rsh;"], [8626, "&ldsh;"], [8627, "&rdsh;"], [8629, "&crarr;"], [8630, "&cularr;"], [8631, "&curarr;"], [8634, "&circlearrowleft;"], [8635, "&circlearrowright;"], [8636, "&leftharpoonup;"], [8637, "&DownLeftVector;"], [8638, "&RightUpVector;"], [8639, "&LeftUpVector;"], [8640, "&rharu;"], [8641, "&DownRightVector;"], [8642, "&dharr;"], [8643, "&dharl;"], [8644, "&RightArrowLeftArrow;"], [8645, "&udarr;"], [8646, "&LeftArrowRightArrow;"], [8647, "&leftleftarrows;"], [8648, "&upuparrows;"], [8649, "&rightrightarrows;"], [8650, "&ddarr;"], [8651, "&leftrightharpoons;"], [8652, "&Equilibrium;"], [8653, "&nlArr;"], [8654, "&nhArr;"], [8655, "&nrArr;"], [8656, "&DoubleLeftArrow;"], [8657, "&DoubleUpArrow;"], [8658, "&DoubleRightArrow;"], [8659, "&dArr;"], [8660, "&DoubleLeftRightArrow;"], [8661, "&DoubleUpDownArrow;"], [8662, "&nwArr;"], [8663, "&neArr;"], [8664, "&seArr;"], [8665, "&swArr;"], [8666, "&lAarr;"], [8667, "&rAarr;"], [8669, "&zigrarr;"], [8676, "&larrb;"], [8677, "&rarrb;"], [8693, "&DownArrowUpArrow;"], [8701, "&loarr;"], [8702, "&roarr;"], [8703, "&hoarr;"], [8704, "&forall;"], [8705, "&comp;"], [8706, { v: "&part;", n: 824, o: "&npart;" }], [8707, "&exist;"], [8708, "&nexist;"], [8709, "&empty;"], [8711, "&Del;"], [8712, "&Element;"], [8713, "&NotElement;"], [8715, "&ni;"], [8716, "&notni;"], [8719, "&prod;"], [8720, "&coprod;"], [8721, "&sum;"], [8722, "&minus;"], [8723, "&MinusPlus;"], [8724, "&dotplus;"], [8726, "&Backslash;"], [8727, "&lowast;"], [8728, "&compfn;"], [8730, "&radic;"], [8733, "&prop;"], [8734, "&infin;"], [8735, "&angrt;"], [8736, { v: "&ang;", n: 8402, o: "&nang;" }], [8737, "&angmsd;"], [8738, "&angsph;"], [8739, "&mid;"], [8740, "&nmid;"], [8741, "&DoubleVerticalBar;"], [8742, "&NotDoubleVerticalBar;"], [8743, "&and;"], [8744, "&or;"], [8745, { v: "&cap;", n: 65024, o: "&caps;" }], [8746, { v: "&cup;", n: 65024, o: "&cups;" }], [8747, "&int;"], [8748, "&Int;"], [8749, "&iiint;"], [8750, "&conint;"], [8751, "&Conint;"], [8752, "&Cconint;"], [8753, "&cwint;"], [8754, "&ClockwiseContourIntegral;"], [8755, "&awconint;"], [8756, "&there4;"], [8757, "&becaus;"], [8758, "&ratio;"], [8759, "&Colon;"], [8760, "&dotminus;"], [8762, "&mDDot;"], [8763, "&homtht;"], [8764, { v: "&sim;", n: 8402, o: "&nvsim;" }], [8765, { v: "&backsim;", n: 817, o: "&race;" }], [8766, { v: "&ac;", n: 819, o: "&acE;" }], [8767, "&acd;"], [8768, "&VerticalTilde;"], [8769, "&NotTilde;"], [8770, { v: "&eqsim;", n: 824, o: "&nesim;" }], [8771, "&sime;"], [8772, "&NotTildeEqual;"], [8773, "&cong;"], [8774, "&simne;"], [8775, "&ncong;"], [8776, "&ap;"], [8777, "&nap;"], [8778, "&ape;"], [8779, { v: "&apid;", n: 824, o: "&napid;" }], [8780, "&backcong;"], [8781, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [8782, { v: "&bump;", n: 824, o: "&nbump;" }], [8783, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [8784, { v: "&doteq;", n: 824, o: "&nedot;" }], [8785, "&doteqdot;"], [8786, "&efDot;"], [8787, "&erDot;"], [8788, "&Assign;"], [8789, "&ecolon;"], [8790, "&ecir;"], [8791, "&circeq;"], [8793, "&wedgeq;"], [8794, "&veeeq;"], [8796, "&triangleq;"], [8799, "&equest;"], [8800, "&ne;"], [8801, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [8802, "&nequiv;"], [8804, { v: "&le;", n: 8402, o: "&nvle;" }], [8805, { v: "&ge;", n: 8402, o: "&nvge;" }], [8806, { v: "&lE;", n: 824, o: "&nlE;" }], [8807, { v: "&gE;", n: 824, o: "&ngE;" }], [8808, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [8809, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [8810, { v: "&ll;", n: /* @__PURE__ */ new Map([[824, "&nLtv;"], [8402, "&nLt;"]]) }], [8811, { v: "&gg;", n: /* @__PURE__ */ new Map([[824, "&nGtv;"], [8402, "&nGt;"]]) }], [8812, "&between;"], [8813, "&NotCupCap;"], [8814, "&nless;"], [8815, "&ngt;"], [8816, "&nle;"], [8817, "&nge;"], [8818, "&lesssim;"], [8819, "&GreaterTilde;"], [8820, "&nlsim;"], [8821, "&ngsim;"], [8822, "&LessGreater;"], [8823, "&gl;"], [8824, "&NotLessGreater;"], [8825, "&NotGreaterLess;"], [8826, "&pr;"], [8827, "&sc;"], [8828, "&prcue;"], [8829, "&sccue;"], [8830, "&PrecedesTilde;"], [8831, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [8832, "&NotPrecedes;"], [8833, "&NotSucceeds;"], [8834, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [8835, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [8836, "&nsub;"], [8837, "&nsup;"], [8838, "&sube;"], [8839, "&supe;"], [8840, "&NotSubsetEqual;"], [8841, "&NotSupersetEqual;"], [8842, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [8843, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [8845, "&cupdot;"], [8846, "&UnionPlus;"], [8847, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [8848, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [8849, "&sqsube;"], [8850, "&sqsupe;"], [8851, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [8852, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [8853, "&CirclePlus;"], [8854, "&CircleMinus;"], [8855, "&CircleTimes;"], [8856, "&osol;"], [8857, "&CircleDot;"], [8858, "&circledcirc;"], [8859, "&circledast;"], [8861, "&circleddash;"], [8862, "&boxplus;"], [8863, "&boxminus;"], [8864, "&boxtimes;"], [8865, "&dotsquare;"], [8866, "&RightTee;"], [8867, "&dashv;"], [8868, "&DownTee;"], [8869, "&bot;"], [8871, "&models;"], [8872, "&DoubleRightTee;"], [8873, "&Vdash;"], [8874, "&Vvdash;"], [8875, "&VDash;"], [8876, "&nvdash;"], [8877, "&nvDash;"], [8878, "&nVdash;"], [8879, "&nVDash;"], [8880, "&prurel;"], [8882, "&LeftTriangle;"], [8883, "&RightTriangle;"], [8884, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [8885, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [8886, "&origof;"], [8887, "&imof;"], [8888, "&multimap;"], [8889, "&hercon;"], [8890, "&intcal;"], [8891, "&veebar;"], [8893, "&barvee;"], [8894, "&angrtvb;"], [8895, "&lrtri;"], [8896, "&bigwedge;"], [8897, "&bigvee;"], [8898, "&bigcap;"], [8899, "&bigcup;"], [8900, "&diam;"], [8901, "&sdot;"], [8902, "&sstarf;"], [8903, "&divideontimes;"], [8904, "&bowtie;"], [8905, "&ltimes;"], [8906, "&rtimes;"], [8907, "&leftthreetimes;"], [8908, "&rightthreetimes;"], [8909, "&backsimeq;"], [8910, "&curlyvee;"], [8911, "&curlywedge;"], [8912, "&Sub;"], [8913, "&Sup;"], [8914, "&Cap;"], [8915, "&Cup;"], [8916, "&fork;"], [8917, "&epar;"], [8918, "&lessdot;"], [8919, "&gtdot;"], [8920, { v: "&Ll;", n: 824, o: "&nLl;" }], [8921, { v: "&Gg;", n: 824, o: "&nGg;" }], [8922, { v: "&leg;", n: 65024, o: "&lesg;" }], [8923, { v: "&gel;", n: 65024, o: "&gesl;" }], [8926, "&cuepr;"], [8927, "&cuesc;"], [8928, "&NotPrecedesSlantEqual;"], [8929, "&NotSucceedsSlantEqual;"], [8930, "&NotSquareSubsetEqual;"], [8931, "&NotSquareSupersetEqual;"], [8934, "&lnsim;"], [8935, "&gnsim;"], [8936, "&precnsim;"], [8937, "&scnsim;"], [8938, "&nltri;"], [8939, "&NotRightTriangle;"], [8940, "&nltrie;"], [8941, "&NotRightTriangleEqual;"], [8942, "&vellip;"], [8943, "&ctdot;"], [8944, "&utdot;"], [8945, "&dtdot;"], [8946, "&disin;"], [8947, "&isinsv;"], [8948, "&isins;"], [8949, { v: "&isindot;", n: 824, o: "&notindot;" }], [8950, "&notinvc;"], [8951, "&notinvb;"], [8953, { v: "&isinE;", n: 824, o: "&notinE;" }], [8954, "&nisd;"], [8955, "&xnis;"], [8956, "&nis;"], [8957, "&notnivc;"], [8958, "&notnivb;"], [8965, "&barwed;"], [8966, "&Barwed;"], [8968, "&lceil;"], [8969, "&rceil;"], [8970, "&LeftFloor;"], [8971, "&rfloor;"], [8972, "&drcrop;"], [8973, "&dlcrop;"], [8974, "&urcrop;"], [8975, "&ulcrop;"], [8976, "&bnot;"], [8978, "&profline;"], [8979, "&profsurf;"], [8981, "&telrec;"], [8982, "&target;"], [8988, "&ulcorn;"], [8989, "&urcorn;"], [8990, "&dlcorn;"], [8991, "&drcorn;"], [8994, "&frown;"], [8995, "&smile;"], [9005, "&cylcty;"], [9006, "&profalar;"], [9014, "&topbot;"], [9021, "&ovbar;"], [9023, "&solbar;"], [9084, "&angzarr;"], [9136, "&lmoustache;"], [9137, "&rmoustache;"], [9140, "&OverBracket;"], [9141, "&bbrk;"], [9142, "&bbrktbrk;"], [9180, "&OverParenthesis;"], [9181, "&UnderParenthesis;"], [9182, "&OverBrace;"], [9183, "&UnderBrace;"], [9186, "&trpezium;"], [9191, "&elinters;"], [9251, "&blank;"], [9416, "&circledS;"], [9472, "&boxh;"], [9474, "&boxv;"], [9484, "&boxdr;"], [9488, "&boxdl;"], [9492, "&boxur;"], [9496, "&boxul;"], [9500, "&boxvr;"], [9508, "&boxvl;"], [9516, "&boxhd;"], [9524, "&boxhu;"], [9532, "&boxvh;"], [9552, "&boxH;"], [9553, "&boxV;"], [9554, "&boxdR;"], [9555, "&boxDr;"], [9556, "&boxDR;"], [9557, "&boxdL;"], [9558, "&boxDl;"], [9559, "&boxDL;"], [9560, "&boxuR;"], [9561, "&boxUr;"], [9562, "&boxUR;"], [9563, "&boxuL;"], [9564, "&boxUl;"], [9565, "&boxUL;"], [9566, "&boxvR;"], [9567, "&boxVr;"], [9568, "&boxVR;"], [9569, "&boxvL;"], [9570, "&boxVl;"], [9571, "&boxVL;"], [9572, "&boxHd;"], [9573, "&boxhD;"], [9574, "&boxHD;"], [9575, "&boxHu;"], [9576, "&boxhU;"], [9577, "&boxHU;"], [9578, "&boxvH;"], [9579, "&boxVh;"], [9580, "&boxVH;"], [9600, "&uhblk;"], [9604, "&lhblk;"], [9608, "&block;"], [9617, "&blk14;"], [9618, "&blk12;"], [9619, "&blk34;"], [9633, "&square;"], [9642, "&blacksquare;"], [9643, "&EmptyVerySmallSquare;"], [9645, "&rect;"], [9646, "&marker;"], [9649, "&fltns;"], [9651, "&bigtriangleup;"], [9652, "&blacktriangle;"], [9653, "&triangle;"], [9656, "&blacktriangleright;"], [9657, "&rtri;"], [9661, "&bigtriangledown;"], [9662, "&blacktriangledown;"], [9663, "&dtri;"], [9666, "&blacktriangleleft;"], [9667, "&ltri;"], [9674, "&loz;"], [9675, "&cir;"], [9708, "&tridot;"], [9711, "&bigcirc;"], [9720, "&ultri;"], [9721, "&urtri;"], [9722, "&lltri;"], [9723, "&EmptySmallSquare;"], [9724, "&FilledSmallSquare;"], [9733, "&bigstar;"], [9734, "&star;"], [9742, "&phone;"], [9792, "&female;"], [9794, "&male;"], [9824, "&spades;"], [9827, "&clubs;"], [9829, "&hearts;"], [9830, "&diamondsuit;"], [9834, "&sung;"], [9837, "&flat;"], [9838, "&natural;"], [9839, "&sharp;"], [10003, "&check;"], [10007, "&cross;"], [10016, "&malt;"], [10038, "&sext;"], [10072, "&VerticalSeparator;"], [10098, "&lbbrk;"], [10099, "&rbbrk;"], [10184, "&bsolhsub;"], [10185, "&suphsol;"], [10214, "&LeftDoubleBracket;"], [10215, "&RightDoubleBracket;"], [10216, "&lang;"], [10217, "&rang;"], [10218, "&Lang;"], [10219, "&Rang;"], [10220, "&loang;"], [10221, "&roang;"], [10229, "&longleftarrow;"], [10230, "&longrightarrow;"], [10231, "&longleftrightarrow;"], [10232, "&DoubleLongLeftArrow;"], [10233, "&DoubleLongRightArrow;"], [10234, "&DoubleLongLeftRightArrow;"], [10236, "&longmapsto;"], [10239, "&dzigrarr;"], [10498, "&nvlArr;"], [10499, "&nvrArr;"], [10500, "&nvHarr;"], [10501, "&Map;"], [10508, "&lbarr;"], [10509, "&bkarow;"], [10510, "&lBarr;"], [10511, "&dbkarow;"], [10512, "&drbkarow;"], [10513, "&DDotrahd;"], [10514, "&UpArrowBar;"], [10515, "&DownArrowBar;"], [10518, "&Rarrtl;"], [10521, "&latail;"], [10522, "&ratail;"], [10523, "&lAtail;"], [10524, "&rAtail;"], [10525, "&larrfs;"], [10526, "&rarrfs;"], [10527, "&larrbfs;"], [10528, "&rarrbfs;"], [10531, "&nwarhk;"], [10532, "&nearhk;"], [10533, "&hksearow;"], [10534, "&hkswarow;"], [10535, "&nwnear;"], [10536, "&nesear;"], [10537, "&seswar;"], [10538, "&swnwar;"], [10547, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [10549, "&cudarrr;"], [10550, "&ldca;"], [10551, "&rdca;"], [10552, "&cudarrl;"], [10553, "&larrpl;"], [10556, "&curarrm;"], [10557, "&cularrp;"], [10565, "&rarrpl;"], [10568, "&harrcir;"], [10569, "&Uarrocir;"], [10570, "&lurdshar;"], [10571, "&ldrushar;"], [10574, "&LeftRightVector;"], [10575, "&RightUpDownVector;"], [10576, "&DownLeftRightVector;"], [10577, "&LeftUpDownVector;"], [10578, "&LeftVectorBar;"], [10579, "&RightVectorBar;"], [10580, "&RightUpVectorBar;"], [10581, "&RightDownVectorBar;"], [10582, "&DownLeftVectorBar;"], [10583, "&DownRightVectorBar;"], [10584, "&LeftUpVectorBar;"], [10585, "&LeftDownVectorBar;"], [10586, "&LeftTeeVector;"], [10587, "&RightTeeVector;"], [10588, "&RightUpTeeVector;"], [10589, "&RightDownTeeVector;"], [10590, "&DownLeftTeeVector;"], [10591, "&DownRightTeeVector;"], [10592, "&LeftUpTeeVector;"], [10593, "&LeftDownTeeVector;"], [10594, "&lHar;"], [10595, "&uHar;"], [10596, "&rHar;"], [10597, "&dHar;"], [10598, "&luruhar;"], [10599, "&ldrdhar;"], [10600, "&ruluhar;"], [10601, "&rdldhar;"], [10602, "&lharul;"], [10603, "&llhard;"], [10604, "&rharul;"], [10605, "&lrhard;"], [10606, "&udhar;"], [10607, "&duhar;"], [10608, "&RoundImplies;"], [10609, "&erarr;"], [10610, "&simrarr;"], [10611, "&larrsim;"], [10612, "&rarrsim;"], [10613, "&rarrap;"], [10614, "&ltlarr;"], [10616, "&gtrarr;"], [10617, "&subrarr;"], [10619, "&suplarr;"], [10620, "&lfisht;"], [10621, "&rfisht;"], [10622, "&ufisht;"], [10623, "&dfisht;"], [10629, "&lopar;"], [10630, "&ropar;"], [10635, "&lbrke;"], [10636, "&rbrke;"], [10637, "&lbrkslu;"], [10638, "&rbrksld;"], [10639, "&lbrksld;"], [10640, "&rbrkslu;"], [10641, "&langd;"], [10642, "&rangd;"], [10643, "&lparlt;"], [10644, "&rpargt;"], [10645, "&gtlPar;"], [10646, "&ltrPar;"], [10650, "&vzigzag;"], [10652, "&vangrt;"], [10653, "&angrtvbd;"], [10660, "&ange;"], [10661, "&range;"], [10662, "&dwangle;"], [10663, "&uwangle;"], [10664, "&angmsdaa;"], [10665, "&angmsdab;"], [10666, "&angmsdac;"], [10667, "&angmsdad;"], [10668, "&angmsdae;"], [10669, "&angmsdaf;"], [10670, "&angmsdag;"], [10671, "&angmsdah;"], [10672, "&bemptyv;"], [10673, "&demptyv;"], [10674, "&cemptyv;"], [10675, "&raemptyv;"], [10676, "&laemptyv;"], [10677, "&ohbar;"], [10678, "&omid;"], [10679, "&opar;"], [10681, "&operp;"], [10683, "&olcross;"], [10684, "&odsold;"], [10686, "&olcir;"], [10687, "&ofcir;"], [10688, "&olt;"], [10689, "&ogt;"], [10690, "&cirscir;"], [10691, "&cirE;"], [10692, "&solb;"], [10693, "&bsolb;"], [10697, "&boxbox;"], [10701, "&trisb;"], [10702, "&rtriltri;"], [10703, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [10704, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [10716, "&iinfin;"], [10717, "&infintie;"], [10718, "&nvinfin;"], [10723, "&eparsl;"], [10724, "&smeparsl;"], [10725, "&eqvparsl;"], [10731, "&blacklozenge;"], [10740, "&RuleDelayed;"], [10742, "&dsol;"], [10752, "&bigodot;"], [10753, "&bigoplus;"], [10754, "&bigotimes;"], [10756, "&biguplus;"], [10758, "&bigsqcup;"], [10764, "&iiiint;"], [10765, "&fpartint;"], [10768, "&cirfnint;"], [10769, "&awint;"], [10770, "&rppolint;"], [10771, "&scpolint;"], [10772, "&npolint;"], [10773, "&pointint;"], [10774, "&quatint;"], [10775, "&intlarhk;"], [10786, "&pluscir;"], [10787, "&plusacir;"], [10788, "&simplus;"], [10789, "&plusdu;"], [10790, "&plussim;"], [10791, "&plustwo;"], [10793, "&mcomma;"], [10794, "&minusdu;"], [10797, "&loplus;"], [10798, "&roplus;"], [10799, "&Cross;"], [10800, "&timesd;"], [10801, "&timesbar;"], [10803, "&smashp;"], [10804, "&lotimes;"], [10805, "&rotimes;"], [10806, "&otimesas;"], [10807, "&Otimes;"], [10808, "&odiv;"], [10809, "&triplus;"], [10810, "&triminus;"], [10811, "&tritime;"], [10812, "&intprod;"], [10815, "&amalg;"], [10816, "&capdot;"], [10818, "&ncup;"], [10819, "&ncap;"], [10820, "&capand;"], [10821, "&cupor;"], [10822, "&cupcap;"], [10823, "&capcup;"], [10824, "&cupbrcap;"], [10825, "&capbrcup;"], [10826, "&cupcup;"], [10827, "&capcap;"], [10828, "&ccups;"], [10829, "&ccaps;"], [10832, "&ccupssm;"], [10835, "&And;"], [10836, "&Or;"], [10837, "&andand;"], [10838, "&oror;"], [10839, "&orslope;"], [10840, "&andslope;"], [10842, "&andv;"], [10843, "&orv;"], [10844, "&andd;"], [10845, "&ord;"], [10847, "&wedbar;"], [10854, "&sdote;"], [10858, "&simdot;"], [10861, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [10862, "&easter;"], [10863, "&apacir;"], [10864, { v: "&apE;", n: 824, o: "&napE;" }], [10865, "&eplus;"], [10866, "&pluse;"], [10867, "&Esim;"], [10868, "&Colone;"], [10869, "&Equal;"], [10871, "&ddotseq;"], [10872, "&equivDD;"], [10873, "&ltcir;"], [10874, "&gtcir;"], [10875, "&ltquest;"], [10876, "&gtquest;"], [10877, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [10878, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [10879, "&lesdot;"], [10880, "&gesdot;"], [10881, "&lesdoto;"], [10882, "&gesdoto;"], [10883, "&lesdotor;"], [10884, "&gesdotol;"], [10885, "&lap;"], [10886, "&gap;"], [10887, "&lne;"], [10888, "&gne;"], [10889, "&lnap;"], [10890, "&gnap;"], [10891, "&lEg;"], [10892, "&gEl;"], [10893, "&lsime;"], [10894, "&gsime;"], [10895, "&lsimg;"], [10896, "&gsiml;"], [10897, "&lgE;"], [10898, "&glE;"], [10899, "&lesges;"], [10900, "&gesles;"], [10901, "&els;"], [10902, "&egs;"], [10903, "&elsdot;"], [10904, "&egsdot;"], [10905, "&el;"], [10906, "&eg;"], [10909, "&siml;"], [10910, "&simg;"], [10911, "&simlE;"], [10912, "&simgE;"], [10913, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [10914, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [10916, "&glj;"], [10917, "&gla;"], [10918, "&ltcc;"], [10919, "&gtcc;"], [10920, "&lescc;"], [10921, "&gescc;"], [10922, "&smt;"], [10923, "&lat;"], [10924, { v: "&smte;", n: 65024, o: "&smtes;" }], [10925, { v: "&late;", n: 65024, o: "&lates;" }], [10926, "&bumpE;"], [10927, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [10928, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [10931, "&prE;"], [10932, "&scE;"], [10933, "&precneqq;"], [10934, "&scnE;"], [10935, "&prap;"], [10936, "&scap;"], [10937, "&precnapprox;"], [10938, "&scnap;"], [10939, "&Pr;"], [10940, "&Sc;"], [10941, "&subdot;"], [10942, "&supdot;"], [10943, "&subplus;"], [10944, "&supplus;"], [10945, "&submult;"], [10946, "&supmult;"], [10947, "&subedot;"], [10948, "&supedot;"], [10949, { v: "&subE;", n: 824, o: "&nsubE;" }], [10950, { v: "&supE;", n: 824, o: "&nsupE;" }], [10951, "&subsim;"], [10952, "&supsim;"], [10955, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [10956, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [10959, "&csub;"], [10960, "&csup;"], [10961, "&csube;"], [10962, "&csupe;"], [10963, "&subsup;"], [10964, "&supsub;"], [10965, "&subsub;"], [10966, "&supsup;"], [10967, "&suphsub;"], [10968, "&supdsub;"], [10969, "&forkv;"], [10970, "&topfork;"], [10971, "&mlcp;"], [10980, "&Dashv;"], [10982, "&Vdashl;"], [10983, "&Barv;"], [10984, "&vBar;"], [10985, "&vBarv;"], [10987, "&Vbar;"], [10988, "&Not;"], [10989, "&bNot;"], [10990, "&rnmid;"], [10991, "&cirmid;"], [10992, "&midcir;"], [10993, "&topcir;"], [10994, "&nhpar;"], [10995, "&parsim;"], [11005, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [55349, { n: /* @__PURE__ */ new Map([[56476, "&Ascr;"], [56478, "&Cscr;"], [56479, "&Dscr;"], [56482, "&Gscr;"], [56485, "&Jscr;"], [56486, "&Kscr;"], [56489, "&Nscr;"], [56490, "&Oscr;"], [56491, "&Pscr;"], [56492, "&Qscr;"], [56494, "&Sscr;"], [56495, "&Tscr;"], [56496, "&Uscr;"], [56497, "&Vscr;"], [56498, "&Wscr;"], [56499, "&Xscr;"], [56500, "&Yscr;"], [56501, "&Zscr;"], [56502, "&ascr;"], [56503, "&bscr;"], [56504, "&cscr;"], [56505, "&dscr;"], [56507, "&fscr;"], [56509, "&hscr;"], [56510, "&iscr;"], [56511, "&jscr;"], [56512, "&kscr;"], [56513, "&lscr;"], [56514, "&mscr;"], [56515, "&nscr;"], [56517, "&pscr;"], [56518, "&qscr;"], [56519, "&rscr;"], [56520, "&sscr;"], [56521, "&tscr;"], [56522, "&uscr;"], [56523, "&vscr;"], [56524, "&wscr;"], [56525, "&xscr;"], [56526, "&yscr;"], [56527, "&zscr;"], [56580, "&Afr;"], [56581, "&Bfr;"], [56583, "&Dfr;"], [56584, "&Efr;"], [56585, "&Ffr;"], [56586, "&Gfr;"], [56589, "&Jfr;"], [56590, "&Kfr;"], [56591, "&Lfr;"], [56592, "&Mfr;"], [56593, "&Nfr;"], [56594, "&Ofr;"], [56595, "&Pfr;"], [56596, "&Qfr;"], [56598, "&Sfr;"], [56599, "&Tfr;"], [56600, "&Ufr;"], [56601, "&Vfr;"], [56602, "&Wfr;"], [56603, "&Xfr;"], [56604, "&Yfr;"], [56606, "&afr;"], [56607, "&bfr;"], [56608, "&cfr;"], [56609, "&dfr;"], [56610, "&efr;"], [56611, "&ffr;"], [56612, "&gfr;"], [56613, "&hfr;"], [56614, "&ifr;"], [56615, "&jfr;"], [56616, "&kfr;"], [56617, "&lfr;"], [56618, "&mfr;"], [56619, "&nfr;"], [56620, "&ofr;"], [56621, "&pfr;"], [56622, "&qfr;"], [56623, "&rfr;"], [56624, "&sfr;"], [56625, "&tfr;"], [56626, "&ufr;"], [56627, "&vfr;"], [56628, "&wfr;"], [56629, "&xfr;"], [56630, "&yfr;"], [56631, "&zfr;"], [56632, "&Aopf;"], [56633, "&Bopf;"], [56635, "&Dopf;"], [56636, "&Eopf;"], [56637, "&Fopf;"], [56638, "&Gopf;"], [56640, "&Iopf;"], [56641, "&Jopf;"], [56642, "&Kopf;"], [56643, "&Lopf;"], [56644, "&Mopf;"], [56646, "&Oopf;"], [56650, "&Sopf;"], [56651, "&Topf;"], [56652, "&Uopf;"], [56653, "&Vopf;"], [56654, "&Wopf;"], [56655, "&Xopf;"], [56656, "&Yopf;"], [56658, "&aopf;"], [56659, "&bopf;"], [56660, "&copf;"], [56661, "&dopf;"], [56662, "&eopf;"], [56663, "&fopf;"], [56664, "&gopf;"], [56665, "&hopf;"], [56666, "&iopf;"], [56667, "&jopf;"], [56668, "&kopf;"], [56669, "&lopf;"], [56670, "&mopf;"], [56671, "&nopf;"], [56672, "&oopf;"], [56673, "&popf;"], [56674, "&qopf;"], [56675, "&ropf;"], [56676, "&sopf;"], [56677, "&topf;"], [56678, "&uopf;"], [56679, "&vopf;"], [56680, "&wopf;"], [56681, "&xopf;"], [56682, "&yopf;"], [56683, "&zopf;"]]) }], [64256, "&fflig;"], [64257, "&filig;"], [64258, "&fllig;"], [64259, "&ffilig;"], [64260, "&ffllig;"]]);
  }
});

// node_modules/entities/lib/escape.js
var require_escape = __commonJS({
  "node_modules/entities/lib/escape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
    exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var xmlCodeMap = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    exports.getCodePoint = String.prototype.codePointAt != null ? function(str, index) {
      return str.codePointAt(index);
    } : function(c, index) {
      return (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
    };
    function encodeXML(str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = exports.xmlReplacer.exec(str)) !== null) {
        var i = match.index;
        var char = str.charCodeAt(i);
        var next = xmlCodeMap.get(char);
        if (next !== void 0) {
          ret += str.substring(lastIdx, i) + next;
          lastIdx = i + 1;
        } else {
          ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
          lastIdx = exports.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
        }
      }
      return ret + str.substr(lastIdx);
    }
    exports.encodeXML = encodeXML;
    exports.escape = encodeXML;
    function getEscaper(regex, map) {
      return function escape(data) {
        var match;
        var lastIdx = 0;
        var result = "";
        while (match = regex.exec(data)) {
          if (lastIdx !== match.index) {
            result += data.substring(lastIdx, match.index);
          }
          result += map.get(match[0].charCodeAt(0));
          lastIdx = match.index + 1;
        }
        return result + data.substring(lastIdx);
      };
    }
    exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
    exports.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ]));
    exports.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  }
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeNonAsciiHTML = exports.encodeHTML = void 0;
    var encode_html_js_1 = __importDefault(require_encode_html());
    var escape_js_1 = require_escape();
    var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function encodeHTML(data) {
      return encodeHTMLTrieRe(htmlReplacer, data);
    }
    exports.encodeHTML = encodeHTML;
    function encodeNonAsciiHTML(data) {
      return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
    }
    exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
    function encodeHTMLTrieRe(regExp, str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = regExp.exec(str)) !== null) {
        var i = match.index;
        ret += str.substring(lastIdx, i);
        var char = str.charCodeAt(i);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
          if (i + 1 < str.length) {
            var nextChar = str.charCodeAt(i + 1);
            var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
            if (value !== void 0) {
              ret += value;
              lastIdx = regExp.lastIndex += 1;
              continue;
            }
          }
          next = next.v;
        }
        if (next !== void 0) {
          ret += next;
          lastIdx = i + 1;
        } else {
          var cp = (0, escape_js_1.getCodePoint)(str, i);
          ret += "&#x".concat(cp.toString(16), ";");
          lastIdx = regExp.lastIndex += Number(cp !== char);
        }
      }
      return ret + str.substr(lastIdx);
    }
  }
});

// node_modules/entities/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.DecodingMode = exports.EntityLevel = void 0;
    var decode_js_1 = require_decode();
    var encode_js_1 = require_encode();
    var escape_js_1 = require_escape();
    var EntityLevel;
    (function(EntityLevel2) {
      EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
      EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
    })(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
    var DecodingMode;
    (function(DecodingMode2) {
      DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
      DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
    var EncodingMode;
    (function(EncodingMode2) {
      EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
      EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
      EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
      EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
      EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
    })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
    function decode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      if (opts.level === EntityLevel.HTML) {
        if (opts.mode === DecodingMode.Strict) {
          return (0, decode_js_1.decodeHTMLStrict)(data);
        }
        return (0, decode_js_1.decodeHTML)(data);
      }
      return (0, decode_js_1.decodeXML)(data);
    }
    exports.decode = decode;
    function decodeStrict(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      if (opts.level === EntityLevel.HTML) {
        if (opts.mode === DecodingMode.Legacy) {
          return (0, decode_js_1.decodeHTML)(data);
        }
        return (0, decode_js_1.decodeHTMLStrict)(data);
      }
      return (0, decode_js_1.decodeXML)(data);
    }
    exports.decodeStrict = decodeStrict;
    function encode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      if (opts.mode === EncodingMode.UTF8)
        return (0, escape_js_1.escapeUTF8)(data);
      if (opts.mode === EncodingMode.Attribute)
        return (0, escape_js_1.escapeAttribute)(data);
      if (opts.mode === EncodingMode.Text)
        return (0, escape_js_1.escapeText)(data);
      if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
          return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
      }
      return (0, escape_js_1.encodeXML)(data);
    }
    exports.encode = encode;
    var escape_js_2 = require_escape();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
      return escape_js_2.encodeXML;
    } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
      return escape_js_2.escapeUTF8;
    } });
    Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function() {
      return escape_js_2.escapeAttribute;
    } });
    Object.defineProperty(exports, "escapeText", { enumerable: true, get: function() {
      return escape_js_2.escapeText;
    } });
    var encode_js_2 = require_encode();
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    var decode_js_2 = require_decode();
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
  }
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "node_modules/dom-serializer/lib/foreignNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeNames = exports.elementNames = void 0;
    exports.elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
    exports.attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
  }
});

// node_modules/dom-serializer/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/dom-serializer/lib/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.render = void 0;
    var ElementType = __importStar(require_lib());
    var entities_1 = require_lib3();
    var foreignNames_js_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function replaceQuotes(value) {
      return value.replace(/"/g, "&quot;");
    }
    function formatAttributes(attributes, opts) {
      var _a;
      if (!attributes)
        return;
      var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
      return Object.keys(attributes).map(function(key) {
        var _a2, _b;
        var value = (_a2 = attributes[key]) !== null && _a2 !== void 0 ? _a2 : "";
        if (opts.xmlMode === "foreign") {
          key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key;
        }
        return "".concat(key, '="').concat(encode(value), '"');
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
      }
      return output;
    }
    exports.render = render;
    exports.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType.Root:
          return render(node.children, options);
        case ElementType.Doctype:
        case ElementType.Directive:
          return renderDirective(node);
        case ElementType.Comment:
          return renderComment(node);
        case ElementType.CDATA:
          return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
          return renderTag(node, options);
        case ElementType.Text:
          return renderText(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<".concat(elem.name);
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " ".concat(attribs);
      }
      if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</".concat(elem.name, ">");
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<".concat(elem.data, ">");
    }
    function renderText(elem, opts) {
      var _a;
      var data = elem.data || "";
      if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[".concat(elem.children[0].data, "]]>");
    }
    function renderComment(elem) {
      return "<!--".concat(elem.data, "-->");
    }
  }
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/domutils/lib/stringify.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
    var domhandler_1 = require_lib2();
    var dom_serializer_1 = __importDefault(require_lib4());
    var domelementtype_1 = require_lib();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    exports.getOuterHTML = getOuterHTML;
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options);
      }).join("") : "";
    }
    exports.getInnerHTML = getInnerHTML;
    function getText(node) {
      if (Array.isArray(node))
        return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.getText = getText;
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.textContent = textContent;
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.innerText = innerText;
  }
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "node_modules/domutils/lib/traversal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
    var domhandler_1 = require_lib2();
    function getChildren(elem) {
      return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
    }
    exports.getChildren = getChildren;
    function getParent(elem) {
      return elem.parent || null;
    }
    exports.getParent = getParent;
    function getSiblings(elem) {
      var _a, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    exports.getSiblings = getSiblings;
    function getAttributeValue(elem, name) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    exports.getAttributeValue = getAttributeValue;
    function hasAttrib(elem, name) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
    }
    exports.hasAttrib = hasAttrib;
    function getName(elem) {
      return elem.name;
    }
    exports.getName = getName;
    function nextElementSibling(elem) {
      var _a;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a = next, next = _a.next;
      return next;
    }
    exports.nextElementSibling = nextElementSibling;
    function prevElementSibling(elem) {
      var _a;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a = prev, prev = _a.prev;
      return prev;
    }
    exports.prevElementSibling = prevElementSibling;
  }
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "node_modules/domutils/lib/manipulation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
      }
    }
    exports.removeElement = removeElement;
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
      }
    }
    exports.replaceElement = replaceElement;
    function appendChild(elem, child) {
      removeElement(child);
      child.next = null;
      child.parent = elem;
      if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    exports.appendChild = appendChild;
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    exports.append = append;
    function prependChild(elem, child) {
      removeElement(child);
      child.parent = elem;
      child.prev = null;
      if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    exports.prependChild = prependChild;
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
    exports.prepend = prepend;
  }
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "node_modules/domutils/lib/querying.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
    var domhandler_1 = require_lib2();
    function filter(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      if (!Array.isArray(node))
        node = [node];
      return find(test, node, recurse, limit);
    }
    exports.filter = filter;
    function find(test, nodes, recurse, limit) {
      var result = [];
      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
          result.push(elem);
          if (--limit <= 0)
            break;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          var children = find(test, elem.children, recurse, limit);
          result.push.apply(result, children);
          limit -= children.length;
          if (limit <= 0)
            break;
        }
      }
      return result;
    }
    exports.find = find;
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    exports.findOneChild = findOneChild;
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var elem = null;
      for (var i = 0; i < nodes.length && !elem; i++) {
        var checked = nodes[i];
        if (!(0, domhandler_1.isTag)(checked)) {
          continue;
        } else if (test(checked)) {
          elem = checked;
        } else if (recurse && checked.children.length > 0) {
          elem = findOne(test, checked.children, true);
        }
      }
      return elem;
    }
    exports.findOne = findOne;
    function existsOne(test, nodes) {
      return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));
      });
    }
    exports.existsOne = existsOne;
    function findAll(test, nodes) {
      var _a;
      var result = [];
      var stack = nodes.filter(domhandler_1.isTag);
      var elem;
      while (elem = stack.shift()) {
        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
        if (children && children.length > 0) {
          stack.unshift.apply(stack, children);
        }
        if (test(elem))
          result.push(elem);
      }
      return result;
    }
    exports.findAll = findAll;
  }
});

// node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS({
  "node_modules/domutils/lib/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
    var domhandler_1 = require_lib2();
    var querying_js_1 = require_querying();
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
      },
      tag_type: function(type) {
        if (typeof type === "function") {
          return function(elem) {
            return type(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a, b) {
      return function(elem) {
        return a(elem) || b(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    exports.testElement = testElement;
    function getElements(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
    }
    exports.getElements = getElements;
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports.getElementById = getElementById;
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
    }
    exports.getElementsByTagName = getElementsByTagName;
    function getElementsByTagType(type, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
    }
    exports.getElementsByTagType = getElementsByTagType;
  }
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/domutils/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;
    var domhandler_1 = require_lib2();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    exports.removeSubsets = removeSubsets;
    var DocumentPosition;
    (function(DocumentPosition2) {
      DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
      DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
      DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
      DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
      DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
    })(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
      }
      if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
      }
      return DocumentPosition.PRECEDING;
    }
    exports.compareDocumentPosition = compareDocumentPosition;
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i, arr) {
        return !arr.includes(node, i + 1);
      });
      nodes.sort(function(a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & DocumentPosition.PRECEDING) {
          return -1;
        } else if (relative & DocumentPosition.FOLLOWING) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
    exports.uniqueSort = uniqueSort;
  }
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "node_modules/domutils/lib/feeds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeed = void 0;
    var stringify_js_1 = require_stringify();
    var legacy_js_1 = require_legacy();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    exports.getFeed = getFeed;
    function getAtomFeed(feedRoot) {
      var _a;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a2;
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "id", children);
          addConditionally(entry, "title", "title", children);
          var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
          if (href2) {
            entry.link = href2;
          }
          var description = fetch("summary", children) || fetch("content", children);
          if (description) {
            entry.description = description;
          }
          var pubDate = fetch("updated", children);
          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }
          return entry;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a, _b;
      var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate = fetch("pubDate", children);
          if (pubDate)
            entry.pubDate = new Date(pubDate);
          return entry;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where) {
      return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs["medium"],
          isDefault: !!attribs["isDefault"]
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
          var attrib = MEDIA_KEYS_INT_1[_a];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs["expression"]) {
          media.expression = attribs["expression"];
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch(tagName, where, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// node_modules/domutils/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/domutils/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
    __exportStar(require_stringify(), exports);
    __exportStar(require_traversal(), exports);
    __exportStar(require_manipulation(), exports);
    __exportStar(require_querying(), exports);
    __exportStar(require_legacy(), exports);
    __exportStar(require_helpers(), exports);
    __exportStar(require_feeds(), exports);
    var domhandler_1 = require_lib2();
    Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// node_modules/htmlparser2/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/htmlparser2/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultHandler = exports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DomHandler = exports.Parser = void 0;
    var Parser_js_1 = require_Parser();
    Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
      return Parser_js_1.Parser;
    } });
    var domhandler_1 = require_lib2();
    Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function() {
      return domhandler_1.DomHandler;
    } });
    Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function() {
      return domhandler_1.DomHandler;
    } });
    function parseDocument(data, options) {
      var handler = new domhandler_1.DomHandler(void 0, options);
      new Parser_js_1.Parser(handler, options).end(data);
      return handler.root;
    }
    exports.parseDocument = parseDocument;
    function parseDOM(data, options) {
      return parseDocument(data, options).children;
    }
    exports.parseDOM = parseDOM;
    function createDomStream(cb, options, elementCb) {
      var handler = new domhandler_1.DomHandler(cb, options, elementCb);
      return new Parser_js_1.Parser(handler, options);
    }
    exports.createDomStream = createDomStream;
    var Tokenizer_js_1 = require_Tokenizer();
    Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function() {
      return __importDefault(Tokenizer_js_1).default;
    } });
    var ElementType = __importStar(require_lib());
    exports.ElementType = ElementType;
    var domutils_1 = require_lib5();
    Object.defineProperty(exports, "getFeed", { enumerable: true, get: function() {
      return domutils_1.getFeed;
    } });
    function parseFeed(feed, options) {
      if (options === void 0) {
        options = { xmlMode: true };
      }
      return (0, domutils_1.getFeed)(parseDOM(feed, options));
    }
    exports.parseFeed = parseFeed;
    exports.DomUtils = __importStar(require_lib5());
  }
});

// node_modules/linkedom/cjs/shared/constants.js
var require_constants = __commonJS({
  "node_modules/linkedom/cjs/shared/constants.js"(exports) {
    "use strict";
    var NODE_END = -1;
    exports.NODE_END = NODE_END;
    var ELEMENT_NODE = 1;
    exports.ELEMENT_NODE = ELEMENT_NODE;
    var ATTRIBUTE_NODE = 2;
    exports.ATTRIBUTE_NODE = ATTRIBUTE_NODE;
    var TEXT_NODE = 3;
    exports.TEXT_NODE = TEXT_NODE;
    var COMMENT_NODE = 8;
    exports.COMMENT_NODE = COMMENT_NODE;
    var DOCUMENT_NODE = 9;
    exports.DOCUMENT_NODE = DOCUMENT_NODE;
    var DOCUMENT_TYPE_NODE = 10;
    exports.DOCUMENT_TYPE_NODE = DOCUMENT_TYPE_NODE;
    var DOCUMENT_FRAGMENT_NODE = 11;
    exports.DOCUMENT_FRAGMENT_NODE = DOCUMENT_FRAGMENT_NODE;
    var BLOCK_ELEMENTS = /* @__PURE__ */ new Set(["ARTICLE", "ASIDE", "BLOCKQUOTE", "BODY", "BR", "BUTTON", "CANVAS", "CAPTION", "COL", "COLGROUP", "DD", "DIV", "DL", "DT", "EMBED", "FIELDSET", "FIGCAPTION", "FIGURE", "FOOTER", "FORM", "H1", "H2", "H3", "H4", "H5", "H6", "LI", "UL", "OL", "P"]);
    exports.BLOCK_ELEMENTS = BLOCK_ELEMENTS;
    var SHOW_ALL = -1;
    exports.SHOW_ALL = SHOW_ALL;
    var SHOW_ELEMENT = 1;
    exports.SHOW_ELEMENT = SHOW_ELEMENT;
    var SHOW_TEXT = 4;
    exports.SHOW_TEXT = SHOW_TEXT;
    var SHOW_COMMENT = 128;
    exports.SHOW_COMMENT = SHOW_COMMENT;
    var DOCUMENT_POSITION_DISCONNECTED = 1;
    exports.DOCUMENT_POSITION_DISCONNECTED = DOCUMENT_POSITION_DISCONNECTED;
    var DOCUMENT_POSITION_PRECEDING = 2;
    exports.DOCUMENT_POSITION_PRECEDING = DOCUMENT_POSITION_PRECEDING;
    var DOCUMENT_POSITION_FOLLOWING = 4;
    exports.DOCUMENT_POSITION_FOLLOWING = DOCUMENT_POSITION_FOLLOWING;
    var DOCUMENT_POSITION_CONTAINS = 8;
    exports.DOCUMENT_POSITION_CONTAINS = DOCUMENT_POSITION_CONTAINS;
    var DOCUMENT_POSITION_CONTAINED_BY = 16;
    exports.DOCUMENT_POSITION_CONTAINED_BY = DOCUMENT_POSITION_CONTAINED_BY;
    var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
    exports.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
    var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    exports.SVG_NAMESPACE = SVG_NAMESPACE;
  }
});

// node_modules/linkedom/cjs/shared/object.js
var require_object = __commonJS({
  "node_modules/linkedom/cjs/shared/object.js"(exports) {
    "use strict";
    var {
      assign,
      create,
      defineProperties,
      entries,
      getOwnPropertyDescriptors,
      keys,
      setPrototypeOf
    } = Object;
    exports.assign = assign;
    exports.create = create;
    exports.defineProperties = defineProperties;
    exports.entries = entries;
    exports.getOwnPropertyDescriptors = getOwnPropertyDescriptors;
    exports.keys = keys;
    exports.setPrototypeOf = setPrototypeOf;
  }
});

// node_modules/linkedom/cjs/shared/utils.js
var require_utils = __commonJS({
  "node_modules/linkedom/cjs/shared/utils.js"(exports) {
    "use strict";
    var { ELEMENT_NODE } = require_constants();
    var { END, MIME, NEXT, PREV } = require_symbols();
    var $String = String;
    exports.String = $String;
    var getEnd = (node) => node.nodeType === ELEMENT_NODE ? node[END] : node;
    exports.getEnd = getEnd;
    var ignoreCase = ({ ownerDocument }) => ownerDocument[MIME].ignoreCase;
    exports.ignoreCase = ignoreCase;
    var knownAdjacent = (prev, next) => {
      prev[NEXT] = next;
      next[PREV] = prev;
    };
    exports.knownAdjacent = knownAdjacent;
    var knownBoundaries = (prev, current, next) => {
      knownAdjacent(prev, current);
      knownAdjacent(getEnd(current), next);
    };
    exports.knownBoundaries = knownBoundaries;
    var knownSegment = (prev, start, end, next) => {
      knownAdjacent(prev, start);
      knownAdjacent(getEnd(end), next);
    };
    exports.knownSegment = knownSegment;
    var knownSiblings = (prev, current, next) => {
      knownAdjacent(prev, current);
      knownAdjacent(current, next);
    };
    exports.knownSiblings = knownSiblings;
    var localCase = ({ localName, ownerDocument }) => {
      return ownerDocument[MIME].ignoreCase ? localName.toUpperCase() : localName;
    };
    exports.localCase = localCase;
    var setAdjacent = (prev, next) => {
      if (prev)
        prev[NEXT] = next;
      if (next)
        next[PREV] = prev;
    };
    exports.setAdjacent = setAdjacent;
  }
});

// node_modules/linkedom/cjs/shared/shadow-roots.js
var require_shadow_roots = __commonJS({
  "node_modules/linkedom/cjs/shared/shadow-roots.js"(exports) {
    "use strict";
    var shadowRoots = /* @__PURE__ */ new WeakMap();
    exports.shadowRoots = shadowRoots;
  }
});

// node_modules/linkedom/cjs/interface/custom-element-registry.js
var require_custom_element_registry = __commonJS({
  "node_modules/linkedom/cjs/interface/custom-element-registry.js"(exports) {
    "use strict";
    var { ELEMENT_NODE } = require_constants();
    var { END, NEXT, UPGRADE } = require_symbols();
    var { entries, setPrototypeOf } = require_object();
    var { shadowRoots } = require_shadow_roots();
    var reactive = false;
    var Classes = /* @__PURE__ */ new WeakMap();
    exports.Classes = Classes;
    var customElements = /* @__PURE__ */ new WeakMap();
    exports.customElements = customElements;
    var attributeChangedCallback = (element, attributeName, oldValue, newValue) => {
      if (reactive && customElements.has(element) && element.attributeChangedCallback && element.constructor.observedAttributes.includes(attributeName)) {
        element.attributeChangedCallback(attributeName, oldValue, newValue);
      }
    };
    exports.attributeChangedCallback = attributeChangedCallback;
    var createTrigger = (method, isConnected) => (element) => {
      if (customElements.has(element)) {
        const info = customElements.get(element);
        if (info.connected !== isConnected && element.isConnected === isConnected) {
          info.connected = isConnected;
          if (method in element)
            element[method]();
        }
      }
    };
    var triggerConnected = createTrigger("connectedCallback", true);
    var connectedCallback = (element) => {
      if (reactive) {
        triggerConnected(element);
        if (shadowRoots.has(element))
          element = shadowRoots.get(element).shadowRoot;
        let { [NEXT]: next, [END]: end } = element;
        while (next !== end) {
          if (next.nodeType === ELEMENT_NODE)
            triggerConnected(next);
          next = next[NEXT];
        }
      }
    };
    exports.connectedCallback = connectedCallback;
    var triggerDisconnected = createTrigger("disconnectedCallback", false);
    var disconnectedCallback = (element) => {
      if (reactive) {
        triggerDisconnected(element);
        if (shadowRoots.has(element))
          element = shadowRoots.get(element).shadowRoot;
        let { [NEXT]: next, [END]: end } = element;
        while (next !== end) {
          if (next.nodeType === ELEMENT_NODE)
            triggerDisconnected(next);
          next = next[NEXT];
        }
      }
    };
    exports.disconnectedCallback = disconnectedCallback;
    var CustomElementRegistry = class {
      constructor(ownerDocument) {
        this.ownerDocument = ownerDocument;
        this.registry = /* @__PURE__ */ new Map();
        this.waiting = /* @__PURE__ */ new Map();
        this.active = false;
      }
      define(localName, Class, options = {}) {
        const { ownerDocument, registry, waiting } = this;
        if (registry.has(localName))
          throw new Error("unable to redefine " + localName);
        if (Classes.has(Class))
          throw new Error("unable to redefine the same class: " + Class);
        this.active = reactive = true;
        const { extends: extend } = options;
        Classes.set(Class, {
          ownerDocument,
          options: { is: extend ? localName : "" },
          localName: extend || localName
        });
        const check = extend ? (element) => {
          return element.localName === extend && element.getAttribute("is") === localName;
        } : (element) => element.localName === localName;
        registry.set(localName, { Class, check });
        if (waiting.has(localName)) {
          for (const resolve of waiting.get(localName))
            resolve(Class);
          waiting.delete(localName);
        }
        ownerDocument.querySelectorAll(extend ? `${extend}[is="${localName}"]` : localName).forEach(this.upgrade, this);
      }
      upgrade(element) {
        if (customElements.has(element))
          return;
        const { ownerDocument, registry } = this;
        const ce = element.getAttribute("is") || element.localName;
        if (registry.has(ce)) {
          const { Class, check } = registry.get(ce);
          if (check(element)) {
            const { attributes, isConnected } = element;
            for (const attr of attributes)
              element.removeAttributeNode(attr);
            const values = entries(element);
            for (const [key] of values)
              delete element[key];
            setPrototypeOf(element, Class.prototype);
            ownerDocument[UPGRADE] = { element, values };
            new Class(ownerDocument, ce);
            customElements.set(element, { connected: isConnected });
            for (const attr of attributes)
              element.setAttributeNode(attr);
            if (isConnected && element.connectedCallback)
              element.connectedCallback();
          }
        }
      }
      whenDefined(localName) {
        const { registry, waiting } = this;
        return new Promise((resolve) => {
          if (registry.has(localName))
            resolve(registry.get(localName).Class);
          else {
            if (!waiting.has(localName))
              waiting.set(localName, []);
            waiting.get(localName).push(resolve);
          }
        });
      }
      get(localName) {
        const info = this.registry.get(localName);
        return info && info.Class;
      }
    };
    exports.CustomElementRegistry = CustomElementRegistry;
  }
});

// node_modules/linkedom/cjs/shared/parse-from-string.js
var require_parse_from_string = __commonJS({
  "node_modules/linkedom/cjs/shared/parse-from-string.js"(exports) {
    "use strict";
    var HTMLParser2 = require_lib6();
    var { ELEMENT_NODE, SVG_NAMESPACE } = require_constants();
    var { CUSTOM_ELEMENTS, PREV, END, VALUE } = require_symbols();
    var { keys } = require_object();
    var { knownBoundaries, knownSiblings } = require_utils();
    var { attributeChangedCallback, connectedCallback } = require_custom_element_registry();
    var { Parser } = HTMLParser2;
    var notParsing = true;
    var append = (self, node, active) => {
      const end = self[END];
      node.parentNode = self;
      knownBoundaries(end[PREV], node, end);
      if (active && node.nodeType === ELEMENT_NODE)
        connectedCallback(node);
      return node;
    };
    var attribute = (element, end, attribute2, value, active) => {
      attribute2[VALUE] = value;
      attribute2.ownerElement = element;
      knownSiblings(end[PREV], attribute2, end);
      if (attribute2.name === "class")
        element.className = value;
      if (active)
        attributeChangedCallback(element, attribute2.name, null, value);
    };
    var isNotParsing = () => notParsing;
    exports.isNotParsing = isNotParsing;
    var parseFromString = (document2, isHTML, markupLanguage) => {
      const { active, registry } = document2[CUSTOM_ELEMENTS];
      let node = document2;
      let ownerSVGElement = null;
      notParsing = false;
      const content = new Parser({
        onprocessinginstruction(name, data) {
          if (name.toLowerCase() === "!doctype")
            document2.doctype = data.slice(name.length).trim();
        },
        onopentag(name, attributes) {
          let create = true;
          if (isHTML) {
            if (ownerSVGElement) {
              node = append(node, document2.createElementNS(SVG_NAMESPACE, name), active);
              node.ownerSVGElement = ownerSVGElement;
              create = false;
            } else if (name === "svg" || name === "SVG") {
              ownerSVGElement = document2.createElementNS(SVG_NAMESPACE, name);
              node = append(node, ownerSVGElement, active);
              create = false;
            } else if (active) {
              const ce = name.includes("-") ? name : attributes.is || "";
              if (ce && registry.has(ce)) {
                const { Class } = registry.get(ce);
                node = append(node, new Class(), active);
                delete attributes.is;
                create = false;
              }
            }
          }
          if (create)
            node = append(node, document2.createElement(name), false);
          let end = node[END];
          for (const name2 of keys(attributes))
            attribute(node, end, document2.createAttribute(name2), attributes[name2], active);
        },
        oncomment(data) {
          append(node, document2.createComment(data), active);
        },
        ontext(text) {
          append(node, document2.createTextNode(text), active);
        },
        onclosetag() {
          if (isHTML && node === ownerSVGElement)
            ownerSVGElement = null;
          node = node.parentNode;
        }
      }, {
        lowerCaseAttributeNames: false,
        decodeEntities: true,
        xmlMode: !isHTML
      });
      content.write(markupLanguage);
      content.end();
      notParsing = true;
      return document2;
    };
    exports.parseFromString = parseFromString;
  }
});

// node_modules/linkedom/cjs/shared/register-html-class.js
var require_register_html_class = __commonJS({
  "node_modules/linkedom/cjs/shared/register-html-class.js"(exports) {
    "use strict";
    var htmlClasses = /* @__PURE__ */ new Map();
    exports.htmlClasses = htmlClasses;
    var registerHTMLClass = (names, Class) => {
      for (const name of [].concat(names)) {
        htmlClasses.set(name, Class);
        htmlClasses.set(name.toUpperCase(), Class);
      }
    };
    exports.registerHTMLClass = registerHTMLClass;
  }
});

// node_modules/linkedom/commonjs/perf_hooks.cjs
var require_perf_hooks = __commonJS({
  "node_modules/linkedom/commonjs/perf_hooks.cjs"(exports) {
    try {
      const { performance } = __require("perf_hooks");
      exports.performance = performance;
    } catch (fallback) {
      exports.performance = { now() {
        return +new Date();
      } };
    }
  }
});

// node_modules/linkedom/cjs/shared/jsdon.js
var require_jsdon = __commonJS({
  "node_modules/linkedom/cjs/shared/jsdon.js"(exports) {
    "use strict";
    var {
      NODE_END,
      ATTRIBUTE_NODE,
      COMMENT_NODE,
      DOCUMENT_TYPE_NODE,
      ELEMENT_NODE,
      TEXT_NODE
    } = require_constants();
    var { END, NEXT, VALUE } = require_symbols();
    var { getEnd } = require_utils();
    var loopSegment = ({ [NEXT]: next, [END]: end }, json) => {
      while (next !== end) {
        switch (next.nodeType) {
          case ATTRIBUTE_NODE:
            attrAsJSON(next, json);
            break;
          case TEXT_NODE:
          case COMMENT_NODE:
            characterDataAsJSON(next, json);
            break;
          case ELEMENT_NODE:
            elementAsJSON(next, json);
            next = getEnd(next);
            break;
          case DOCUMENT_TYPE_NODE:
            documentTypeAsJSON(next, json);
            break;
        }
        next = next[NEXT];
      }
      const last = json.length - 1;
      const value = json[last];
      if (typeof value === "number" && value < 0)
        json[last] += NODE_END;
      else
        json.push(NODE_END);
    };
    var attrAsJSON = (attr, json) => {
      json.push(ATTRIBUTE_NODE, attr.name);
      const value = attr[VALUE].trim();
      if (value)
        json.push(value);
    };
    exports.attrAsJSON = attrAsJSON;
    var characterDataAsJSON = (node, json) => {
      const value = node[VALUE];
      if (value.trim())
        json.push(node.nodeType, value);
    };
    exports.characterDataAsJSON = characterDataAsJSON;
    var nonElementAsJSON = (node, json) => {
      json.push(node.nodeType);
      loopSegment(node, json);
    };
    exports.nonElementAsJSON = nonElementAsJSON;
    var documentTypeAsJSON = ({ name, publicId, systemId }, json) => {
      json.push(DOCUMENT_TYPE_NODE, name);
      if (publicId)
        json.push(publicId);
      if (systemId)
        json.push(systemId);
    };
    exports.documentTypeAsJSON = documentTypeAsJSON;
    var elementAsJSON = (element, json) => {
      json.push(ELEMENT_NODE, element.localName);
      loopSegment(element, json);
    };
    exports.elementAsJSON = elementAsJSON;
  }
});

// node_modules/linkedom/cjs/interface/mutation-observer.js
var require_mutation_observer = __commonJS({
  "node_modules/linkedom/cjs/interface/mutation-observer.js"(exports) {
    "use strict";
    var { MUTATION_OBSERVER } = require_symbols();
    var createRecord = (type, target, addedNodes, removedNodes, attributeName, oldValue) => ({ type, target, addedNodes, removedNodes, attributeName, oldValue });
    var queueAttribute = (observer, target, attributeName, attributeFilter, attributeOldValue, oldValue) => {
      if (!attributeFilter || attributeFilter.includes(attributeName)) {
        const { callback, records, scheduled } = observer;
        records.push(createRecord("attributes", target, [], [], attributeName, attributeOldValue ? oldValue : void 0));
        if (!scheduled) {
          observer.scheduled = true;
          Promise.resolve().then(() => {
            observer.scheduled = false;
            callback(records.splice(0), observer);
          });
        }
      }
    };
    var attributeChangedCallback = (element, attributeName, oldValue) => {
      const { ownerDocument } = element;
      const { active, observers } = ownerDocument[MUTATION_OBSERVER];
      if (active) {
        for (const observer of observers) {
          for (const [
            target,
            {
              childList,
              subtree,
              attributes,
              attributeFilter,
              attributeOldValue
            }
          ] of observer.nodes) {
            if (childList) {
              if (subtree && (target === ownerDocument || target.contains(element)) || !subtree && target.children.includes(element)) {
                queueAttribute(observer, element, attributeName, attributeFilter, attributeOldValue, oldValue);
                break;
              }
            } else if (attributes && target === element) {
              queueAttribute(observer, element, attributeName, attributeFilter, attributeOldValue, oldValue);
              break;
            }
          }
        }
      }
    };
    exports.attributeChangedCallback = attributeChangedCallback;
    var moCallback = (element, parentNode) => {
      const { ownerDocument } = element;
      const { active, observers } = ownerDocument[MUTATION_OBSERVER];
      if (active) {
        for (const observer of observers) {
          for (const [target, { subtree, childList, characterData }] of observer.nodes) {
            if (childList) {
              if (parentNode && (target === parentNode || subtree && target.contains(parentNode)) || !parentNode && (subtree && (target === ownerDocument || target.contains(element)) || !subtree && target[characterData ? "childNodes" : "children"].includes(element))) {
                const { callback, records, scheduled } = observer;
                records.push(createRecord("childList", target, parentNode ? [] : [element], parentNode ? [element] : []));
                if (!scheduled) {
                  observer.scheduled = true;
                  Promise.resolve().then(() => {
                    observer.scheduled = false;
                    callback(records.splice(0), observer);
                  });
                }
                break;
              }
            }
          }
        }
      }
    };
    exports.moCallback = moCallback;
    var MutationObserverClass = class {
      constructor(ownerDocument) {
        const observers = /* @__PURE__ */ new Set();
        this.observers = observers;
        this.active = false;
        this.class = class MutationObserver {
          constructor(callback) {
            this.callback = callback;
            this.nodes = /* @__PURE__ */ new Map();
            this.records = [];
            this.scheduled = false;
          }
          disconnect() {
            this.records.splice(0);
            this.nodes.clear();
            observers.delete(this);
            ownerDocument[MUTATION_OBSERVER].active = !!observers.size;
          }
          observe(target, options = {
            subtree: false,
            childList: false,
            attributes: false,
            attributeFilter: null,
            attributeOldValue: false,
            characterData: false
          }) {
            if ("attributeOldValue" in options || "attributeFilter" in options)
              options.attributes = true;
            options.childList = !!options.childList;
            options.subtree = !!options.subtree;
            this.nodes.set(target, options);
            observers.add(this);
            ownerDocument[MUTATION_OBSERVER].active = true;
          }
          takeRecords() {
            return this.records.splice(0);
          }
        };
      }
    };
    exports.MutationObserverClass = MutationObserverClass;
  }
});

// node_modules/linkedom/cjs/shared/attributes.js
var require_attributes = __commonJS({
  "node_modules/linkedom/cjs/shared/attributes.js"(exports) {
    "use strict";
    var { CLASS_LIST, NEXT, PREV, VALUE } = require_symbols();
    var { knownAdjacent, knownSiblings } = require_utils();
    var { attributeChangedCallback: ceAttributes } = require_custom_element_registry();
    var { attributeChangedCallback: moAttributes } = require_mutation_observer();
    var emptyAttributes = /* @__PURE__ */ new Set([
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "class",
      "contenteditable",
      "controls",
      "default",
      "defer",
      "disabled",
      "draggable",
      "formnovalidate",
      "hidden",
      "id",
      "ismap",
      "itemscope",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected",
      "style",
      "truespeed"
    ]);
    exports.emptyAttributes = emptyAttributes;
    var setAttribute = (element, attribute) => {
      const { [VALUE]: value, name } = attribute;
      attribute.ownerElement = element;
      knownSiblings(element, attribute, element[NEXT]);
      if (name === "class")
        element.className = value;
      moAttributes(element, name, null);
      ceAttributes(element, name, null, value);
    };
    exports.setAttribute = setAttribute;
    var removeAttribute = (element, attribute) => {
      const { [VALUE]: value, name } = attribute;
      knownAdjacent(attribute[PREV], attribute[NEXT]);
      attribute.ownerElement = attribute[PREV] = attribute[NEXT] = null;
      if (name === "class")
        element[CLASS_LIST] = null;
      moAttributes(element, name, value);
      ceAttributes(element, name, value, null);
    };
    exports.removeAttribute = removeAttribute;
    var booleanAttribute = {
      get(element, name) {
        return element.hasAttribute(name);
      },
      set(element, name, value) {
        if (value)
          element.setAttribute(name, "");
        else
          element.removeAttribute(name);
      }
    };
    exports.booleanAttribute = booleanAttribute;
    var numericAttribute = {
      get(element, name) {
        return parseFloat(element.getAttribute(name) || 0);
      },
      set(element, name, value) {
        element.setAttribute(name, value);
      }
    };
    exports.numericAttribute = numericAttribute;
    var stringAttribute = {
      get(element, name) {
        return element.getAttribute(name) || "";
      },
      set(element, name, value) {
        element.setAttribute(name, value);
      }
    };
    exports.stringAttribute = stringAttribute;
  }
});

// node_modules/linkedom/cjs/interface/event-target.js
var require_event_target = __commonJS({
  "node_modules/linkedom/cjs/interface/event-target.js"(exports) {
    "use strict";
    var wm = /* @__PURE__ */ new WeakMap();
    function dispatch(event, listener) {
      if (typeof listener === "function")
        listener.call(event.target, event);
      else
        listener.handleEvent(event);
      return event._stopImmediatePropagationFlag;
    }
    function invokeListeners({ currentTarget, target }) {
      const map = wm.get(currentTarget);
      if (map && map.has(this.type)) {
        const listeners = map.get(this.type);
        if (currentTarget === target) {
          this.eventPhase = this.AT_TARGET;
        } else {
          this.eventPhase = this.BUBBLING_PHASE;
        }
        this.currentTarget = currentTarget;
        this.target = target;
        for (const [listener, options] of listeners) {
          if (options && options.once)
            listeners.delete(listener);
          if (dispatch(this, listener))
            break;
        }
        delete this.currentTarget;
        delete this.target;
        return this.cancelBubble;
      }
    }
    var DOMEventTarget = class {
      constructor() {
        wm.set(this, /* @__PURE__ */ new Map());
      }
      _getParent() {
        return null;
      }
      addEventListener(type, listener, options) {
        const map = wm.get(this);
        if (!map.has(type))
          map.set(type, /* @__PURE__ */ new Map());
        map.get(type).set(listener, options);
      }
      removeEventListener(type, listener) {
        const map = wm.get(this);
        if (map.has(type)) {
          const listeners = map.get(type);
          if (listeners.delete(listener) && !listeners.size)
            map.delete(type);
        }
      }
      dispatchEvent(event) {
        let node = this;
        event.eventPhase = event.CAPTURING_PHASE;
        while (node) {
          if (node.dispatchEvent)
            event._path.push({ currentTarget: node, target: this });
          node = event.bubbles && node._getParent && node._getParent();
        }
        event._path.some(invokeListeners, event);
        event._path = [];
        event.eventPhase = event.NONE;
        return !event.defaultPrevented;
      }
    };
    exports.EventTarget = DOMEventTarget;
  }
});

// node_modules/linkedom/cjs/interface/node-list.js
var require_node_list = __commonJS({
  "node_modules/linkedom/cjs/interface/node-list.js"(exports) {
    "use strict";
    var NodeList = class extends Array {
      item(i) {
        return i < this.length ? this[i] : null;
      }
    };
    exports.NodeList = NodeList;
  }
});

// node_modules/linkedom/cjs/interface/node.js
var require_node2 = __commonJS({
  "node_modules/linkedom/cjs/interface/node.js"(exports) {
    "use strict";
    var {
      ELEMENT_NODE,
      ATTRIBUTE_NODE,
      TEXT_NODE,
      COMMENT_NODE,
      DOCUMENT_NODE,
      DOCUMENT_FRAGMENT_NODE,
      DOCUMENT_TYPE_NODE,
      DOCUMENT_POSITION_DISCONNECTED,
      DOCUMENT_POSITION_PRECEDING,
      DOCUMENT_POSITION_FOLLOWING,
      DOCUMENT_POSITION_CONTAINS,
      DOCUMENT_POSITION_CONTAINED_BY,
      DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
    } = require_constants();
    var { NEXT, PREV } = require_symbols();
    var { EventTarget } = require_event_target();
    var { NodeList } = require_node_list();
    var getParentNodeCount = ({ parentNode }) => {
      let count = 0;
      while (parentNode) {
        count++;
        parentNode = parentNode.parentNode;
      }
      return count;
    };
    var Node = class extends EventTarget {
      static get ELEMENT_NODE() {
        return ELEMENT_NODE;
      }
      static get ATTRIBUTE_NODE() {
        return ATTRIBUTE_NODE;
      }
      static get TEXT_NODE() {
        return TEXT_NODE;
      }
      static get COMMENT_NODE() {
        return COMMENT_NODE;
      }
      static get DOCUMENT_NODE() {
        return DOCUMENT_NODE;
      }
      static get DOCUMENT_FRAGMENT_NODE() {
        return DOCUMENT_FRAGMENT_NODE;
      }
      static get DOCUMENT_TYPE_NODE() {
        return DOCUMENT_TYPE_NODE;
      }
      constructor(ownerDocument, localName, nodeType) {
        super();
        this.ownerDocument = ownerDocument;
        this.localName = localName;
        this.nodeType = nodeType;
        this.parentNode = null;
        this[NEXT] = null;
        this[PREV] = null;
      }
      get ELEMENT_NODE() {
        return ELEMENT_NODE;
      }
      get ATTRIBUTE_NODE() {
        return ATTRIBUTE_NODE;
      }
      get TEXT_NODE() {
        return TEXT_NODE;
      }
      get COMMENT_NODE() {
        return COMMENT_NODE;
      }
      get DOCUMENT_NODE() {
        return DOCUMENT_NODE;
      }
      get DOCUMENT_FRAGMENT_NODE() {
        return DOCUMENT_FRAGMENT_NODE;
      }
      get DOCUMENT_TYPE_NODE() {
        return DOCUMENT_TYPE_NODE;
      }
      get baseURI() {
        const ownerDocument = this.nodeType === DOCUMENT_NODE ? this : this.ownerDocument;
        if (ownerDocument) {
          const base = ownerDocument.querySelector("base");
          if (base)
            return base.getAttribute("href");
          const { location } = ownerDocument.defaultView;
          if (location)
            return location.href;
        }
        return null;
      }
      get isConnected() {
        return false;
      }
      get nodeName() {
        return this.localName;
      }
      get parentElement() {
        return null;
      }
      get previousSibling() {
        return null;
      }
      get previousElementSibling() {
        return null;
      }
      get nextSibling() {
        return null;
      }
      get nextElementSibling() {
        return null;
      }
      get childNodes() {
        return new NodeList();
      }
      get firstChild() {
        return null;
      }
      get lastChild() {
        return null;
      }
      get nodeValue() {
        return null;
      }
      set nodeValue(value) {
      }
      get textContent() {
        return null;
      }
      set textContent(value) {
      }
      normalize() {
      }
      cloneNode() {
        return null;
      }
      contains() {
        return false;
      }
      insertBefore(newNode, referenceNode) {
        return newNode;
      }
      appendChild(child) {
        return child;
      }
      replaceChild(newChild, oldChild) {
        return oldChild;
      }
      removeChild(child) {
        return child;
      }
      toString() {
        return "";
      }
      hasChildNodes() {
        return !!this.lastChild;
      }
      isSameNode(node) {
        return this === node;
      }
      compareDocumentPosition(target) {
        let result = 0;
        if (this !== target) {
          let self = getParentNodeCount(this);
          let other = getParentNodeCount(target);
          if (self < other) {
            result += DOCUMENT_POSITION_FOLLOWING;
            if (this.contains(target))
              result += DOCUMENT_POSITION_CONTAINED_BY;
          } else if (other < self) {
            result += DOCUMENT_POSITION_PRECEDING;
            if (target.contains(this))
              result += DOCUMENT_POSITION_CONTAINS;
          } else if (self && other) {
            const { childNodes } = this.parentNode;
            if (childNodes.indexOf(this) < childNodes.indexOf(target))
              result += DOCUMENT_POSITION_FOLLOWING;
            else
              result += DOCUMENT_POSITION_PRECEDING;
          }
          if (!self || !other) {
            result += DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
            result += DOCUMENT_POSITION_DISCONNECTED;
          }
        }
        return result;
      }
      isEqualNode(node) {
        if (this === node)
          return true;
        if (this.nodeType === node.nodeType) {
          switch (this.nodeType) {
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE: {
              const aNodes = this.childNodes;
              const bNodes = node.childNodes;
              return aNodes.length === bNodes.length && aNodes.every((node2, i) => node2.isEqualNode(bNodes[i]));
            }
          }
          return this.toString() === node.toString();
        }
        return false;
      }
      _getParent() {
        return this.parentNode;
      }
      getRootNode() {
        let root = this;
        while (root.parentNode)
          root = root.parentNode;
        return root.nodeType === DOCUMENT_NODE ? root.documentElement : root;
      }
    };
    exports.Node = Node;
  }
});

// node_modules/linkedom/cjs/interface/attr.js
var require_attr = __commonJS({
  "node_modules/linkedom/cjs/interface/attr.js"(exports) {
    "use strict";
    var { ATTRIBUTE_NODE } = require_constants();
    var { CHANGED, VALUE } = require_symbols();
    var { String: String2 } = require_utils();
    var { attrAsJSON } = require_jsdon();
    var { emptyAttributes } = require_attributes();
    var { attributeChangedCallback: moAttributes } = require_mutation_observer();
    var { attributeChangedCallback: ceAttributes } = require_custom_element_registry();
    var { Node } = require_node2();
    var QUOTE = /"/g;
    var Attr = class extends Node {
      constructor(ownerDocument, name, value = "") {
        super(ownerDocument, "#attribute", ATTRIBUTE_NODE);
        this.ownerElement = null;
        this.name = String2(name);
        this[VALUE] = String2(value);
        this[CHANGED] = false;
      }
      get value() {
        return this[VALUE];
      }
      set value(newValue) {
        const { [VALUE]: oldValue, name, ownerElement } = this;
        this[VALUE] = String2(newValue);
        this[CHANGED] = true;
        if (ownerElement) {
          moAttributes(ownerElement, name, oldValue);
          ceAttributes(ownerElement, name, oldValue, this[VALUE]);
        }
      }
      cloneNode() {
        const { ownerDocument, name, [VALUE]: value } = this;
        return new Attr(ownerDocument, name, value);
      }
      toString() {
        const { name, [VALUE]: value } = this;
        return emptyAttributes.has(name) && !value ? name : `${name}="${value.replace(QUOTE, "&quot;")}"`;
      }
      toJSON() {
        const json = [];
        attrAsJSON(this, json);
        return json;
      }
    };
    exports.Attr = Attr;
  }
});

// node_modules/linkedom/cjs/shared/node.js
var require_node3 = __commonJS({
  "node_modules/linkedom/cjs/shared/node.js"(exports) {
    "use strict";
    var {
      COMMENT_NODE,
      DOCUMENT_NODE,
      DOCUMENT_FRAGMENT_NODE,
      TEXT_NODE,
      NODE_END
    } = require_constants();
    var { START, NEXT, PREV } = require_symbols();
    var { getEnd } = require_utils();
    var isConnected = ({ ownerDocument, parentNode }) => {
      while (parentNode) {
        if (parentNode === ownerDocument)
          return true;
        parentNode = parentNode.parentNode || parentNode.host;
      }
      return false;
    };
    exports.isConnected = isConnected;
    var parentElement = ({ parentNode }) => {
      if (parentNode) {
        switch (parentNode.nodeType) {
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            return null;
        }
      }
      return parentNode;
    };
    exports.parentElement = parentElement;
    var previousSibling = ({ [PREV]: prev }) => {
      switch (prev ? prev.nodeType : 0) {
        case NODE_END:
          return prev[START];
        case TEXT_NODE:
        case COMMENT_NODE:
          return prev;
      }
      return null;
    };
    exports.previousSibling = previousSibling;
    var nextSibling = (node) => {
      const next = getEnd(node)[NEXT];
      return next && (next.nodeType === NODE_END ? null : next);
    };
    exports.nextSibling = nextSibling;
  }
});

// node_modules/linkedom/cjs/mixin/non-document-type-child-node.js
var require_non_document_type_child_node = __commonJS({
  "node_modules/linkedom/cjs/mixin/non-document-type-child-node.js"(exports) {
    "use strict";
    var { ELEMENT_NODE } = require_constants();
    var { nextSibling, previousSibling } = require_node3();
    var nextElementSibling = (node) => {
      let next = nextSibling(node);
      while (next && next.nodeType !== ELEMENT_NODE)
        next = nextSibling(next);
      return next;
    };
    exports.nextElementSibling = nextElementSibling;
    var previousElementSibling = (node) => {
      let prev = previousSibling(node);
      while (prev && prev.nodeType !== ELEMENT_NODE)
        prev = previousSibling(prev);
      return prev;
    };
    exports.previousElementSibling = previousElementSibling;
  }
});

// node_modules/linkedom/cjs/mixin/child-node.js
var require_child_node = __commonJS({
  "node_modules/linkedom/cjs/mixin/child-node.js"(exports) {
    "use strict";
    var { ELEMENT_NODE } = require_constants();
    var { NEXT, PREV } = require_symbols();
    var { getEnd, setAdjacent } = require_utils();
    var { moCallback } = require_mutation_observer();
    var { disconnectedCallback } = require_custom_element_registry();
    var asFragment = (ownerDocument, nodes) => {
      const fragment = ownerDocument.createDocumentFragment();
      fragment.append(...nodes);
      return fragment;
    };
    var before = (node, nodes) => {
      const { ownerDocument, parentNode } = node;
      if (parentNode)
        parentNode.insertBefore(asFragment(ownerDocument, nodes), node);
    };
    exports.before = before;
    var after = (node, nodes) => {
      const { ownerDocument, parentNode } = node;
      if (parentNode)
        parentNode.insertBefore(asFragment(ownerDocument, nodes), getEnd(node)[NEXT]);
    };
    exports.after = after;
    var replaceWith = (node, nodes) => {
      const { ownerDocument, parentNode } = node;
      if (parentNode) {
        parentNode.insertBefore(asFragment(ownerDocument, nodes), node);
        node.remove();
      }
    };
    exports.replaceWith = replaceWith;
    var remove = (prev, current, next) => {
      const { parentNode, nodeType } = current;
      if (prev || next) {
        setAdjacent(prev, next);
        current[PREV] = null;
        getEnd(current)[NEXT] = null;
      }
      if (parentNode) {
        current.parentNode = null;
        moCallback(current, parentNode);
        if (nodeType === ELEMENT_NODE)
          disconnectedCallback(current);
      }
    };
    exports.remove = remove;
  }
});

// node_modules/linkedom/cjs/interface/character-data.js
var require_character_data = __commonJS({
  "node_modules/linkedom/cjs/interface/character-data.js"(exports) {
    "use strict";
    var { NEXT, PREV, VALUE } = require_symbols();
    var { String: String2 } = require_utils();
    var { isConnected, parentElement, previousSibling, nextSibling } = require_node3();
    var { characterDataAsJSON } = require_jsdon();
    var { previousElementSibling, nextElementSibling } = require_non_document_type_child_node();
    var { before, after, replaceWith, remove } = require_child_node();
    var { Node } = require_node2();
    var { moCallback } = require_mutation_observer();
    var CharacterData2 = class extends Node {
      constructor(ownerDocument, localName, nodeType, data) {
        super(ownerDocument, localName, nodeType);
        this[VALUE] = String2(data);
      }
      get isConnected() {
        return isConnected(this);
      }
      get parentElement() {
        return parentElement(this);
      }
      get previousSibling() {
        return previousSibling(this);
      }
      get nextSibling() {
        return nextSibling(this);
      }
      get previousElementSibling() {
        return previousElementSibling(this);
      }
      get nextElementSibling() {
        return nextElementSibling(this);
      }
      before(...nodes) {
        before(this, nodes);
      }
      after(...nodes) {
        after(this, nodes);
      }
      replaceWith(...nodes) {
        replaceWith(this, nodes);
      }
      remove() {
        remove(this[PREV], this, this[NEXT]);
      }
      get data() {
        return this[VALUE];
      }
      set data(value) {
        this[VALUE] = String2(value);
        moCallback(this, this.parentNode);
      }
      get nodeValue() {
        return this.data;
      }
      set nodeValue(value) {
        this.data = value;
      }
      get textContent() {
        return this.data;
      }
      set textContent(value) {
        this.data = value;
      }
      get length() {
        return this.data.length;
      }
      substringData(offset, count) {
        return this.data.substr(offset, count);
      }
      appendData(data) {
        this.data += data;
      }
      insertData(offset, data) {
        const { data: t } = this;
        this.data = t.slice(0, offset) + data + t.slice(offset);
      }
      deleteData(offset, count) {
        const { data: t } = this;
        this.data = t.slice(0, offset) + t.slice(offset + count);
      }
      replaceData(offset, count, data) {
        const { data: t } = this;
        this.data = t.slice(0, offset) + data + t.slice(offset + count);
      }
      toJSON() {
        const json = [];
        characterDataAsJSON(this, json);
        return json;
      }
    };
    exports.CharacterData = CharacterData2;
  }
});

// node_modules/linkedom/cjs/interface/comment.js
var require_comment = __commonJS({
  "node_modules/linkedom/cjs/interface/comment.js"(exports) {
    "use strict";
    var { COMMENT_NODE } = require_constants();
    var { VALUE } = require_symbols();
    var { CharacterData: CharacterData2 } = require_character_data();
    var Comment = class extends CharacterData2 {
      constructor(ownerDocument, data = "") {
        super(ownerDocument, "#comment", COMMENT_NODE, data);
      }
      cloneNode() {
        const { ownerDocument, [VALUE]: data } = this;
        return new Comment(ownerDocument, data);
      }
      toString() {
        return `<!--${this[VALUE]}-->`;
      }
    };
    exports.Comment = Comment;
  }
});

// node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/boolbase/index.js"(exports, module) {
    module.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// node_modules/css-what/lib/commonjs/types.js
var require_types = __commonJS({
  "node_modules/css-what/lib/commonjs/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeAction = exports.IgnoreCaseMode = exports.SelectorType = void 0;
    var SelectorType;
    (function(SelectorType2) {
      SelectorType2["Attribute"] = "attribute";
      SelectorType2["Pseudo"] = "pseudo";
      SelectorType2["PseudoElement"] = "pseudo-element";
      SelectorType2["Tag"] = "tag";
      SelectorType2["Universal"] = "universal";
      SelectorType2["Adjacent"] = "adjacent";
      SelectorType2["Child"] = "child";
      SelectorType2["Descendant"] = "descendant";
      SelectorType2["Parent"] = "parent";
      SelectorType2["Sibling"] = "sibling";
      SelectorType2["ColumnCombinator"] = "column-combinator";
    })(SelectorType = exports.SelectorType || (exports.SelectorType = {}));
    exports.IgnoreCaseMode = {
      Unknown: null,
      QuirksMode: "quirks",
      IgnoreCase: true,
      CaseSensitive: false
    };
    var AttributeAction;
    (function(AttributeAction2) {
      AttributeAction2["Any"] = "any";
      AttributeAction2["Element"] = "element";
      AttributeAction2["End"] = "end";
      AttributeAction2["Equals"] = "equals";
      AttributeAction2["Exists"] = "exists";
      AttributeAction2["Hyphen"] = "hyphen";
      AttributeAction2["Not"] = "not";
      AttributeAction2["Start"] = "start";
    })(AttributeAction = exports.AttributeAction || (exports.AttributeAction = {}));
  }
});

// node_modules/css-what/lib/commonjs/parse.js
var require_parse = __commonJS({
  "node_modules/css-what/lib/commonjs/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.isTraversal = void 0;
    var types_1 = require_types();
    var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
    var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
    var actionTypes = /* @__PURE__ */ new Map([
      [126, types_1.AttributeAction.Element],
      [94, types_1.AttributeAction.Start],
      [36, types_1.AttributeAction.End],
      [42, types_1.AttributeAction.Any],
      [33, types_1.AttributeAction.Not],
      [124, types_1.AttributeAction.Hyphen]
    ]);
    var unpackPseudos = /* @__PURE__ */ new Set([
      "has",
      "not",
      "matches",
      "is",
      "where",
      "host",
      "host-context"
    ]);
    function isTraversal(selector) {
      switch (selector.type) {
        case types_1.SelectorType.Adjacent:
        case types_1.SelectorType.Child:
        case types_1.SelectorType.Descendant:
        case types_1.SelectorType.Parent:
        case types_1.SelectorType.Sibling:
        case types_1.SelectorType.ColumnCombinator:
          return true;
        default:
          return false;
      }
    }
    exports.isTraversal = isTraversal;
    var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
    function funescape(_, escaped, escapedWhitespace) {
      var high = parseInt(escaped, 16) - 65536;
      return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
    }
    function unescapeCSS(str) {
      return str.replace(reEscape, funescape);
    }
    function isQuote(c) {
      return c === 39 || c === 34;
    }
    function isWhitespace(c) {
      return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
    }
    function parse(selector) {
      var subselects = [];
      var endIndex = parseSelector(subselects, "".concat(selector), 0);
      if (endIndex < selector.length) {
        throw new Error("Unmatched selector: ".concat(selector.slice(endIndex)));
      }
      return subselects;
    }
    exports.parse = parse;
    function parseSelector(subselects, selector, selectorIndex) {
      var tokens = [];
      function getName(offset) {
        var match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
          throw new Error("Expected name, found ".concat(selector.slice(selectorIndex)));
        }
        var name = match[0];
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
      }
      function stripWhitespace(offset) {
        selectorIndex += offset;
        while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
          selectorIndex++;
        }
      }
      function readValueWithParenthesis() {
        selectorIndex += 1;
        var start = selectorIndex;
        var counter = 1;
        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
          if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
            counter++;
          } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
            counter--;
          }
        }
        if (counter) {
          throw new Error("Parenthesis not matched");
        }
        return unescapeCSS(selector.slice(start, selectorIndex - 1));
      }
      function isEscaped(pos) {
        var slashCount = 0;
        while (selector.charCodeAt(--pos) === 92)
          slashCount++;
        return (slashCount & 1) === 1;
      }
      function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
          throw new Error("Did not expect successive traversals.");
        }
      }
      function addTraversal(type) {
        if (tokens.length > 0 && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
          tokens[tokens.length - 1].type = type;
          return;
        }
        ensureNotTraversal();
        tokens.push({ type });
      }
      function addSpecialAttribute(name, action2) {
        tokens.push({
          type: types_1.SelectorType.Attribute,
          name,
          action: action2,
          value: getName(1),
          namespace: null,
          ignoreCase: "quirks"
        });
      }
      function finalizeSubselector() {
        if (tokens.length && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
          tokens.pop();
        }
        if (tokens.length === 0) {
          throw new Error("Empty sub-selector");
        }
        subselects.push(tokens);
      }
      stripWhitespace(0);
      if (selector.length === selectorIndex) {
        return selectorIndex;
      }
      loop:
        while (selectorIndex < selector.length) {
          var firstChar = selector.charCodeAt(selectorIndex);
          switch (firstChar) {
            case 32:
            case 9:
            case 10:
            case 12:
            case 13: {
              if (tokens.length === 0 || tokens[0].type !== types_1.SelectorType.Descendant) {
                ensureNotTraversal();
                tokens.push({ type: types_1.SelectorType.Descendant });
              }
              stripWhitespace(1);
              break;
            }
            case 62: {
              addTraversal(types_1.SelectorType.Child);
              stripWhitespace(1);
              break;
            }
            case 60: {
              addTraversal(types_1.SelectorType.Parent);
              stripWhitespace(1);
              break;
            }
            case 126: {
              addTraversal(types_1.SelectorType.Sibling);
              stripWhitespace(1);
              break;
            }
            case 43: {
              addTraversal(types_1.SelectorType.Adjacent);
              stripWhitespace(1);
              break;
            }
            case 46: {
              addSpecialAttribute("class", types_1.AttributeAction.Element);
              break;
            }
            case 35: {
              addSpecialAttribute("id", types_1.AttributeAction.Equals);
              break;
            }
            case 91: {
              stripWhitespace(1);
              var name_1 = void 0;
              var namespace = null;
              if (selector.charCodeAt(selectorIndex) === 124) {
                name_1 = getName(1);
              } else if (selector.startsWith("*|", selectorIndex)) {
                namespace = "*";
                name_1 = getName(2);
              } else {
                name_1 = getName(0);
                if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
                  namespace = name_1;
                  name_1 = getName(1);
                }
              }
              stripWhitespace(0);
              var action = types_1.AttributeAction.Exists;
              var possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
              if (possibleAction) {
                action = possibleAction;
                if (selector.charCodeAt(selectorIndex + 1) !== 61) {
                  throw new Error("Expected `=`");
                }
                stripWhitespace(2);
              } else if (selector.charCodeAt(selectorIndex) === 61) {
                action = types_1.AttributeAction.Equals;
                stripWhitespace(1);
              }
              var value = "";
              var ignoreCase = null;
              if (action !== "exists") {
                if (isQuote(selector.charCodeAt(selectorIndex))) {
                  var quote = selector.charCodeAt(selectorIndex);
                  var sectionEnd = selectorIndex + 1;
                  while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                    sectionEnd += 1;
                  }
                  if (selector.charCodeAt(sectionEnd) !== quote) {
                    throw new Error("Attribute value didn't end");
                  }
                  value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                  selectorIndex = sectionEnd + 1;
                } else {
                  var valueStart = selectorIndex;
                  while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                    selectorIndex += 1;
                  }
                  value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                }
                stripWhitespace(0);
                var forceIgnore = selector.charCodeAt(selectorIndex) | 32;
                if (forceIgnore === 115) {
                  ignoreCase = false;
                  stripWhitespace(1);
                } else if (forceIgnore === 105) {
                  ignoreCase = true;
                  stripWhitespace(1);
                }
              }
              if (selector.charCodeAt(selectorIndex) !== 93) {
                throw new Error("Attribute selector didn't terminate");
              }
              selectorIndex += 1;
              var attributeSelector = {
                type: types_1.SelectorType.Attribute,
                name: name_1,
                action,
                value,
                namespace,
                ignoreCase
              };
              tokens.push(attributeSelector);
              break;
            }
            case 58: {
              if (selector.charCodeAt(selectorIndex + 1) === 58) {
                tokens.push({
                  type: types_1.SelectorType.PseudoElement,
                  name: getName(2).toLowerCase(),
                  data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
                });
                continue;
              }
              var name_2 = getName(1).toLowerCase();
              var data = null;
              if (selector.charCodeAt(selectorIndex) === 40) {
                if (unpackPseudos.has(name_2)) {
                  if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                    throw new Error("Pseudo-selector ".concat(name_2, " cannot be quoted"));
                  }
                  data = [];
                  selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                  if (selector.charCodeAt(selectorIndex) !== 41) {
                    throw new Error("Missing closing parenthesis in :".concat(name_2, " (").concat(selector, ")"));
                  }
                  selectorIndex += 1;
                } else {
                  data = readValueWithParenthesis();
                  if (stripQuotesFromPseudos.has(name_2)) {
                    var quot = data.charCodeAt(0);
                    if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                      data = data.slice(1, -1);
                    }
                  }
                  data = unescapeCSS(data);
                }
              }
              tokens.push({ type: types_1.SelectorType.Pseudo, name: name_2, data });
              break;
            }
            case 44: {
              finalizeSubselector();
              tokens = [];
              stripWhitespace(1);
              break;
            }
            default: {
              if (selector.startsWith("/*", selectorIndex)) {
                var endIndex = selector.indexOf("*/", selectorIndex + 2);
                if (endIndex < 0) {
                  throw new Error("Comment was not terminated");
                }
                selectorIndex = endIndex + 2;
                if (tokens.length === 0) {
                  stripWhitespace(0);
                }
                break;
              }
              var namespace = null;
              var name_3 = void 0;
              if (firstChar === 42) {
                selectorIndex += 1;
                name_3 = "*";
              } else if (firstChar === 124) {
                name_3 = "";
                if (selector.charCodeAt(selectorIndex + 1) === 124) {
                  addTraversal(types_1.SelectorType.ColumnCombinator);
                  stripWhitespace(2);
                  break;
                }
              } else if (reName.test(selector.slice(selectorIndex))) {
                name_3 = getName(0);
              } else {
                break loop;
              }
              if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
                namespace = name_3;
                if (selector.charCodeAt(selectorIndex + 1) === 42) {
                  name_3 = "*";
                  selectorIndex += 2;
                } else {
                  name_3 = getName(1);
                }
              }
              tokens.push(name_3 === "*" ? { type: types_1.SelectorType.Universal, namespace } : { type: types_1.SelectorType.Tag, name: name_3, namespace });
            }
          }
        }
      finalizeSubselector();
      return selectorIndex;
    }
  }
});

// node_modules/css-what/lib/commonjs/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/css-what/lib/commonjs/stringify.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = void 0;
    var types_1 = require_types();
    var attribValChars = ["\\", '"'];
    var pseudoValChars = __spreadArray(__spreadArray([], attribValChars, true), ["(", ")"], false);
    var charsToEscapeInAttributeValue = new Set(attribValChars.map(function(c) {
      return c.charCodeAt(0);
    }));
    var charsToEscapeInPseudoValue = new Set(pseudoValChars.map(function(c) {
      return c.charCodeAt(0);
    }));
    var charsToEscapeInName = new Set(__spreadArray(__spreadArray([], pseudoValChars, true), [
      "~",
      "^",
      "$",
      "*",
      "+",
      "!",
      "|",
      ":",
      "[",
      "]",
      " ",
      "."
    ], false).map(function(c) {
      return c.charCodeAt(0);
    }));
    function stringify(selector) {
      return selector.map(function(token) {
        return token.map(stringifyToken).join("");
      }).join(", ");
    }
    exports.stringify = stringify;
    function stringifyToken(token, index, arr) {
      switch (token.type) {
        case types_1.SelectorType.Child:
          return index === 0 ? "> " : " > ";
        case types_1.SelectorType.Parent:
          return index === 0 ? "< " : " < ";
        case types_1.SelectorType.Sibling:
          return index === 0 ? "~ " : " ~ ";
        case types_1.SelectorType.Adjacent:
          return index === 0 ? "+ " : " + ";
        case types_1.SelectorType.Descendant:
          return " ";
        case types_1.SelectorType.ColumnCombinator:
          return index === 0 ? "|| " : " || ";
        case types_1.SelectorType.Universal:
          return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : "".concat(getNamespace(token.namespace), "*");
        case types_1.SelectorType.Tag:
          return getNamespacedName(token);
        case types_1.SelectorType.PseudoElement:
          return "::".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(escapeName(token.data, charsToEscapeInPseudoValue), ")"));
        case types_1.SelectorType.Pseudo:
          return ":".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data), ")"));
        case types_1.SelectorType.Attribute: {
          if (token.name === "id" && token.action === types_1.AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
            return "#".concat(escapeName(token.value, charsToEscapeInName));
          }
          if (token.name === "class" && token.action === types_1.AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
            return ".".concat(escapeName(token.value, charsToEscapeInName));
          }
          var name_1 = getNamespacedName(token);
          if (token.action === types_1.AttributeAction.Exists) {
            return "[".concat(name_1, "]");
          }
          return "[".concat(name_1).concat(getActionValue(token.action), '="').concat(escapeName(token.value, charsToEscapeInAttributeValue), '"').concat(token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s", "]");
        }
      }
    }
    function getActionValue(action) {
      switch (action) {
        case types_1.AttributeAction.Equals:
          return "";
        case types_1.AttributeAction.Element:
          return "~";
        case types_1.AttributeAction.Start:
          return "^";
        case types_1.AttributeAction.End:
          return "$";
        case types_1.AttributeAction.Any:
          return "*";
        case types_1.AttributeAction.Not:
          return "!";
        case types_1.AttributeAction.Hyphen:
          return "|";
        case types_1.AttributeAction.Exists:
          throw new Error("Shouldn't be here");
      }
    }
    function getNamespacedName(token) {
      return "".concat(getNamespace(token.namespace)).concat(escapeName(token.name, charsToEscapeInName));
    }
    function getNamespace(namespace) {
      return namespace !== null ? "".concat(namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName), "|") : "";
    }
    function escapeName(str, charsToEscape) {
      var lastIdx = 0;
      var ret = "";
      for (var i = 0; i < str.length; i++) {
        if (charsToEscape.has(str.charCodeAt(i))) {
          ret += "".concat(str.slice(lastIdx, i), "\\").concat(str.charAt(i));
          lastIdx = i + 1;
        }
      }
      return ret.length > 0 ? ret + str.slice(lastIdx) : str;
    }
  }
});

// node_modules/css-what/lib/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/css-what/lib/commonjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = exports.parse = exports.isTraversal = void 0;
    __exportStar(require_types(), exports);
    var parse_1 = require_parse();
    Object.defineProperty(exports, "isTraversal", { enumerable: true, get: function() {
      return parse_1.isTraversal;
    } });
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_1.parse;
    } });
    var stringify_1 = require_stringify2();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_1.stringify;
    } });
  }
});

// node_modules/css-select/lib/sort.js
var require_sort = __commonJS({
  "node_modules/css-select/lib/sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTraversal = void 0;
    var css_what_1 = require_commonjs();
    var procedure = /* @__PURE__ */ new Map([
      [css_what_1.SelectorType.Universal, 50],
      [css_what_1.SelectorType.Tag, 30],
      [css_what_1.SelectorType.Attribute, 1],
      [css_what_1.SelectorType.Pseudo, 0]
    ]);
    function isTraversal(token) {
      return !procedure.has(token.type);
    }
    exports.isTraversal = isTraversal;
    var attributes = /* @__PURE__ */ new Map([
      [css_what_1.AttributeAction.Exists, 10],
      [css_what_1.AttributeAction.Equals, 8],
      [css_what_1.AttributeAction.Not, 7],
      [css_what_1.AttributeAction.Start, 6],
      [css_what_1.AttributeAction.End, 6],
      [css_what_1.AttributeAction.Any, 5]
    ]);
    function sortByProcedure(arr) {
      var procs = arr.map(getProcedure);
      for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
          continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
          var token = arr[j + 1];
          arr[j + 1] = arr[j];
          arr[j] = token;
          procs[j + 1] = procs[j];
          procs[j] = procNew;
        }
      }
    }
    exports.default = sortByProcedure;
    function getProcedure(token) {
      var _a, _b;
      var proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;
      if (token.type === css_what_1.SelectorType.Attribute) {
        proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
        if (token.action === css_what_1.AttributeAction.Equals && token.name === "id") {
          proc = 9;
        }
        if (token.ignoreCase) {
          proc >>= 1;
        }
      } else if (token.type === css_what_1.SelectorType.Pseudo) {
        if (!token.data) {
          proc = 3;
        } else if (token.name === "has" || token.name === "contains") {
          proc = 0;
        } else if (Array.isArray(token.data)) {
          proc = Math.min.apply(Math, token.data.map(function(d) {
            return Math.min.apply(Math, d.map(getProcedure));
          }));
          if (proc < 0) {
            proc = 0;
          }
        } else {
          proc = 2;
        }
      }
      return proc;
    }
  }
});

// node_modules/css-select/lib/attributes.js
var require_attributes2 = __commonJS({
  "node_modules/css-select/lib/attributes.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeRules = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
    function escapeRegex(value) {
      return value.replace(reChars, "\\$&");
    }
    var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
      "accept",
      "accept-charset",
      "align",
      "alink",
      "axis",
      "bgcolor",
      "charset",
      "checked",
      "clear",
      "codetype",
      "color",
      "compact",
      "declare",
      "defer",
      "dir",
      "direction",
      "disabled",
      "enctype",
      "face",
      "frame",
      "hreflang",
      "http-equiv",
      "lang",
      "language",
      "link",
      "media",
      "method",
      "multiple",
      "nohref",
      "noresize",
      "noshade",
      "nowrap",
      "readonly",
      "rel",
      "rev",
      "rules",
      "scope",
      "scrolling",
      "selected",
      "shape",
      "target",
      "text",
      "type",
      "valign",
      "valuetype",
      "vlink"
    ]);
    function shouldIgnoreCase(selector, options) {
      return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
    }
    exports.attributeRules = {
      equals: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
      },
      hyphen: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function hyphenIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function hyphen(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
        };
      },
      element: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (/\s/.test(value)) {
          return boolbase_1.default.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
        return function element(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
        };
      },
      exists: function(next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function(elem) {
          return adapter.hasAttrib(elem, name) && next(elem);
        };
      },
      start: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) && next(elem);
        };
      },
      end: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var _a;
            return ((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) && next(elem);
        };
      },
      any: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          var regex_1 = new RegExp(escapeRegex(value), "i");
          return function anyIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= value.length && regex_1.test(attr) && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) && next(elem);
        };
      },
      not: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
          return function(elem) {
            return !!adapter.getAttributeValue(elem, name) && next(elem);
          };
        } else if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
      }
    };
  }
});

// node_modules/nth-check/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/nth-check/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
    var ZERO = "0".charCodeAt(0);
    var NINE = "9".charCodeAt(0);
    function parse(formula) {
      formula = formula.trim().toLowerCase();
      if (formula === "even") {
        return [2, 0];
      } else if (formula === "odd") {
        return [2, 1];
      }
      var idx = 0;
      var a = 0;
      var sign = readSign();
      var number = readNumber();
      if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
          sign = readSign();
          skipWhitespace();
          number = readNumber();
        } else {
          sign = number = 0;
        }
      }
      if (number === null || idx < formula.length) {
        throw new Error("n-th rule couldn't be parsed ('" + formula + "')");
      }
      return [a, sign * number];
      function readSign() {
        if (formula.charAt(idx) === "-") {
          idx++;
          return -1;
        }
        if (formula.charAt(idx) === "+") {
          idx++;
        }
        return 1;
      }
      function readNumber() {
        var start = idx;
        var value = 0;
        while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
          value = value * 10 + (formula.charCodeAt(idx) - ZERO);
          idx++;
        }
        return idx === start ? null : value;
      }
      function skipWhitespace() {
        while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
          idx++;
        }
      }
    }
    exports.parse = parse;
  }
});

// node_modules/nth-check/lib/compile.js
var require_compile = __commonJS({
  "node_modules/nth-check/lib/compile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compile = void 0;
    var boolbase_1 = require_boolbase();
    function compile(parsed) {
      var a = parsed[0];
      var b = parsed[1] - 1;
      if (b < 0 && a <= 0)
        return boolbase_1.falseFunc;
      if (a === -1)
        return function(index) {
          return index <= b;
        };
      if (a === 0)
        return function(index) {
          return index === b;
        };
      if (a === 1)
        return b < 0 ? boolbase_1.trueFunc : function(index) {
          return index >= b;
        };
      var absA = Math.abs(a);
      var bMod = (b % absA + absA) % absA;
      return a > 1 ? function(index) {
        return index >= b && index % absA === bMod;
      } : function(index) {
        return index <= b && index % absA === bMod;
      };
    }
    exports.compile = compile;
  }
});

// node_modules/nth-check/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/nth-check/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compile = exports.parse = void 0;
    var parse_1 = require_parse2();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_1.parse;
    } });
    var compile_1 = require_compile();
    Object.defineProperty(exports, "compile", { enumerable: true, get: function() {
      return compile_1.compile;
    } });
    function nthCheck(formula) {
      return (0, compile_1.compile)((0, parse_1.parse)(formula));
    }
    exports.default = nthCheck;
  }
});

// node_modules/css-select/lib/pseudo-selectors/filters.js
var require_filters = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/filters.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filters = void 0;
    var nth_check_1 = __importDefault(require_lib7());
    var boolbase_1 = __importDefault(require_boolbase());
    function getChildFunc(next, adapter) {
      return function(elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
      };
    }
    exports.filters = {
      contains: function(next, text, _a) {
        var adapter = _a.adapter;
        return function contains(elem) {
          return next(elem) && adapter.getText(elem).includes(text);
        };
      },
      icontains: function(next, text, _a) {
        var adapter = _a.adapter;
        var itext = text.toLowerCase();
        return function icontains(elem) {
          return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
        };
      },
      "nth-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = 0; i < siblings.length; i++) {
            if (equals(elem, siblings[i]))
              break;
            if (adapter.isTag(siblings[i])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i]))
              break;
            if (adapter.isTag(siblings[i])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      root: function(next, _rule, _a) {
        var adapter = _a.adapter;
        return function(elem) {
          var parent = adapter.getParent(elem);
          return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
      },
      scope: function(next, rule, options, context) {
        var equals = options.equals;
        if (!context || context.length === 0) {
          return exports.filters["root"](next, rule, options);
        }
        if (context.length === 1) {
          return function(elem) {
            return equals(context[0], elem) && next(elem);
          };
        }
        return function(elem) {
          return context.includes(elem) && next(elem);
        };
      },
      hover: dynamicStatePseudo("isHovered"),
      visited: dynamicStatePseudo("isVisited"),
      active: dynamicStatePseudo("isActive")
    };
    function dynamicStatePseudo(name) {
      return function dynamicPseudo(next, _rule, _a) {
        var adapter = _a.adapter;
        var func = adapter[name];
        if (typeof func !== "function") {
          return boolbase_1.default.falseFunc;
        }
        return function active(elem) {
          return func(elem) && next(elem);
        };
      };
    }
  }
});

// node_modules/css-select/lib/pseudo-selectors/pseudos.js
var require_pseudos = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/pseudos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyPseudoArgs = exports.pseudos = void 0;
    exports.pseudos = {
      empty: function(elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function(elem2) {
          return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
        });
      },
      "first-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        if (adapter.prevElementSibling) {
          return adapter.prevElementSibling(elem) == null;
        }
        var firstChild = adapter.getSiblings(elem).find(function(elem2) {
          return adapter.isTag(elem2);
        });
        return firstChild != null && equals(elem, firstChild);
      },
      "last-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
          if (equals(elem, siblings[i]))
            return true;
          if (adapter.isTag(siblings[i]))
            break;
        }
        return false;
      },
      "first-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = 0; i < siblings.length; i++) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "last-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "only-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
        });
      },
      "only-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling);
        });
      }
    };
    function verifyPseudoArgs(func, name, subselect, argIndex) {
      if (subselect === null) {
        if (func.length > argIndex) {
          throw new Error("Pseudo-class :".concat(name, " requires an argument"));
        }
      } else if (func.length === argIndex) {
        throw new Error("Pseudo-class :".concat(name, " doesn't have any arguments"));
      }
    }
    exports.verifyPseudoArgs = verifyPseudoArgs;
  }
});

// node_modules/css-select/lib/pseudo-selectors/aliases.js
var require_aliases = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliases = void 0;
    exports.aliases = {
      "any-link": ":is(a, area, link)[href]",
      link: ":any-link:not(:visited)",
      disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
      enabled: ":not(:disabled)",
      checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
      required: ":is(input, select, textarea)[required]",
      optional: ":is(input, select, textarea):not([required])",
      selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
      checkbox: "[type=checkbox]",
      file: "[type=file]",
      password: "[type=password]",
      radio: "[type=radio]",
      reset: "[type=reset]",
      image: "[type=image]",
      submit: "[type=submit]",
      parent: ":not(:empty)",
      header: ":is(h1, h2, h3, h4, h5, h6)",
      button: ":is(button, input[type=button])",
      input: ":is(input, textarea, select, button)",
      text: "input:is(:not([type!='']), [type=text])"
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/subselects.js
var require_subselects = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/subselects.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = require_sort();
    exports.PLACEHOLDER_ELEMENT = {};
    function ensureIsTag(next, adapter) {
      if (next === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      return function(elem) {
        return adapter.isTag(elem) && next(elem);
      };
    }
    exports.ensureIsTag = ensureIsTag;
    function getNextSiblings(elem, adapter) {
      var siblings = adapter.getSiblings(elem);
      if (siblings.length <= 1)
        return [];
      var elemIndex = siblings.indexOf(elem);
      if (elemIndex < 0 || elemIndex === siblings.length - 1)
        return [];
      return siblings.slice(elemIndex + 1).filter(adapter.isTag);
    }
    exports.getNextSiblings = getNextSiblings;
    function copyOptions(options) {
      return {
        xmlMode: !!options.xmlMode,
        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
        lowerCaseTags: !!options.lowerCaseTags,
        quirksMode: !!options.quirksMode,
        cacheResults: !!options.cacheResults,
        pseudos: options.pseudos,
        adapter: options.adapter,
        equals: options.equals
      };
    }
    var is = function(next, token, options, context, compileToken) {
      var func = compileToken(token, copyOptions(options), context);
      return func === boolbase_1.default.trueFunc ? next : func === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : function(elem) {
        return func(elem) && next(elem);
      };
    };
    exports.subselects = {
      is,
      matches: is,
      where: is,
      not: function(next, token, options, context, compileToken) {
        var func = compileToken(token, copyOptions(options), context);
        return func === boolbase_1.default.falseFunc ? next : func === boolbase_1.default.trueFunc ? boolbase_1.default.falseFunc : function(elem) {
          return !func(elem) && next(elem);
        };
      },
      has: function(next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = copyOptions(options);
        opts.relativeSelector = true;
        var context = subselect.some(function(s) {
          return s.some(sort_js_1.isTraversal);
        }) ? [exports.PLACEHOLDER_ELEMENT] : void 0;
        var compiled = compileToken(subselect, opts, context);
        if (compiled === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        var hasElement = ensureIsTag(compiled, adapter);
        if (context && compiled !== boolbase_1.default.trueFunc) {
          var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings_1 = _a === void 0 ? false : _a;
          return function(elem) {
            if (!next(elem))
              return false;
            context[0] = elem;
            var childs = adapter.getChildren(elem);
            var nextElements = shouldTestNextSiblings_1 ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
            return adapter.existsOne(hasElement, nextElements);
          };
        }
        return function(elem) {
          return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
        };
      }
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/index.js
var require_pseudo_selectors = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
    var css_what_1 = require_commonjs();
    var filters_js_1 = require_filters();
    Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
      return filters_js_1.filters;
    } });
    var pseudos_js_1 = require_pseudos();
    Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
      return pseudos_js_1.pseudos;
    } });
    var aliases_js_1 = require_aliases();
    Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
      return aliases_js_1.aliases;
    } });
    var subselects_js_1 = require_subselects();
    function compilePseudoSelector(next, selector, options, context, compileToken) {
      var _a;
      var name = selector.name, data = selector.data;
      if (Array.isArray(data)) {
        if (!(name in subselects_js_1.subselects)) {
          throw new Error("Unknown pseudo-class :".concat(name, "(").concat(data, ")"));
        }
        return subselects_js_1.subselects[name](next, data, options, context, compileToken);
      }
      var userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];
      var stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases_js_1.aliases[name];
      if (typeof stringPseudo === "string") {
        if (data != null) {
          throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
        }
        var alias = (0, css_what_1.parse)(stringPseudo);
        return subselects_js_1.subselects["is"](next, alias, options, context, compileToken);
      }
      if (typeof userPseudo === "function") {
        (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name, data, 1);
        return function(elem) {
          return userPseudo(elem, data) && next(elem);
        };
      }
      if (name in filters_js_1.filters) {
        return filters_js_1.filters[name](next, data, options, context);
      }
      if (name in pseudos_js_1.pseudos) {
        var pseudo_1 = pseudos_js_1.pseudos[name];
        (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name, data, 2);
        return function(elem) {
          return pseudo_1(elem, options, data) && next(elem);
        };
      }
      throw new Error("Unknown pseudo-class :".concat(name));
    }
    exports.compilePseudoSelector = compilePseudoSelector;
  }
});

// node_modules/css-select/lib/general.js
var require_general = __commonJS({
  "node_modules/css-select/lib/general.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileGeneralSelector = void 0;
    var attributes_js_1 = require_attributes2();
    var index_js_1 = require_pseudo_selectors();
    var css_what_1 = require_commonjs();
    function getElementParent(node, adapter) {
      var parent = adapter.getParent(node);
      if (parent && adapter.isTag(parent)) {
        return parent;
      }
      return null;
    }
    function compileGeneralSelector(next, selector, options, context, compileToken) {
      var adapter = options.adapter, equals = options.equals;
      switch (selector.type) {
        case css_what_1.SelectorType.PseudoElement: {
          throw new Error("Pseudo-elements are not supported by css-select");
        }
        case css_what_1.SelectorType.ColumnCombinator: {
          throw new Error("Column combinators are not yet supported by css-select");
        }
        case css_what_1.SelectorType.Attribute: {
          if (selector.namespace != null) {
            throw new Error("Namespaced attributes are not yet supported by css-select");
          }
          if (!options.xmlMode || options.lowerCaseAttributeNames) {
            selector.name = selector.name.toLowerCase();
          }
          return attributes_js_1.attributeRules[selector.action](next, selector, options);
        }
        case css_what_1.SelectorType.Pseudo: {
          return (0, index_js_1.compilePseudoSelector)(next, selector, options, context, compileToken);
        }
        case css_what_1.SelectorType.Tag: {
          if (selector.namespace != null) {
            throw new Error("Namespaced tag names are not yet supported by css-select");
          }
          var name_1 = selector.name;
          if (!options.xmlMode || options.lowerCaseTags) {
            name_1 = name_1.toLowerCase();
          }
          return function tag(elem) {
            return adapter.getName(elem) === name_1 && next(elem);
          };
        }
        case css_what_1.SelectorType.Descendant: {
          if (options.cacheResults === false || typeof WeakSet === "undefined") {
            return function descendant(elem) {
              var current = elem;
              while (current = getElementParent(current, adapter)) {
                if (next(current)) {
                  return true;
                }
              }
              return false;
            };
          }
          var isFalseCache_1 = /* @__PURE__ */ new WeakSet();
          return function cachedDescendant(elem) {
            var current = elem;
            while (current = getElementParent(current, adapter)) {
              if (!isFalseCache_1.has(current)) {
                if (adapter.isTag(current) && next(current)) {
                  return true;
                }
                isFalseCache_1.add(current);
              }
            }
            return false;
          };
        }
        case "_flexibleDescendant": {
          return function flexibleDescendant(elem) {
            var current = elem;
            do {
              if (next(current))
                return true;
            } while (current = getElementParent(current, adapter));
            return false;
          };
        }
        case css_what_1.SelectorType.Parent: {
          return function parent(elem) {
            return adapter.getChildren(elem).some(function(elem2) {
              return adapter.isTag(elem2) && next(elem2);
            });
          };
        }
        case css_what_1.SelectorType.Child: {
          return function child(elem) {
            var parent = adapter.getParent(elem);
            return parent != null && adapter.isTag(parent) && next(parent);
          };
        }
        case css_what_1.SelectorType.Sibling: {
          return function sibling(elem) {
            var siblings = adapter.getSiblings(elem);
            for (var i = 0; i < siblings.length; i++) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling) && next(currentSibling)) {
                return true;
              }
            }
            return false;
          };
        }
        case css_what_1.SelectorType.Adjacent: {
          if (adapter.prevElementSibling) {
            return function adjacent(elem) {
              var previous = adapter.prevElementSibling(elem);
              return previous != null && next(previous);
            };
          }
          return function adjacent(elem) {
            var siblings = adapter.getSiblings(elem);
            var lastElement;
            for (var i = 0; i < siblings.length; i++) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling)) {
                lastElement = currentSibling;
              }
            }
            return !!lastElement && next(lastElement);
          };
        }
        case css_what_1.SelectorType.Universal: {
          if (selector.namespace != null && selector.namespace !== "*") {
            throw new Error("Namespaced universal selectors are not yet supported by css-select");
          }
          return next;
        }
      }
    }
    exports.compileGeneralSelector = compileGeneralSelector;
  }
});

// node_modules/css-select/lib/compile.js
var require_compile2 = __commonJS({
  "node_modules/css-select/lib/compile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileToken = exports.compileUnsafe = exports.compile = void 0;
    var css_what_1 = require_commonjs();
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = __importStar(require_sort());
    var general_js_1 = require_general();
    var subselects_js_1 = require_subselects();
    function compile(selector, options, context) {
      var next = compileUnsafe(selector, options, context);
      return (0, subselects_js_1.ensureIsTag)(next, options.adapter);
    }
    exports.compile = compile;
    function compileUnsafe(selector, options, context) {
      var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
      return compileToken(token, options, context);
    }
    exports.compileUnsafe = compileUnsafe;
    function includesScopePseudo(t) {
      return t.type === css_what_1.SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some(function(data) {
        return data.some(includesScopePseudo);
      }));
    }
    var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
    var FLEXIBLE_DESCENDANT_TOKEN = {
      type: "_flexibleDescendant"
    };
    var SCOPE_TOKEN = {
      type: css_what_1.SelectorType.Pseudo,
      name: "scope",
      data: null
    };
    function absolutize(token, _a, context) {
      var adapter = _a.adapter;
      var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function(e) {
        var parent = adapter.isTag(e) && adapter.getParent(e);
        return e === subselects_js_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
      }));
      for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t = token_1[_i];
        if (t.length > 0 && (0, sort_js_1.isTraversal)(t[0]) && t[0].type !== css_what_1.SelectorType.Descendant) {
        } else if (hasContext && !t.some(includesScopePseudo)) {
          t.unshift(DESCENDANT_TOKEN);
        } else {
          continue;
        }
        t.unshift(SCOPE_TOKEN);
      }
    }
    function compileToken(token, options, context) {
      var _a;
      token.forEach(sort_js_1.default);
      context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
      var isArrayContext = Array.isArray(context);
      var finalContext = context && (Array.isArray(context) ? context : [context]);
      if (options.relativeSelector !== false) {
        absolutize(token, options, finalContext);
      } else if (token.some(function(t) {
        return t.length > 0 && (0, sort_js_1.isTraversal)(t[0]);
      })) {
        throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
      }
      var shouldTestNextSiblings = false;
      var query = token.map(function(rules) {
        if (rules.length >= 2) {
          var first = rules[0], second = rules[1];
          if (first.type !== css_what_1.SelectorType.Pseudo || first.name !== "scope") {
          } else if (isArrayContext && second.type === css_what_1.SelectorType.Descendant) {
            rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
          } else if (second.type === css_what_1.SelectorType.Adjacent || second.type === css_what_1.SelectorType.Sibling) {
            shouldTestNextSiblings = true;
          }
        }
        return compileRules(rules, options, finalContext);
      }).reduce(reduceRules, boolbase_1.default.falseFunc);
      query.shouldTestNextSiblings = shouldTestNextSiblings;
      return query;
    }
    exports.compileToken = compileToken;
    function compileRules(rules, options, context) {
      var _a;
      return rules.reduce(function(previous, rule) {
        return previous === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : (0, general_js_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
      }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.default.trueFunc);
    }
    function reduceRules(a, b) {
      if (b === boolbase_1.default.falseFunc || a === boolbase_1.default.trueFunc) {
        return a;
      }
      if (a === boolbase_1.default.falseFunc || b === boolbase_1.default.trueFunc) {
        return b;
      }
      return function combine(elem) {
        return a(elem) || b(elem);
      };
    }
  }
});

// node_modules/css-select/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/css-select/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
    var DomUtils = __importStar(require_lib5());
    var boolbase_1 = __importDefault(require_boolbase());
    var compile_js_1 = require_compile2();
    var subselects_js_1 = require_subselects();
    var defaultEquals = function(a, b) {
      return a === b;
    };
    var defaultOptions = {
      adapter: DomUtils,
      equals: defaultEquals
    };
    function convertOptionFormats(options) {
      var _a, _b, _c, _d;
      var opts = options !== null && options !== void 0 ? options : defaultOptions;
      (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;
      (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
      return opts;
    }
    function wrapCompile(func) {
      return function addAdapter(selector, options, context) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context);
      };
    }
    exports.compile = wrapCompile(compile_js_1.compile);
    exports._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
    exports._compileToken = wrapCompile(compile_js_1.compileToken);
    function getSelectorFunc(searchFunc) {
      return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
          query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
        }
        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
      };
    }
    function prepareContext(elems, adapter, shouldTestNextSiblings) {
      if (shouldTestNextSiblings === void 0) {
        shouldTestNextSiblings = false;
      }
      if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
      }
      return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
    }
    exports.prepareContext = prepareContext;
    function appendNextSiblings(elem, adapter) {
      var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
      var elemsLength = elems.length;
      for (var i = 0; i < elemsLength; i++) {
        var nextSiblings = (0, subselects_js_1.getNextSiblings)(elems[i], adapter);
        elems.push.apply(elems, nextSiblings);
      }
      return elems;
    }
    exports.selectAll = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
    });
    exports.selectOne = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
    });
    function is(elem, query, options) {
      var opts = convertOptionFormats(options);
      return (typeof query === "function" ? query : (0, compile_js_1.compile)(query, opts))(elem);
    }
    exports.is = is;
    exports.default = exports.selectAll;
    var index_js_1 = require_pseudo_selectors();
    Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
      return index_js_1.filters;
    } });
    Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
      return index_js_1.pseudos;
    } });
    Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
      return index_js_1.aliases;
    } });
  }
});

// node_modules/linkedom/cjs/shared/matches.js
var require_matches = __commonJS({
  "node_modules/linkedom/cjs/shared/matches.js"(exports) {
    "use strict";
    var CSSselect = require_lib8();
    var { ELEMENT_NODE, TEXT_NODE } = require_constants();
    var { ignoreCase } = require_utils();
    var { isArray } = Array;
    var isTag = ({ nodeType }) => nodeType === ELEMENT_NODE;
    var existsOne = (test, elements) => elements.some((element) => isTag(element) && (test(element) || existsOne(test, getChildren(element))));
    var getAttributeValue = (element, name) => name === "class" ? element.classList.value : element.getAttribute(name);
    var getChildren = ({ childNodes }) => childNodes;
    var getName = (element) => {
      const { localName } = element;
      return ignoreCase(element) ? localName.toLowerCase() : localName;
    };
    var getParent = ({ parentNode }) => parentNode;
    var getSiblings = (element) => {
      const { parentNode } = element;
      return parentNode ? getChildren(parentNode) : element;
    };
    var getText = (node) => {
      if (isArray(node))
        return node.map(getText).join("");
      if (isTag(node))
        return getText(getChildren(node));
      if (node.nodeType === TEXT_NODE)
        return node.data;
      return "";
    };
    var hasAttrib = (element, name) => element.hasAttribute(name);
    var removeSubsets = (nodes) => {
      let { length } = nodes;
      while (length--) {
        const node = nodes[length];
        if (length && -1 < nodes.lastIndexOf(node, length - 1)) {
          nodes.splice(length, 1);
          continue;
        }
        for (let { parentNode } = node; parentNode; parentNode = parentNode.parentNode) {
          if (nodes.includes(parentNode)) {
            nodes.splice(length, 1);
            break;
          }
        }
      }
      return nodes;
    };
    var findAll = (test, nodes) => {
      const matches2 = [];
      for (const node of nodes) {
        if (isTag(node)) {
          if (test(node))
            matches2.push(node);
          matches2.push(...findAll(test, getChildren(node)));
        }
      }
      return matches2;
    };
    var findOne = (test, nodes) => {
      for (let node of nodes)
        if (test(node) || (node = findOne(test, getChildren(node))))
          return node;
      return null;
    };
    var adapter = {
      isTag,
      existsOne,
      getAttributeValue,
      getChildren,
      getName,
      getParent,
      getSiblings,
      getText,
      hasAttrib,
      removeSubsets,
      findAll,
      findOne
    };
    var prepareMatch = (element, selectors) => {
      return CSSselect.compile(selectors, {
        xmlMode: !ignoreCase(element),
        adapter
      });
    };
    exports.prepareMatch = prepareMatch;
    var matches = (element, selectors) => {
      return CSSselect.is(element, selectors, {
        strict: true,
        xmlMode: !ignoreCase(element),
        adapter
      });
    };
    exports.matches = matches;
  }
});

// node_modules/linkedom/cjs/shared/text-escaper.js
var require_text_escaper = __commonJS({
  "node_modules/linkedom/cjs/shared/text-escaper.js"(exports) {
    "use strict";
    var { replace } = "";
    var ca = /[<>&\xA0]/g;
    var esca = {
      "\xA0": "&nbsp;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    var pe = (m) => esca[m];
    var escape = (es) => replace.call(es, ca, pe);
    exports.escape = escape;
  }
});

// node_modules/linkedom/cjs/interface/text.js
var require_text = __commonJS({
  "node_modules/linkedom/cjs/interface/text.js"(exports) {
    "use strict";
    var { TEXT_NODE } = require_constants();
    var { VALUE } = require_symbols();
    var { escape } = require_text_escaper();
    var { CharacterData: CharacterData2 } = require_character_data();
    var Text = class extends CharacterData2 {
      constructor(ownerDocument, data = "") {
        super(ownerDocument, "#text", TEXT_NODE, data);
      }
      get wholeText() {
        const text = [];
        let { previousSibling, nextSibling } = this;
        while (previousSibling) {
          if (previousSibling.nodeType === TEXT_NODE)
            text.unshift(previousSibling[VALUE]);
          else
            break;
          previousSibling = previousSibling.previousSibling;
        }
        text.push(this[VALUE]);
        while (nextSibling) {
          if (nextSibling.nodeType === TEXT_NODE)
            text.push(nextSibling[VALUE]);
          else
            break;
          nextSibling = nextSibling.nextSibling;
        }
        return text.join("");
      }
      cloneNode() {
        const { ownerDocument, [VALUE]: data } = this;
        return new Text(ownerDocument, data);
      }
      toString() {
        return escape(this[VALUE]);
      }
    };
    exports.Text = Text;
  }
});

// node_modules/linkedom/cjs/mixin/parent-node.js
var require_parent_node = __commonJS({
  "node_modules/linkedom/cjs/mixin/parent-node.js"(exports) {
    "use strict";
    var {
      ATTRIBUTE_NODE,
      DOCUMENT_FRAGMENT_NODE,
      ELEMENT_NODE,
      TEXT_NODE,
      NODE_END,
      COMMENT_NODE
    } = require_constants();
    var { PRIVATE, END, NEXT, PREV, START, VALUE } = require_symbols();
    var { prepareMatch } = require_matches();
    var { previousSibling, nextSibling } = require_node3();
    var { getEnd, knownAdjacent, knownBoundaries, knownSegment, knownSiblings, localCase } = require_utils();
    var { Node } = require_node2();
    var { Text } = require_text();
    var { NodeList } = require_node_list();
    var { moCallback } = require_mutation_observer();
    var { connectedCallback } = require_custom_element_registry();
    var { nextElementSibling } = require_non_document_type_child_node();
    var isNode = (node) => node instanceof Node;
    var insert = (parentNode, child, nodes) => {
      const { ownerDocument } = parentNode;
      for (const node of nodes)
        parentNode.insertBefore(isNode(node) ? node : new Text(ownerDocument, node), child);
    };
    var ParentNode = class extends Node {
      constructor(ownerDocument, localName, nodeType) {
        super(ownerDocument, localName, nodeType);
        this[PRIVATE] = null;
        this[NEXT] = this[END] = {
          [NEXT]: null,
          [PREV]: this,
          [START]: this,
          nodeType: NODE_END,
          ownerDocument: this.ownerDocument,
          parentNode: null
        };
      }
      get childNodes() {
        const childNodes = new NodeList();
        let { firstChild } = this;
        while (firstChild) {
          childNodes.push(firstChild);
          firstChild = nextSibling(firstChild);
        }
        return childNodes;
      }
      get children() {
        const children = new NodeList();
        let { firstElementChild } = this;
        while (firstElementChild) {
          children.push(firstElementChild);
          firstElementChild = nextElementSibling(firstElementChild);
        }
        return children;
      }
      get firstChild() {
        let { [NEXT]: next, [END]: end } = this;
        while (next.nodeType === ATTRIBUTE_NODE)
          next = next[NEXT];
        return next === end ? null : next;
      }
      get firstElementChild() {
        let { firstChild } = this;
        while (firstChild) {
          if (firstChild.nodeType === ELEMENT_NODE)
            return firstChild;
          firstChild = nextSibling(firstChild);
        }
        return null;
      }
      get lastChild() {
        const prev = this[END][PREV];
        switch (prev.nodeType) {
          case NODE_END:
            return prev[START];
          case ATTRIBUTE_NODE:
            return null;
        }
        return prev === this ? null : prev;
      }
      get lastElementChild() {
        let { lastChild } = this;
        while (lastChild) {
          if (lastChild.nodeType === ELEMENT_NODE)
            return lastChild;
          lastChild = previousSibling(lastChild);
        }
        return null;
      }
      get childElementCount() {
        return this.children.length;
      }
      prepend(...nodes) {
        insert(this, this.firstChild, nodes);
      }
      append(...nodes) {
        insert(this, this[END], nodes);
      }
      replaceChildren(...nodes) {
        let { [NEXT]: next, [END]: end } = this;
        while (next !== end && next.nodeType === ATTRIBUTE_NODE)
          next = next[NEXT];
        while (next !== end) {
          const after = getEnd(next)[NEXT];
          next.remove();
          next = after;
        }
        if (nodes.length)
          insert(this, end, nodes);
      }
      getElementsByClassName(className) {
        const elements = new NodeList();
        let { [NEXT]: next, [END]: end } = this;
        while (next !== end) {
          if (next.nodeType === ELEMENT_NODE && next.hasAttribute("class") && next.classList.has(className))
            elements.push(next);
          next = next[NEXT];
        }
        return elements;
      }
      getElementsByTagName(tagName) {
        const elements = new NodeList();
        let { [NEXT]: next, [END]: end } = this;
        while (next !== end) {
          if (next.nodeType === ELEMENT_NODE && (next.localName === tagName || localCase(next) === tagName))
            elements.push(next);
          next = next[NEXT];
        }
        return elements;
      }
      querySelector(selectors) {
        const matches = prepareMatch(this, selectors);
        let { [NEXT]: next, [END]: end } = this;
        while (next !== end) {
          if (next.nodeType === ELEMENT_NODE && matches(next))
            return next;
          next = next[NEXT];
        }
        return null;
      }
      querySelectorAll(selectors) {
        const matches = prepareMatch(this, selectors);
        const elements = new NodeList();
        let { [NEXT]: next, [END]: end } = this;
        while (next !== end) {
          if (next.nodeType === ELEMENT_NODE && matches(next))
            elements.push(next);
          next = next[NEXT];
        }
        return elements;
      }
      appendChild(node) {
        return this.insertBefore(node, this[END]);
      }
      contains(node) {
        let parentNode = node;
        while (parentNode && parentNode !== this)
          parentNode = parentNode.parentNode;
        return parentNode === this;
      }
      insertBefore(node, before = null) {
        if (node === before)
          return node;
        if (node === this)
          throw new Error("unable to append a node to itself");
        const next = before || this[END];
        switch (node.nodeType) {
          case ELEMENT_NODE:
            node.remove();
            node.parentNode = this;
            knownBoundaries(next[PREV], node, next);
            moCallback(node, null);
            connectedCallback(node);
            break;
          case DOCUMENT_FRAGMENT_NODE: {
            let { [PRIVATE]: parentNode, firstChild, lastChild } = node;
            if (firstChild) {
              knownSegment(next[PREV], firstChild, lastChild, next);
              knownAdjacent(node, node[END]);
              if (parentNode)
                parentNode.replaceChildren();
              do {
                firstChild.parentNode = this;
                moCallback(firstChild, null);
                if (firstChild.nodeType === ELEMENT_NODE)
                  connectedCallback(firstChild);
              } while (firstChild !== lastChild && (firstChild = nextSibling(firstChild)));
            }
            break;
          }
          case TEXT_NODE:
          case COMMENT_NODE:
            node.remove();
          default:
            node.parentNode = this;
            knownSiblings(next[PREV], node, next);
            moCallback(node, null);
            break;
        }
        return node;
      }
      normalize() {
        let { [NEXT]: next, [END]: end } = this;
        while (next !== end) {
          const { [NEXT]: $next, [PREV]: $prev, nodeType } = next;
          if (nodeType === TEXT_NODE) {
            if (!next[VALUE])
              next.remove();
            else if ($prev && $prev.nodeType === TEXT_NODE) {
              $prev.textContent += next.textContent;
              next.remove();
            }
          }
          next = $next;
        }
      }
      removeChild(node) {
        if (node.parentNode !== this)
          throw new Error("node is not a child");
        node.remove();
        return node;
      }
      replaceChild(node, replaced) {
        const next = getEnd(replaced)[NEXT];
        replaced.remove();
        this.insertBefore(node, next);
        return replaced;
      }
    };
    exports.ParentNode = ParentNode;
  }
});

// node_modules/linkedom/cjs/mixin/non-element-parent-node.js
var require_non_element_parent_node = __commonJS({
  "node_modules/linkedom/cjs/mixin/non-element-parent-node.js"(exports) {
    "use strict";
    var { ELEMENT_NODE } = require_constants();
    var { END, NEXT } = require_symbols();
    var { nonElementAsJSON } = require_jsdon();
    var { ParentNode } = require_parent_node();
    var NonElementParentNode = class extends ParentNode {
      getElementById(id) {
        let { [NEXT]: next, [END]: end } = this;
        while (next !== end) {
          if (next.nodeType === ELEMENT_NODE && next.id === id)
            return next;
          next = next[NEXT];
        }
        return null;
      }
      cloneNode(deep) {
        const { ownerDocument, constructor } = this;
        const nonEPN = new constructor(ownerDocument);
        if (deep) {
          const { [END]: end } = nonEPN;
          for (const node of this.childNodes)
            nonEPN.insertBefore(node.cloneNode(deep), end);
        }
        return nonEPN;
      }
      toString() {
        const { childNodes, localName } = this;
        return `<${localName}>${childNodes.join("")}</${localName}>`;
      }
      toJSON() {
        const json = [];
        nonElementAsJSON(this, json);
        return json;
      }
    };
    exports.NonElementParentNode = NonElementParentNode;
  }
});

// node_modules/linkedom/cjs/interface/document-fragment.js
var require_document_fragment = __commonJS({
  "node_modules/linkedom/cjs/interface/document-fragment.js"(exports) {
    "use strict";
    var { DOCUMENT_FRAGMENT_NODE } = require_constants();
    var { NonElementParentNode } = require_non_element_parent_node();
    var DocumentFragment = class extends NonElementParentNode {
      constructor(ownerDocument) {
        super(ownerDocument, "#document-fragment", DOCUMENT_FRAGMENT_NODE);
      }
    };
    exports.DocumentFragment = DocumentFragment;
  }
});

// node_modules/linkedom/cjs/interface/document-type.js
var require_document_type = __commonJS({
  "node_modules/linkedom/cjs/interface/document-type.js"(exports) {
    "use strict";
    var { DOCUMENT_TYPE_NODE } = require_constants();
    var { documentTypeAsJSON } = require_jsdon();
    var { Node } = require_node2();
    var DocumentType2 = class extends Node {
      constructor(ownerDocument, name, publicId = "", systemId = "") {
        super(ownerDocument, "#document-type", DOCUMENT_TYPE_NODE);
        this.name = name;
        this.publicId = publicId;
        this.systemId = systemId;
      }
      cloneNode() {
        const { ownerDocument, name, publicId, systemId } = this;
        return new DocumentType2(ownerDocument, name, publicId, systemId);
      }
      toString() {
        const { name, publicId, systemId } = this;
        const hasPublic = 0 < publicId.length;
        const str = [name];
        if (hasPublic)
          str.push("PUBLIC", `"${publicId}"`);
        if (systemId.length) {
          if (!hasPublic)
            str.push("SYSTEM");
          str.push(`"${systemId}"`);
        }
        return `<!DOCTYPE ${str.join(" ")}>`;
      }
      toJSON() {
        const json = [];
        documentTypeAsJSON(this, json);
        return json;
      }
    };
    exports.DocumentType = DocumentType2;
  }
});

// node_modules/linkedom/cjs/mixin/inner-html.js
var require_inner_html = __commonJS({
  "node_modules/linkedom/cjs/mixin/inner-html.js"(exports) {
    "use strict";
    var { CUSTOM_ELEMENTS } = require_symbols();
    var { parseFromString } = require_parse_from_string();
    var { ignoreCase } = require_utils();
    var getInnerHtml = (node) => node.childNodes.join("");
    exports.getInnerHtml = getInnerHtml;
    var setInnerHtml = (node, html) => {
      const { ownerDocument } = node;
      const { constructor } = ownerDocument;
      const document2 = new constructor();
      document2[CUSTOM_ELEMENTS] = ownerDocument[CUSTOM_ELEMENTS];
      const { childNodes } = parseFromString(document2, ignoreCase(node), html);
      node.replaceChildren(...childNodes);
    };
    exports.setInnerHtml = setInnerHtml;
  }
});

// node_modules/uhyphen/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/uhyphen/cjs/index.js"(exports, module) {
    "use strict";
    module.exports = (camel) => camel.replace(/(([A-Z0-9])([A-Z0-9][a-z]))|(([a-z])([A-Z]))/g, "$2$5-$3$6").toLowerCase();
  }
});

// node_modules/linkedom/cjs/dom/string-map.js
var require_string_map = __commonJS({
  "node_modules/linkedom/cjs/dom/string-map.js"(exports) {
    "use strict";
    var uhyphen = ((m) => m.__esModule ? m.default : m)(require_cjs());
    var { setPrototypeOf } = require_object();
    var refs = /* @__PURE__ */ new WeakMap();
    var key = (name) => `data-${uhyphen(name)}`;
    var prop = (name) => name.slice(5).replace(/-([a-z])/g, (_, $1) => $1.toUpperCase());
    var handler = {
      get(dataset, name) {
        if (name in dataset)
          return refs.get(dataset).getAttribute(key(name));
      },
      set(dataset, name, value) {
        dataset[name] = value;
        refs.get(dataset).setAttribute(key(name), value);
        return true;
      },
      deleteProperty(dataset, name) {
        if (name in dataset)
          refs.get(dataset).removeAttribute(key(name));
        return delete dataset[name];
      }
    };
    var DOMStringMap = class {
      constructor(ref) {
        for (const { name, value } of ref.attributes) {
          if (/^data-/.test(name))
            this[prop(name)] = value;
        }
        refs.set(this, ref);
        return new Proxy(this, handler);
      }
    };
    exports.DOMStringMap = DOMStringMap;
    setPrototypeOf(DOMStringMap.prototype, null);
  }
});

// node_modules/linkedom/cjs/dom/token-list.js
var require_token_list = __commonJS({
  "node_modules/linkedom/cjs/dom/token-list.js"(exports) {
    "use strict";
    var { OWNER_ELEMENT } = require_symbols();
    var { setAttribute } = require_attributes();
    var { Attr } = require_attr();
    var { add } = Set.prototype;
    var addTokens = (self, tokens) => {
      for (const token of tokens) {
        if (token)
          add.call(self, token);
      }
    };
    var update = ({ [OWNER_ELEMENT]: ownerElement, value }) => {
      const attribute = ownerElement.getAttributeNode("class");
      if (attribute)
        attribute.value = value;
      else
        setAttribute(ownerElement, new Attr(ownerElement.ownerDocument, "class", value));
    };
    var DOMTokenList = class extends Set {
      constructor(ownerElement) {
        super();
        this[OWNER_ELEMENT] = ownerElement;
        const attribute = ownerElement.getAttributeNode("class");
        if (attribute)
          addTokens(this, attribute.value.split(/\s+/));
      }
      get length() {
        return this.size;
      }
      get value() {
        return [...this].join(" ");
      }
      add(...tokens) {
        addTokens(this, tokens);
        update(this);
      }
      contains(token) {
        return this.has(token);
      }
      remove(...tokens) {
        for (const token of tokens)
          this.delete(token);
        update(this);
      }
      toggle(token, force) {
        if (this.has(token)) {
          if (force)
            return true;
          this.delete(token);
          update(this);
        } else if (force || arguments.length === 1) {
          super.add(token);
          update(this);
          return true;
        }
        return false;
      }
      replace(token, newToken) {
        if (this.has(token)) {
          this.delete(token);
          super.add(newToken);
          update(this);
          return true;
        }
        return false;
      }
      supports() {
        return true;
      }
    };
    exports.DOMTokenList = DOMTokenList;
  }
});

// node_modules/linkedom/cjs/interface/css-style-declaration.js
var require_css_style_declaration = __commonJS({
  "node_modules/linkedom/cjs/interface/css-style-declaration.js"(exports) {
    "use strict";
    var uhyphen = ((m) => m.__esModule ? m.default : m)(require_cjs());
    var { CHANGED, PRIVATE, VALUE } = require_symbols();
    var refs = /* @__PURE__ */ new WeakMap();
    var getKeys = (style) => [...style.keys()].filter((key) => key !== PRIVATE);
    var updateKeys = (style) => {
      const attr = refs.get(style).getAttributeNode("style");
      if (!attr || attr[CHANGED] || style.get(PRIVATE) !== attr) {
        style.clear();
        if (attr) {
          style.set(PRIVATE, attr);
          for (const rule of attr[VALUE].split(/\s*;\s*/)) {
            let [key, ...rest] = rule.split(":");
            if (rest.length > 0) {
              key = key.trim();
              const value = rest.join(":").trim();
              if (key && value)
                style.set(key, value);
            }
          }
        }
      }
      return attr;
    };
    var handler = {
      get(style, name) {
        if (name in prototype)
          return style[name];
        updateKeys(style);
        if (name === "length")
          return getKeys(style).length;
        if (/^\d+$/.test(name))
          return getKeys(style)[name];
        return style.get(uhyphen(name));
      },
      set(style, name, value) {
        if (name === "cssText")
          style[name] = value;
        else {
          let attr = updateKeys(style);
          if (value == null)
            style.delete(uhyphen(name));
          else
            style.set(uhyphen(name), value);
          if (!attr) {
            const element = refs.get(style);
            attr = element.ownerDocument.createAttribute("style");
            element.setAttributeNode(attr);
            style.set(PRIVATE, attr);
          }
          attr[CHANGED] = false;
          attr[VALUE] = style.toString();
        }
        return true;
      }
    };
    var CSSStyleDeclaration = class extends Map {
      constructor(element) {
        super();
        refs.set(this, element);
        return new Proxy(this, handler);
      }
      get cssText() {
        return this.toString();
      }
      set cssText(value) {
        refs.get(this).setAttribute("style", value);
      }
      getPropertyValue(name) {
        const self = this[PRIVATE];
        return handler.get(self, name);
      }
      setProperty(name, value) {
        const self = this[PRIVATE];
        handler.set(self, name, value);
      }
      removeProperty(name) {
        const self = this[PRIVATE];
        handler.set(self, name, null);
      }
      [Symbol.iterator]() {
        const keys = getKeys(this[PRIVATE]);
        const { length } = keys;
        let i = 0;
        return {
          next() {
            const done = i === length;
            return { done, value: done ? null : keys[i++] };
          }
        };
      }
      get [PRIVATE]() {
        return this;
      }
      toString() {
        const self = this[PRIVATE];
        updateKeys(self);
        const cssText = [];
        self.forEach(push, cssText);
        return cssText.join(";");
      }
    };
    exports.CSSStyleDeclaration = CSSStyleDeclaration;
    var { prototype } = CSSStyleDeclaration;
    function push(value, key) {
      if (key !== PRIVATE)
        this.push(`${key}:${value}`);
    }
  }
});

// node_modules/linkedom/cjs/interface/event.js
var require_event = __commonJS({
  "node_modules/linkedom/cjs/interface/event.js"(exports) {
    "use strict";
    var BUBBLING_PHASE = 3;
    var AT_TARGET = 2;
    var CAPTURING_PHASE = 1;
    var NONE = 0;
    var GlobalEvent = class {
      static get BUBBLING_PHASE() {
        return BUBBLING_PHASE;
      }
      static get AT_TARGET() {
        return AT_TARGET;
      }
      static get CAPTURING_PHASE() {
        return CAPTURING_PHASE;
      }
      static get NONE() {
        return NONE;
      }
      constructor(type, eventInitDict = {}) {
        this.type = type;
        this.bubbles = !!eventInitDict.bubbles;
        this.cancelBubble = false;
        this._stopImmediatePropagationFlag = false;
        this.cancelable = !!eventInitDict.cancelable;
        this.eventPhase = this.NONE;
        this.timeStamp = Date.now();
        this.defaultPrevented = false;
        this.originalTarget = null;
        this.returnValue = null;
        this.srcElement = null;
        this.target = null;
        this._path = [];
      }
      get BUBBLING_PHASE() {
        return BUBBLING_PHASE;
      }
      get AT_TARGET() {
        return AT_TARGET;
      }
      get CAPTURING_PHASE() {
        return CAPTURING_PHASE;
      }
      get NONE() {
        return NONE;
      }
      preventDefault() {
        this.defaultPrevented = true;
      }
      composedPath() {
        return this._path;
      }
      stopPropagation() {
        this.cancelBubble = true;
      }
      stopImmediatePropagation() {
        this.stopPropagation();
        this._stopImmediatePropagationFlag = true;
      }
    };
    exports.Event = GlobalEvent;
  }
});

// node_modules/linkedom/cjs/interface/named-node-map.js
var require_named_node_map = __commonJS({
  "node_modules/linkedom/cjs/interface/named-node-map.js"(exports) {
    "use strict";
    var NamedNodeMap = class extends Array {
      constructor(ownerElement) {
        super();
        this.ownerElement = ownerElement;
      }
      getNamedItem(name) {
        return this.ownerElement.getAttributeNode(name);
      }
      setNamedItem(attr) {
        this.ownerElement.setAttributeNode(attr);
        this.unshift(attr);
      }
      removeNamedItem(name) {
        const item = this.getNamedItem(name);
        this.ownerElement.removeAttribute(name);
        this.splice(this.indexOf(item), 1);
      }
      item(index) {
        return index < this.length ? this[index] : null;
      }
      getNamedItemNS(_, name) {
        return this.getNamedItem(name);
      }
      setNamedItemNS(_, attr) {
        return this.setNamedItem(attr);
      }
      removeNamedItemNS(_, name) {
        return this.removeNamedItem(name);
      }
    };
    exports.NamedNodeMap = NamedNodeMap;
  }
});

// node_modules/linkedom/cjs/interface/shadow-root.js
var require_shadow_root = __commonJS({
  "node_modules/linkedom/cjs/interface/shadow-root.js"(exports) {
    "use strict";
    var { DOCUMENT_FRAGMENT_NODE } = require_constants();
    var { getInnerHtml, setInnerHtml } = require_inner_html();
    var { NonElementParentNode } = require_non_element_parent_node();
    var ShadowRoot = class extends NonElementParentNode {
      constructor(host) {
        super(host.ownerDocument, "#shadow-root", DOCUMENT_FRAGMENT_NODE);
        this.host = host;
      }
      get innerHTML() {
        return getInnerHtml(this);
      }
      set innerHTML(html) {
        setInnerHtml(this, html);
      }
    };
    exports.ShadowRoot = ShadowRoot;
  }
});

// node_modules/linkedom/cjs/interface/element.js
var require_element = __commonJS({
  "node_modules/linkedom/cjs/interface/element.js"(exports) {
    "use strict";
    var {
      ATTRIBUTE_NODE,
      BLOCK_ELEMENTS,
      COMMENT_NODE,
      ELEMENT_NODE,
      NODE_END,
      TEXT_NODE,
      SVG_NAMESPACE
    } = require_constants();
    var {
      setAttribute,
      removeAttribute,
      numericAttribute,
      stringAttribute
    } = require_attributes();
    var {
      CLASS_LIST,
      DATASET,
      STYLE,
      END,
      NEXT,
      PREV,
      START,
      MIME
    } = require_symbols();
    var {
      ignoreCase,
      knownAdjacent,
      localCase
    } = require_utils();
    var { elementAsJSON } = require_jsdon();
    var { matches, prepareMatch } = require_matches();
    var { shadowRoots } = require_shadow_roots();
    var { isConnected, parentElement, previousSibling, nextSibling } = require_node3();
    var { previousElementSibling, nextElementSibling } = require_non_document_type_child_node();
    var { before, after, replaceWith, remove } = require_child_node();
    var { getInnerHtml, setInnerHtml } = require_inner_html();
    var { ParentNode } = require_parent_node();
    var { DOMStringMap } = require_string_map();
    var { DOMTokenList } = require_token_list();
    var { CSSStyleDeclaration } = require_css_style_declaration();
    var { Event } = require_event();
    var { NamedNodeMap } = require_named_node_map();
    var { ShadowRoot } = require_shadow_root();
    var { NodeList } = require_node_list();
    var { Attr } = require_attr();
    var { Text } = require_text();
    var attributesHandler = {
      get(target, key) {
        return key in target ? target[key] : target.find(({ name }) => name === key);
      }
    };
    var create = (ownerDocument, element, localName) => {
      if ("ownerSVGElement" in element) {
        const svg = ownerDocument.createElementNS(SVG_NAMESPACE, localName);
        svg.ownerSVGElement = element.ownerSVGElement;
        return svg;
      }
      return ownerDocument.createElement(localName);
    };
    var isVoid = ({ localName, ownerDocument }) => {
      return ownerDocument[MIME].voidElements.test(localName);
    };
    var Element2 = class extends ParentNode {
      constructor(ownerDocument, localName) {
        super(ownerDocument, localName, ELEMENT_NODE);
        this[CLASS_LIST] = null;
        this[DATASET] = null;
        this[STYLE] = null;
      }
      get isConnected() {
        return isConnected(this);
      }
      get parentElement() {
        return parentElement(this);
      }
      get previousSibling() {
        return previousSibling(this);
      }
      get nextSibling() {
        return nextSibling(this);
      }
      get previousElementSibling() {
        return previousElementSibling(this);
      }
      get nextElementSibling() {
        return nextElementSibling(this);
      }
      before(...nodes) {
        before(this, nodes);
      }
      after(...nodes) {
        after(this, nodes);
      }
      replaceWith(...nodes) {
        replaceWith(this, nodes);
      }
      remove() {
        remove(this[PREV], this, this[END][NEXT]);
      }
      get id() {
        return stringAttribute.get(this, "id");
      }
      set id(value) {
        stringAttribute.set(this, "id", value);
      }
      get className() {
        return this.classList.value;
      }
      set className(value) {
        const { classList } = this;
        classList.clear();
        classList.add(...value.split(/\s+/));
      }
      get nodeName() {
        return localCase(this);
      }
      get tagName() {
        return localCase(this);
      }
      get classList() {
        return this[CLASS_LIST] || (this[CLASS_LIST] = new DOMTokenList(this));
      }
      get dataset() {
        return this[DATASET] || (this[DATASET] = new DOMStringMap(this));
      }
      get nonce() {
        return stringAttribute.get(this, "nonce");
      }
      set nonce(value) {
        stringAttribute.set(this, "nonce", value);
      }
      get style() {
        return this[STYLE] || (this[STYLE] = new CSSStyleDeclaration(this));
      }
      get tabIndex() {
        return numericAttribute.get(this, "tabindex") || -1;
      }
      set tabIndex(value) {
        numericAttribute.set(this, "tabindex", value);
      }
      get innerText() {
        const text = [];
        let { [NEXT]: next, [END]: end } = this;
        while (next !== end) {
          if (next.nodeType === TEXT_NODE) {
            text.push(next.textContent.replace(/\s+/g, " "));
          } else if (text.length && next[NEXT] != end && BLOCK_ELEMENTS.has(next.tagName)) {
            text.push("\n");
          }
          next = next[NEXT];
        }
        return text.join("");
      }
      get textContent() {
        const text = [];
        let { [NEXT]: next, [END]: end } = this;
        while (next !== end) {
          if (next.nodeType === TEXT_NODE)
            text.push(next.textContent);
          next = next[NEXT];
        }
        return text.join("");
      }
      set textContent(text) {
        this.replaceChildren();
        if (text)
          this.appendChild(new Text(this.ownerDocument, text));
      }
      get innerHTML() {
        return getInnerHtml(this);
      }
      set innerHTML(html) {
        setInnerHtml(this, html);
      }
      get outerHTML() {
        return this.toString();
      }
      set outerHTML(html) {
        const template = this.ownerDocument.createElement("");
        template.innerHTML = html;
        this.replaceWith(...template.childNodes);
      }
      get attributes() {
        const attributes = new NamedNodeMap(this);
        let next = this[NEXT];
        while (next.nodeType === ATTRIBUTE_NODE) {
          attributes.push(next);
          next = next[NEXT];
        }
        return new Proxy(attributes, attributesHandler);
      }
      focus() {
        this.dispatchEvent(new Event("focus"));
      }
      getAttribute(name) {
        if (name === "class")
          return this.className;
        const attribute = this.getAttributeNode(name);
        return attribute && attribute.value;
      }
      getAttributeNode(name) {
        let next = this[NEXT];
        while (next.nodeType === ATTRIBUTE_NODE) {
          if (next.name === name)
            return next;
          next = next[NEXT];
        }
        return null;
      }
      getAttributeNames() {
        const attributes = new NodeList();
        let next = this[NEXT];
        while (next.nodeType === ATTRIBUTE_NODE) {
          attributes.push(next.name);
          next = next[NEXT];
        }
        return attributes;
      }
      hasAttribute(name) {
        return !!this.getAttributeNode(name);
      }
      hasAttributes() {
        return this[NEXT].nodeType === ATTRIBUTE_NODE;
      }
      removeAttribute(name) {
        if (name === "class" && this[CLASS_LIST])
          this[CLASS_LIST].clear();
        let next = this[NEXT];
        while (next.nodeType === ATTRIBUTE_NODE) {
          if (next.name === name) {
            removeAttribute(this, next);
            return;
          }
          next = next[NEXT];
        }
      }
      removeAttributeNode(attribute) {
        let next = this[NEXT];
        while (next.nodeType === ATTRIBUTE_NODE) {
          if (next === attribute) {
            removeAttribute(this, next);
            return;
          }
          next = next[NEXT];
        }
      }
      setAttribute(name, value) {
        if (name === "class")
          this.className = value;
        else {
          const attribute = this.getAttributeNode(name);
          if (attribute)
            attribute.value = value;
          else
            setAttribute(this, new Attr(this.ownerDocument, name, value));
        }
      }
      setAttributeNode(attribute) {
        const { name } = attribute;
        const previously = this.getAttributeNode(name);
        if (previously !== attribute) {
          if (previously)
            this.removeAttributeNode(previously);
          const { ownerElement } = attribute;
          if (ownerElement)
            ownerElement.removeAttributeNode(attribute);
          setAttribute(this, attribute);
        }
        return previously;
      }
      toggleAttribute(name, force) {
        if (this.hasAttribute(name)) {
          if (!force) {
            this.removeAttribute(name);
            return false;
          }
          return true;
        } else if (force || arguments.length === 1) {
          this.setAttribute(name, "");
          return true;
        }
        return false;
      }
      get shadowRoot() {
        if (shadowRoots.has(this)) {
          const { mode, shadowRoot } = shadowRoots.get(this);
          if (mode === "open")
            return shadowRoot;
        }
        return null;
      }
      attachShadow(init) {
        if (shadowRoots.has(this))
          throw new Error("operation not supported");
        const shadowRoot = new ShadowRoot(this);
        shadowRoot.append(...this.childNodes);
        shadowRoots.set(this, {
          mode: init.mode,
          shadowRoot
        });
        return shadowRoot;
      }
      matches(selectors) {
        return matches(this, selectors);
      }
      closest(selectors) {
        let parentElement2 = this;
        const matches2 = prepareMatch(parentElement2, selectors);
        while (parentElement2 && !matches2(parentElement2))
          parentElement2 = parentElement2.parentElement;
        return parentElement2;
      }
      insertAdjacentElement(position, element) {
        const { parentElement: parentElement2 } = this;
        switch (position) {
          case "beforebegin":
            if (parentElement2) {
              parentElement2.insertBefore(element, this);
              break;
            }
            return null;
          case "afterbegin":
            this.insertBefore(element, this.firstChild);
            break;
          case "beforeend":
            this.insertBefore(element, null);
            break;
          case "afterend":
            if (parentElement2) {
              parentElement2.insertBefore(element, this.nextSibling);
              break;
            }
            return null;
        }
        return element;
      }
      insertAdjacentHTML(position, html) {
        const template = this.ownerDocument.createElement("template");
        template.innerHTML = html;
        this.insertAdjacentElement(position, template.content);
      }
      insertAdjacentText(position, text) {
        const node = this.ownerDocument.createTextNode(text);
        this.insertAdjacentElement(position, node);
      }
      cloneNode(deep = false) {
        const { ownerDocument, localName } = this;
        const addNext = (next2) => {
          next2.parentNode = parentNode;
          knownAdjacent($next, next2);
          $next = next2;
        };
        const clone = create(ownerDocument, this, localName);
        let parentNode = clone, $next = clone;
        let { [NEXT]: next, [END]: prev } = this;
        while (next !== prev && (deep || next.nodeType === ATTRIBUTE_NODE)) {
          switch (next.nodeType) {
            case NODE_END:
              knownAdjacent($next, parentNode[END]);
              $next = parentNode[END];
              parentNode = parentNode.parentNode;
              break;
            case ELEMENT_NODE: {
              const node = create(ownerDocument, next, next.localName);
              addNext(node);
              parentNode = node;
              break;
            }
            case ATTRIBUTE_NODE:
            case TEXT_NODE:
            case COMMENT_NODE:
              addNext(next.cloneNode(deep));
              break;
          }
          next = next[NEXT];
        }
        knownAdjacent($next, clone[END]);
        return clone;
      }
      toString() {
        const out = [];
        const { [END]: end } = this;
        let next = { [NEXT]: this };
        let isOpened = false;
        do {
          next = next[NEXT];
          switch (next.nodeType) {
            case ATTRIBUTE_NODE: {
              const attr = " " + next;
              switch (attr) {
                case " id":
                case " class":
                case " style":
                  break;
                default:
                  out.push(attr);
              }
              break;
            }
            case NODE_END: {
              const start = next[START];
              if (isOpened) {
                if ("ownerSVGElement" in start)
                  out.push(" />");
                else if (isVoid(start))
                  out.push(ignoreCase(start) ? ">" : " />");
                else
                  out.push(`></${start.localName}>`);
                isOpened = false;
              } else
                out.push(`</${start.localName}>`);
              break;
            }
            case ELEMENT_NODE:
              if (isOpened)
                out.push(">");
              if (next.toString !== this.toString) {
                out.push(next.toString());
                next = next[END];
                isOpened = false;
              } else {
                out.push(`<${next.localName}`);
                isOpened = true;
              }
              break;
            case TEXT_NODE:
            case COMMENT_NODE:
              out.push((isOpened ? ">" : "") + next);
              isOpened = false;
              break;
          }
        } while (next !== end);
        return out.join("");
      }
      toJSON() {
        const json = [];
        elementAsJSON(this, json);
        return json;
      }
      getAttributeNS(_, name) {
        return this.getAttribute(name);
      }
      getElementsByTagNameNS(_, name) {
        return this.getElementsByTagName(name);
      }
      hasAttributeNS(_, name) {
        return this.hasAttribute(name);
      }
      removeAttributeNS(_, name) {
        this.removeAttribute(name);
      }
      setAttributeNS(_, name, value) {
        this.setAttribute(name, value);
      }
      setAttributeNodeNS(attr) {
        return this.setAttributeNode(attr);
      }
    };
    exports.Element = Element2;
  }
});

// node_modules/linkedom/cjs/svg/element.js
var require_element2 = __commonJS({
  "node_modules/linkedom/cjs/svg/element.js"(exports) {
    "use strict";
    var { Element: Element2 } = require_element();
    var classNames = /* @__PURE__ */ new WeakMap();
    var handler = {
      get(target, name) {
        return target[name];
      },
      set(target, name, value) {
        target[name] = value;
        return true;
      }
    };
    var SVGElement = class extends Element2 {
      constructor(ownerDocument, localName, ownerSVGElement = null) {
        super(ownerDocument, localName);
        this.ownerSVGElement = ownerSVGElement;
      }
      get className() {
        if (!classNames.has(this))
          classNames.set(this, new Proxy({ baseVal: "", animVal: "" }, handler));
        return classNames.get(this);
      }
      set className(value) {
        const { classList } = this;
        classList.clear();
        classList.add(...value.split(/\s+/));
      }
      getAttribute(name) {
        return name === "class" ? [...this.classList].join(" ") : super.getAttribute(name);
      }
      setAttribute(name, value) {
        if (name === "class")
          this.className = value;
        else if (name === "style") {
          const { className } = this;
          className.baseVal = className.animVal = value;
        }
        super.setAttribute(name, value);
      }
    };
    exports.SVGElement = SVGElement;
  }
});

// node_modules/linkedom/cjs/shared/facades.js
var require_facades = __commonJS({
  "node_modules/linkedom/cjs/shared/facades.js"(exports) {
    "use strict";
    var { Attr: _Attr } = require_attr();
    var { CharacterData: _CharacterData } = require_character_data();
    var { Comment: _Comment } = require_comment();
    var { DocumentFragment: _DocumentFragment } = require_document_fragment();
    var { DocumentType: _DocumentType } = require_document_type();
    var { Element: _Element } = require_element();
    var { Node: _Node } = require_node2();
    var { ShadowRoot: _ShadowRoot } = require_shadow_root();
    var { Text: _Text } = require_text();
    var { SVGElement: _SVGElement } = require_element2();
    var { setPrototypeOf } = require_object();
    var illegalConstructor = () => {
      throw new TypeError("Illegal constructor");
    };
    exports.illegalConstructor = illegalConstructor;
    function Attr() {
      illegalConstructor();
    }
    exports.Attr = Attr;
    setPrototypeOf(Attr, _Attr);
    Attr.prototype = _Attr.prototype;
    function CharacterData2() {
      illegalConstructor();
    }
    exports.CharacterData = CharacterData2;
    setPrototypeOf(CharacterData2, _CharacterData);
    CharacterData2.prototype = _CharacterData.prototype;
    function Comment() {
      illegalConstructor();
    }
    exports.Comment = Comment;
    setPrototypeOf(Comment, _Comment);
    Comment.prototype = _Comment.prototype;
    function DocumentFragment() {
      illegalConstructor();
    }
    exports.DocumentFragment = DocumentFragment;
    setPrototypeOf(DocumentFragment, _DocumentFragment);
    DocumentFragment.prototype = _DocumentFragment.prototype;
    function DocumentType2() {
      illegalConstructor();
    }
    exports.DocumentType = DocumentType2;
    setPrototypeOf(DocumentType2, _DocumentType);
    DocumentType2.prototype = _DocumentType.prototype;
    function Element2() {
      illegalConstructor();
    }
    exports.Element = Element2;
    setPrototypeOf(Element2, _Element);
    Element2.prototype = _Element.prototype;
    function Node() {
      illegalConstructor();
    }
    exports.Node = Node;
    setPrototypeOf(Node, _Node);
    Node.prototype = _Node.prototype;
    function ShadowRoot() {
      illegalConstructor();
    }
    exports.ShadowRoot = ShadowRoot;
    setPrototypeOf(ShadowRoot, _ShadowRoot);
    ShadowRoot.prototype = _ShadowRoot.prototype;
    function Text() {
      illegalConstructor();
    }
    exports.Text = Text;
    setPrototypeOf(Text, _Text);
    Text.prototype = _Text.prototype;
    function SVGElement() {
      illegalConstructor();
    }
    exports.SVGElement = SVGElement;
    setPrototypeOf(SVGElement, _SVGElement);
    SVGElement.prototype = _SVGElement.prototype;
    var Facades = {
      Attr,
      CharacterData: CharacterData2,
      Comment,
      DocumentFragment,
      DocumentType: DocumentType2,
      Element: Element2,
      Node,
      ShadowRoot,
      Text,
      SVGElement
    };
    exports.Facades = Facades;
  }
});

// node_modules/linkedom/cjs/html/element.js
var require_element3 = __commonJS({
  "node_modules/linkedom/cjs/html/element.js"(exports) {
    "use strict";
    var { END, UPGRADE } = require_symbols();
    var { booleanAttribute, stringAttribute } = require_attributes();
    var { Event } = require_event();
    var { Element: Element2 } = require_element();
    var { Classes, customElements } = require_custom_element_registry();
    var Level0 = /* @__PURE__ */ new WeakMap();
    var level0 = {
      get(element, name) {
        return Level0.has(element) && Level0.get(element)[name] || null;
      },
      set(element, name, value) {
        if (!Level0.has(element))
          Level0.set(element, {});
        const handlers = Level0.get(element);
        const type = name.slice(2);
        if (handlers[name])
          element.removeEventListener(type, handlers[name], false);
        if (handlers[name] = value)
          element.addEventListener(type, value, false);
      }
    };
    var HTMLElement = class extends Element2 {
      static get observedAttributes() {
        return [];
      }
      constructor(ownerDocument = null, localName = "") {
        super(ownerDocument, localName);
        const ownerLess = !ownerDocument;
        let options;
        if (ownerLess) {
          const { constructor: Class } = this;
          if (!Classes.has(Class))
            throw new Error("unable to initialize this Custom Element");
          ({ ownerDocument, localName, options } = Classes.get(Class));
        }
        if (ownerDocument[UPGRADE]) {
          const { element, values } = ownerDocument[UPGRADE];
          ownerDocument[UPGRADE] = null;
          for (const [key, value] of values)
            element[key] = value;
          return element;
        }
        if (ownerLess) {
          this.ownerDocument = this[END].ownerDocument = ownerDocument;
          this.localName = localName;
          customElements.set(this, { connected: false });
          if (options.is)
            this.setAttribute("is", options.is);
        }
      }
      blur() {
        this.dispatchEvent(new Event("blur"));
      }
      click() {
        this.dispatchEvent(new Event("click"));
      }
      get accessKeyLabel() {
        const { accessKey } = this;
        return accessKey && `Alt+Shift+${accessKey}`;
      }
      get isContentEditable() {
        return this.hasAttribute("contenteditable");
      }
      get contentEditable() {
        return booleanAttribute.get(this, "contenteditable");
      }
      set contentEditable(value) {
        booleanAttribute.set(this, "contenteditable", value);
      }
      get draggable() {
        return booleanAttribute.get(this, "draggable");
      }
      set draggable(value) {
        booleanAttribute.set(this, "draggable", value);
      }
      get hidden() {
        return booleanAttribute.get(this, "hidden");
      }
      set hidden(value) {
        booleanAttribute.set(this, "hidden", value);
      }
      get spellcheck() {
        return booleanAttribute.get(this, "spellcheck");
      }
      set spellcheck(value) {
        booleanAttribute.set(this, "spellcheck", value);
      }
      get accessKey() {
        return stringAttribute.get(this, "accesskey");
      }
      set accessKey(value) {
        stringAttribute.set(this, "accesskey", value);
      }
      get dir() {
        return stringAttribute.get(this, "dir");
      }
      set dir(value) {
        stringAttribute.set(this, "dir", value);
      }
      get lang() {
        return stringAttribute.get(this, "lang");
      }
      set lang(value) {
        stringAttribute.set(this, "lang", value);
      }
      get title() {
        return stringAttribute.get(this, "title");
      }
      set title(value) {
        stringAttribute.set(this, "title", value);
      }
      get onabort() {
        return level0.get(this, "onabort");
      }
      set onabort(value) {
        level0.set(this, "onabort", value);
      }
      get onblur() {
        return level0.get(this, "onblur");
      }
      set onblur(value) {
        level0.set(this, "onblur", value);
      }
      get oncancel() {
        return level0.get(this, "oncancel");
      }
      set oncancel(value) {
        level0.set(this, "oncancel", value);
      }
      get oncanplay() {
        return level0.get(this, "oncanplay");
      }
      set oncanplay(value) {
        level0.set(this, "oncanplay", value);
      }
      get oncanplaythrough() {
        return level0.get(this, "oncanplaythrough");
      }
      set oncanplaythrough(value) {
        level0.set(this, "oncanplaythrough", value);
      }
      get onchange() {
        return level0.get(this, "onchange");
      }
      set onchange(value) {
        level0.set(this, "onchange", value);
      }
      get onclick() {
        return level0.get(this, "onclick");
      }
      set onclick(value) {
        level0.set(this, "onclick", value);
      }
      get onclose() {
        return level0.get(this, "onclose");
      }
      set onclose(value) {
        level0.set(this, "onclose", value);
      }
      get oncontextmenu() {
        return level0.get(this, "oncontextmenu");
      }
      set oncontextmenu(value) {
        level0.set(this, "oncontextmenu", value);
      }
      get oncuechange() {
        return level0.get(this, "oncuechange");
      }
      set oncuechange(value) {
        level0.set(this, "oncuechange", value);
      }
      get ondblclick() {
        return level0.get(this, "ondblclick");
      }
      set ondblclick(value) {
        level0.set(this, "ondblclick", value);
      }
      get ondrag() {
        return level0.get(this, "ondrag");
      }
      set ondrag(value) {
        level0.set(this, "ondrag", value);
      }
      get ondragend() {
        return level0.get(this, "ondragend");
      }
      set ondragend(value) {
        level0.set(this, "ondragend", value);
      }
      get ondragenter() {
        return level0.get(this, "ondragenter");
      }
      set ondragenter(value) {
        level0.set(this, "ondragenter", value);
      }
      get ondragleave() {
        return level0.get(this, "ondragleave");
      }
      set ondragleave(value) {
        level0.set(this, "ondragleave", value);
      }
      get ondragover() {
        return level0.get(this, "ondragover");
      }
      set ondragover(value) {
        level0.set(this, "ondragover", value);
      }
      get ondragstart() {
        return level0.get(this, "ondragstart");
      }
      set ondragstart(value) {
        level0.set(this, "ondragstart", value);
      }
      get ondrop() {
        return level0.get(this, "ondrop");
      }
      set ondrop(value) {
        level0.set(this, "ondrop", value);
      }
      get ondurationchange() {
        return level0.get(this, "ondurationchange");
      }
      set ondurationchange(value) {
        level0.set(this, "ondurationchange", value);
      }
      get onemptied() {
        return level0.get(this, "onemptied");
      }
      set onemptied(value) {
        level0.set(this, "onemptied", value);
      }
      get onended() {
        return level0.get(this, "onended");
      }
      set onended(value) {
        level0.set(this, "onended", value);
      }
      get onerror() {
        return level0.get(this, "onerror");
      }
      set onerror(value) {
        level0.set(this, "onerror", value);
      }
      get onfocus() {
        return level0.get(this, "onfocus");
      }
      set onfocus(value) {
        level0.set(this, "onfocus", value);
      }
      get oninput() {
        return level0.get(this, "oninput");
      }
      set oninput(value) {
        level0.set(this, "oninput", value);
      }
      get oninvalid() {
        return level0.get(this, "oninvalid");
      }
      set oninvalid(value) {
        level0.set(this, "oninvalid", value);
      }
      get onkeydown() {
        return level0.get(this, "onkeydown");
      }
      set onkeydown(value) {
        level0.set(this, "onkeydown", value);
      }
      get onkeypress() {
        return level0.get(this, "onkeypress");
      }
      set onkeypress(value) {
        level0.set(this, "onkeypress", value);
      }
      get onkeyup() {
        return level0.get(this, "onkeyup");
      }
      set onkeyup(value) {
        level0.set(this, "onkeyup", value);
      }
      get onload() {
        return level0.get(this, "onload");
      }
      set onload(value) {
        level0.set(this, "onload", value);
      }
      get onloadeddata() {
        return level0.get(this, "onloadeddata");
      }
      set onloadeddata(value) {
        level0.set(this, "onloadeddata", value);
      }
      get onloadedmetadata() {
        return level0.get(this, "onloadedmetadata");
      }
      set onloadedmetadata(value) {
        level0.set(this, "onloadedmetadata", value);
      }
      get onloadstart() {
        return level0.get(this, "onloadstart");
      }
      set onloadstart(value) {
        level0.set(this, "onloadstart", value);
      }
      get onmousedown() {
        return level0.get(this, "onmousedown");
      }
      set onmousedown(value) {
        level0.set(this, "onmousedown", value);
      }
      get onmouseenter() {
        return level0.get(this, "onmouseenter");
      }
      set onmouseenter(value) {
        level0.set(this, "onmouseenter", value);
      }
      get onmouseleave() {
        return level0.get(this, "onmouseleave");
      }
      set onmouseleave(value) {
        level0.set(this, "onmouseleave", value);
      }
      get onmousemove() {
        return level0.get(this, "onmousemove");
      }
      set onmousemove(value) {
        level0.set(this, "onmousemove", value);
      }
      get onmouseout() {
        return level0.get(this, "onmouseout");
      }
      set onmouseout(value) {
        level0.set(this, "onmouseout", value);
      }
      get onmouseover() {
        return level0.get(this, "onmouseover");
      }
      set onmouseover(value) {
        level0.set(this, "onmouseover", value);
      }
      get onmouseup() {
        return level0.get(this, "onmouseup");
      }
      set onmouseup(value) {
        level0.set(this, "onmouseup", value);
      }
      get onmousewheel() {
        return level0.get(this, "onmousewheel");
      }
      set onmousewheel(value) {
        level0.set(this, "onmousewheel", value);
      }
      get onpause() {
        return level0.get(this, "onpause");
      }
      set onpause(value) {
        level0.set(this, "onpause", value);
      }
      get onplay() {
        return level0.get(this, "onplay");
      }
      set onplay(value) {
        level0.set(this, "onplay", value);
      }
      get onplaying() {
        return level0.get(this, "onplaying");
      }
      set onplaying(value) {
        level0.set(this, "onplaying", value);
      }
      get onprogress() {
        return level0.get(this, "onprogress");
      }
      set onprogress(value) {
        level0.set(this, "onprogress", value);
      }
      get onratechange() {
        return level0.get(this, "onratechange");
      }
      set onratechange(value) {
        level0.set(this, "onratechange", value);
      }
      get onreset() {
        return level0.get(this, "onreset");
      }
      set onreset(value) {
        level0.set(this, "onreset", value);
      }
      get onresize() {
        return level0.get(this, "onresize");
      }
      set onresize(value) {
        level0.set(this, "onresize", value);
      }
      get onscroll() {
        return level0.get(this, "onscroll");
      }
      set onscroll(value) {
        level0.set(this, "onscroll", value);
      }
      get onseeked() {
        return level0.get(this, "onseeked");
      }
      set onseeked(value) {
        level0.set(this, "onseeked", value);
      }
      get onseeking() {
        return level0.get(this, "onseeking");
      }
      set onseeking(value) {
        level0.set(this, "onseeking", value);
      }
      get onselect() {
        return level0.get(this, "onselect");
      }
      set onselect(value) {
        level0.set(this, "onselect", value);
      }
      get onshow() {
        return level0.get(this, "onshow");
      }
      set onshow(value) {
        level0.set(this, "onshow", value);
      }
      get onstalled() {
        return level0.get(this, "onstalled");
      }
      set onstalled(value) {
        level0.set(this, "onstalled", value);
      }
      get onsubmit() {
        return level0.get(this, "onsubmit");
      }
      set onsubmit(value) {
        level0.set(this, "onsubmit", value);
      }
      get onsuspend() {
        return level0.get(this, "onsuspend");
      }
      set onsuspend(value) {
        level0.set(this, "onsuspend", value);
      }
      get ontimeupdate() {
        return level0.get(this, "ontimeupdate");
      }
      set ontimeupdate(value) {
        level0.set(this, "ontimeupdate", value);
      }
      get ontoggle() {
        return level0.get(this, "ontoggle");
      }
      set ontoggle(value) {
        level0.set(this, "ontoggle", value);
      }
      get onvolumechange() {
        return level0.get(this, "onvolumechange");
      }
      set onvolumechange(value) {
        level0.set(this, "onvolumechange", value);
      }
      get onwaiting() {
        return level0.get(this, "onwaiting");
      }
      set onwaiting(value) {
        level0.set(this, "onwaiting", value);
      }
      get onauxclick() {
        return level0.get(this, "onauxclick");
      }
      set onauxclick(value) {
        level0.set(this, "onauxclick", value);
      }
      get ongotpointercapture() {
        return level0.get(this, "ongotpointercapture");
      }
      set ongotpointercapture(value) {
        level0.set(this, "ongotpointercapture", value);
      }
      get onlostpointercapture() {
        return level0.get(this, "onlostpointercapture");
      }
      set onlostpointercapture(value) {
        level0.set(this, "onlostpointercapture", value);
      }
      get onpointercancel() {
        return level0.get(this, "onpointercancel");
      }
      set onpointercancel(value) {
        level0.set(this, "onpointercancel", value);
      }
      get onpointerdown() {
        return level0.get(this, "onpointerdown");
      }
      set onpointerdown(value) {
        level0.set(this, "onpointerdown", value);
      }
      get onpointerenter() {
        return level0.get(this, "onpointerenter");
      }
      set onpointerenter(value) {
        level0.set(this, "onpointerenter", value);
      }
      get onpointerleave() {
        return level0.get(this, "onpointerleave");
      }
      set onpointerleave(value) {
        level0.set(this, "onpointerleave", value);
      }
      get onpointermove() {
        return level0.get(this, "onpointermove");
      }
      set onpointermove(value) {
        level0.set(this, "onpointermove", value);
      }
      get onpointerout() {
        return level0.get(this, "onpointerout");
      }
      set onpointerout(value) {
        level0.set(this, "onpointerout", value);
      }
      get onpointerover() {
        return level0.get(this, "onpointerover");
      }
      set onpointerover(value) {
        level0.set(this, "onpointerover", value);
      }
      get onpointerup() {
        return level0.get(this, "onpointerup");
      }
      set onpointerup(value) {
        level0.set(this, "onpointerup", value);
      }
    };
    exports.HTMLElement = HTMLElement;
  }
});

// node_modules/linkedom/cjs/html/template-element.js
var require_template_element = __commonJS({
  "node_modules/linkedom/cjs/html/template-element.js"(exports) {
    "use strict";
    var { CONTENT, PRIVATE } = require_symbols();
    var { registerHTMLClass } = require_register_html_class();
    var { HTMLElement } = require_element3();
    var tagName = "template";
    var HTMLTemplateElement = class extends HTMLElement {
      constructor(ownerDocument) {
        super(ownerDocument, tagName);
        const content = this.ownerDocument.createDocumentFragment();
        (this[CONTENT] = content)[PRIVATE] = this;
      }
      get content() {
        if (this.hasChildNodes() && !this[CONTENT].hasChildNodes()) {
          for (const node of this.childNodes)
            this[CONTENT].appendChild(node.cloneNode(true));
        }
        return this[CONTENT];
      }
    };
    registerHTMLClass(tagName, HTMLTemplateElement);
    exports.HTMLTemplateElement = HTMLTemplateElement;
  }
});

// node_modules/linkedom/cjs/html/html-element.js
var require_html_element = __commonJS({
  "node_modules/linkedom/cjs/html/html-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLHtmlElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "html") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLHtmlElement = HTMLHtmlElement;
  }
});

// node_modules/linkedom/cjs/html/text-element.js
var require_text_element = __commonJS({
  "node_modules/linkedom/cjs/html/text-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var { toString } = HTMLElement.prototype;
    var TextElement = class extends HTMLElement {
      get innerHTML() {
        return this.textContent;
      }
      set innerHTML(html) {
        this.textContent = html;
      }
      toString() {
        const outerHTML = toString.call(this.cloneNode());
        return outerHTML.replace(/></, `>${this.textContent}<`);
      }
    };
    exports.TextElement = TextElement;
  }
});

// node_modules/linkedom/cjs/html/script-element.js
var require_script_element = __commonJS({
  "node_modules/linkedom/cjs/html/script-element.js"(exports) {
    "use strict";
    var { registerHTMLClass } = require_register_html_class();
    var { TextElement } = require_text_element();
    var tagName = "script";
    var HTMLScriptElement = class extends TextElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
      }
    };
    registerHTMLClass(tagName, HTMLScriptElement);
    exports.HTMLScriptElement = HTMLScriptElement;
  }
});

// node_modules/linkedom/cjs/html/frame-element.js
var require_frame_element = __commonJS({
  "node_modules/linkedom/cjs/html/frame-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLFrameElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "frame") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLFrameElement = HTMLFrameElement;
  }
});

// node_modules/linkedom/cjs/html/i-frame-element.js
var require_i_frame_element = __commonJS({
  "node_modules/linkedom/cjs/html/i-frame-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLIFrameElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "iframe") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLIFrameElement = HTMLIFrameElement;
  }
});

// node_modules/linkedom/cjs/html/object-element.js
var require_object_element = __commonJS({
  "node_modules/linkedom/cjs/html/object-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLObjectElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "object") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLObjectElement = HTMLObjectElement;
  }
});

// node_modules/linkedom/cjs/html/head-element.js
var require_head_element = __commonJS({
  "node_modules/linkedom/cjs/html/head-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLHeadElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "head") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLHeadElement = HTMLHeadElement;
  }
});

// node_modules/linkedom/cjs/html/body-element.js
var require_body_element = __commonJS({
  "node_modules/linkedom/cjs/html/body-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLBodyElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "body") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLBodyElement = HTMLBodyElement;
  }
});

// node_modules/cssom/lib/StyleSheet.js
var require_StyleSheet = __commonJS({
  "node_modules/cssom/lib/StyleSheet.js"(exports) {
    var CSSOM = {};
    CSSOM.StyleSheet = function StyleSheet() {
      this.parentStyleSheet = null;
    };
    exports.StyleSheet = CSSOM.StyleSheet;
  }
});

// node_modules/cssom/lib/CSSRule.js
var require_CSSRule = __commonJS({
  "node_modules/cssom/lib/CSSRule.js"(exports) {
    var CSSOM = {};
    CSSOM.CSSRule = function CSSRule() {
      this.parentRule = null;
      this.parentStyleSheet = null;
    };
    CSSOM.CSSRule.UNKNOWN_RULE = 0;
    CSSOM.CSSRule.STYLE_RULE = 1;
    CSSOM.CSSRule.CHARSET_RULE = 2;
    CSSOM.CSSRule.IMPORT_RULE = 3;
    CSSOM.CSSRule.MEDIA_RULE = 4;
    CSSOM.CSSRule.FONT_FACE_RULE = 5;
    CSSOM.CSSRule.PAGE_RULE = 6;
    CSSOM.CSSRule.KEYFRAMES_RULE = 7;
    CSSOM.CSSRule.KEYFRAME_RULE = 8;
    CSSOM.CSSRule.MARGIN_RULE = 9;
    CSSOM.CSSRule.NAMESPACE_RULE = 10;
    CSSOM.CSSRule.COUNTER_STYLE_RULE = 11;
    CSSOM.CSSRule.SUPPORTS_RULE = 12;
    CSSOM.CSSRule.DOCUMENT_RULE = 13;
    CSSOM.CSSRule.FONT_FEATURE_VALUES_RULE = 14;
    CSSOM.CSSRule.VIEWPORT_RULE = 15;
    CSSOM.CSSRule.REGION_STYLE_RULE = 16;
    CSSOM.CSSRule.prototype = {
      constructor: CSSOM.CSSRule
    };
    exports.CSSRule = CSSOM.CSSRule;
  }
});

// node_modules/cssom/lib/CSSStyleRule.js
var require_CSSStyleRule = __commonJS({
  "node_modules/cssom/lib/CSSStyleRule.js"(exports) {
    var CSSOM = {
      CSSStyleDeclaration: require_CSSStyleDeclaration().CSSStyleDeclaration,
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSStyleRule = function CSSStyleRule() {
      CSSOM.CSSRule.call(this);
      this.selectorText = "";
      this.style = new CSSOM.CSSStyleDeclaration();
      this.style.parentRule = this;
    };
    CSSOM.CSSStyleRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSStyleRule.prototype.constructor = CSSOM.CSSStyleRule;
    CSSOM.CSSStyleRule.prototype.type = 1;
    Object.defineProperty(CSSOM.CSSStyleRule.prototype, "cssText", {
      get: function() {
        var text;
        if (this.selectorText) {
          text = this.selectorText + " {" + this.style.cssText + "}";
        } else {
          text = "";
        }
        return text;
      },
      set: function(cssText) {
        var rule = CSSOM.CSSStyleRule.parse(cssText);
        this.style = rule.style;
        this.selectorText = rule.selectorText;
      }
    });
    CSSOM.CSSStyleRule.parse = function(ruleText) {
      var i = 0;
      var state = "selector";
      var index;
      var j = i;
      var buffer = "";
      var SIGNIFICANT_WHITESPACE = {
        "selector": true,
        "value": true
      };
      var styleRule = new CSSOM.CSSStyleRule();
      var name, priority = "";
      for (var character; character = ruleText.charAt(i); i++) {
        switch (character) {
          case " ":
          case "	":
          case "\r":
          case "\n":
          case "\f":
            if (SIGNIFICANT_WHITESPACE[state]) {
              switch (ruleText.charAt(i - 1)) {
                case " ":
                case "	":
                case "\r":
                case "\n":
                case "\f":
                  break;
                default:
                  buffer += " ";
                  break;
              }
            }
            break;
          case '"':
            j = i + 1;
            index = ruleText.indexOf('"', j) + 1;
            if (!index) {
              throw '" is missing';
            }
            buffer += ruleText.slice(i, index);
            i = index - 1;
            break;
          case "'":
            j = i + 1;
            index = ruleText.indexOf("'", j) + 1;
            if (!index) {
              throw "' is missing";
            }
            buffer += ruleText.slice(i, index);
            i = index - 1;
            break;
          case "/":
            if (ruleText.charAt(i + 1) === "*") {
              i += 2;
              index = ruleText.indexOf("*/", i);
              if (index === -1) {
                throw new SyntaxError("Missing */");
              } else {
                i = index + 1;
              }
            } else {
              buffer += character;
            }
            break;
          case "{":
            if (state === "selector") {
              styleRule.selectorText = buffer.trim();
              buffer = "";
              state = "name";
            }
            break;
          case ":":
            if (state === "name") {
              name = buffer.trim();
              buffer = "";
              state = "value";
            } else {
              buffer += character;
            }
            break;
          case "!":
            if (state === "value" && ruleText.indexOf("!important", i) === i) {
              priority = "important";
              i += "important".length;
            } else {
              buffer += character;
            }
            break;
          case ";":
            if (state === "value") {
              styleRule.style.setProperty(name, buffer.trim(), priority);
              priority = "";
              buffer = "";
              state = "name";
            } else {
              buffer += character;
            }
            break;
          case "}":
            if (state === "value") {
              styleRule.style.setProperty(name, buffer.trim(), priority);
              priority = "";
              buffer = "";
            } else if (state === "name") {
              break;
            } else {
              buffer += character;
            }
            state = "selector";
            break;
          default:
            buffer += character;
            break;
        }
      }
      return styleRule;
    };
    exports.CSSStyleRule = CSSOM.CSSStyleRule;
  }
});

// node_modules/cssom/lib/CSSStyleSheet.js
var require_CSSStyleSheet = __commonJS({
  "node_modules/cssom/lib/CSSStyleSheet.js"(exports) {
    var CSSOM = {
      StyleSheet: require_StyleSheet().StyleSheet,
      CSSStyleRule: require_CSSStyleRule().CSSStyleRule
    };
    CSSOM.CSSStyleSheet = function CSSStyleSheet() {
      CSSOM.StyleSheet.call(this);
      this.cssRules = [];
    };
    CSSOM.CSSStyleSheet.prototype = new CSSOM.StyleSheet();
    CSSOM.CSSStyleSheet.prototype.constructor = CSSOM.CSSStyleSheet;
    CSSOM.CSSStyleSheet.prototype.insertRule = function(rule, index) {
      if (index < 0 || index > this.cssRules.length) {
        throw new RangeError("INDEX_SIZE_ERR");
      }
      var cssRule = CSSOM.parse(rule).cssRules[0];
      cssRule.parentStyleSheet = this;
      this.cssRules.splice(index, 0, cssRule);
      return index;
    };
    CSSOM.CSSStyleSheet.prototype.deleteRule = function(index) {
      if (index < 0 || index >= this.cssRules.length) {
        throw new RangeError("INDEX_SIZE_ERR");
      }
      this.cssRules.splice(index, 1);
    };
    CSSOM.CSSStyleSheet.prototype.toString = function() {
      var result = "";
      var rules = this.cssRules;
      for (var i = 0; i < rules.length; i++) {
        result += rules[i].cssText + "\n";
      }
      return result;
    };
    exports.CSSStyleSheet = CSSOM.CSSStyleSheet;
    CSSOM.parse = require_parse3().parse;
  }
});

// node_modules/cssom/lib/MediaList.js
var require_MediaList = __commonJS({
  "node_modules/cssom/lib/MediaList.js"(exports) {
    var CSSOM = {};
    CSSOM.MediaList = function MediaList() {
      this.length = 0;
    };
    CSSOM.MediaList.prototype = {
      constructor: CSSOM.MediaList,
      get mediaText() {
        return Array.prototype.join.call(this, ", ");
      },
      set mediaText(value) {
        var values = value.split(",");
        var length = this.length = values.length;
        for (var i = 0; i < length; i++) {
          this[i] = values[i].trim();
        }
      },
      appendMedium: function(medium) {
        if (Array.prototype.indexOf.call(this, medium) === -1) {
          this[this.length] = medium;
          this.length++;
        }
      },
      deleteMedium: function(medium) {
        var index = Array.prototype.indexOf.call(this, medium);
        if (index !== -1) {
          Array.prototype.splice.call(this, index, 1);
        }
      }
    };
    exports.MediaList = CSSOM.MediaList;
  }
});

// node_modules/cssom/lib/CSSImportRule.js
var require_CSSImportRule = __commonJS({
  "node_modules/cssom/lib/CSSImportRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSStyleSheet: require_CSSStyleSheet().CSSStyleSheet,
      MediaList: require_MediaList().MediaList
    };
    CSSOM.CSSImportRule = function CSSImportRule() {
      CSSOM.CSSRule.call(this);
      this.href = "";
      this.media = new CSSOM.MediaList();
      this.styleSheet = new CSSOM.CSSStyleSheet();
    };
    CSSOM.CSSImportRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSImportRule.prototype.constructor = CSSOM.CSSImportRule;
    CSSOM.CSSImportRule.prototype.type = 3;
    Object.defineProperty(CSSOM.CSSImportRule.prototype, "cssText", {
      get: function() {
        var mediaText = this.media.mediaText;
        return "@import url(" + this.href + ")" + (mediaText ? " " + mediaText : "") + ";";
      },
      set: function(cssText) {
        var i = 0;
        var state = "";
        var buffer = "";
        var index;
        for (var character; character = cssText.charAt(i); i++) {
          switch (character) {
            case " ":
            case "	":
            case "\r":
            case "\n":
            case "\f":
              if (state === "after-import") {
                state = "url";
              } else {
                buffer += character;
              }
              break;
            case "@":
              if (!state && cssText.indexOf("@import", i) === i) {
                state = "after-import";
                i += "import".length;
                buffer = "";
              }
              break;
            case "u":
              if (state === "url" && cssText.indexOf("url(", i) === i) {
                index = cssText.indexOf(")", i + 1);
                if (index === -1) {
                  throw i + ': ")" not found';
                }
                i += "url(".length;
                var url = cssText.slice(i, index);
                if (url[0] === url[url.length - 1]) {
                  if (url[0] === '"' || url[0] === "'") {
                    url = url.slice(1, -1);
                  }
                }
                this.href = url;
                i = index;
                state = "media";
              }
              break;
            case '"':
              if (state === "url") {
                index = cssText.indexOf('"', i + 1);
                if (!index) {
                  throw i + `: '"' not found`;
                }
                this.href = cssText.slice(i + 1, index);
                i = index;
                state = "media";
              }
              break;
            case "'":
              if (state === "url") {
                index = cssText.indexOf("'", i + 1);
                if (!index) {
                  throw i + `: "'" not found`;
                }
                this.href = cssText.slice(i + 1, index);
                i = index;
                state = "media";
              }
              break;
            case ";":
              if (state === "media") {
                if (buffer) {
                  this.media.mediaText = buffer.trim();
                }
              }
              break;
            default:
              if (state === "media") {
                buffer += character;
              }
              break;
          }
        }
      }
    });
    exports.CSSImportRule = CSSOM.CSSImportRule;
  }
});

// node_modules/cssom/lib/CSSGroupingRule.js
var require_CSSGroupingRule = __commonJS({
  "node_modules/cssom/lib/CSSGroupingRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSGroupingRule = function CSSGroupingRule() {
      CSSOM.CSSRule.call(this);
      this.cssRules = [];
    };
    CSSOM.CSSGroupingRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSGroupingRule.prototype.constructor = CSSOM.CSSGroupingRule;
    CSSOM.CSSGroupingRule.prototype.insertRule = function insertRule(rule, index) {
      if (index < 0 || index > this.cssRules.length) {
        throw new RangeError("INDEX_SIZE_ERR");
      }
      var cssRule = CSSOM.parse(rule).cssRules[0];
      cssRule.parentRule = this;
      this.cssRules.splice(index, 0, cssRule);
      return index;
    };
    CSSOM.CSSGroupingRule.prototype.deleteRule = function deleteRule(index) {
      if (index < 0 || index >= this.cssRules.length) {
        throw new RangeError("INDEX_SIZE_ERR");
      }
      this.cssRules.splice(index, 1)[0].parentRule = null;
    };
    exports.CSSGroupingRule = CSSOM.CSSGroupingRule;
  }
});

// node_modules/cssom/lib/CSSConditionRule.js
var require_CSSConditionRule = __commonJS({
  "node_modules/cssom/lib/CSSConditionRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSGroupingRule: require_CSSGroupingRule().CSSGroupingRule
    };
    CSSOM.CSSConditionRule = function CSSConditionRule() {
      CSSOM.CSSGroupingRule.call(this);
      this.cssRules = [];
    };
    CSSOM.CSSConditionRule.prototype = new CSSOM.CSSGroupingRule();
    CSSOM.CSSConditionRule.prototype.constructor = CSSOM.CSSConditionRule;
    CSSOM.CSSConditionRule.prototype.conditionText = "";
    CSSOM.CSSConditionRule.prototype.cssText = "";
    exports.CSSConditionRule = CSSOM.CSSConditionRule;
  }
});

// node_modules/cssom/lib/CSSMediaRule.js
var require_CSSMediaRule = __commonJS({
  "node_modules/cssom/lib/CSSMediaRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSGroupingRule: require_CSSGroupingRule().CSSGroupingRule,
      CSSConditionRule: require_CSSConditionRule().CSSConditionRule,
      MediaList: require_MediaList().MediaList
    };
    CSSOM.CSSMediaRule = function CSSMediaRule() {
      CSSOM.CSSConditionRule.call(this);
      this.media = new CSSOM.MediaList();
    };
    CSSOM.CSSMediaRule.prototype = new CSSOM.CSSConditionRule();
    CSSOM.CSSMediaRule.prototype.constructor = CSSOM.CSSMediaRule;
    CSSOM.CSSMediaRule.prototype.type = 4;
    Object.defineProperties(CSSOM.CSSMediaRule.prototype, {
      "conditionText": {
        get: function() {
          return this.media.mediaText;
        },
        set: function(value) {
          this.media.mediaText = value;
        },
        configurable: true,
        enumerable: true
      },
      "cssText": {
        get: function() {
          var cssTexts = [];
          for (var i = 0, length = this.cssRules.length; i < length; i++) {
            cssTexts.push(this.cssRules[i].cssText);
          }
          return "@media " + this.media.mediaText + " {" + cssTexts.join("") + "}";
        },
        configurable: true,
        enumerable: true
      }
    });
    exports.CSSMediaRule = CSSOM.CSSMediaRule;
  }
});

// node_modules/cssom/lib/CSSSupportsRule.js
var require_CSSSupportsRule = __commonJS({
  "node_modules/cssom/lib/CSSSupportsRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSGroupingRule: require_CSSGroupingRule().CSSGroupingRule,
      CSSConditionRule: require_CSSConditionRule().CSSConditionRule
    };
    CSSOM.CSSSupportsRule = function CSSSupportsRule() {
      CSSOM.CSSConditionRule.call(this);
    };
    CSSOM.CSSSupportsRule.prototype = new CSSOM.CSSConditionRule();
    CSSOM.CSSSupportsRule.prototype.constructor = CSSOM.CSSSupportsRule;
    CSSOM.CSSSupportsRule.prototype.type = 12;
    Object.defineProperty(CSSOM.CSSSupportsRule.prototype, "cssText", {
      get: function() {
        var cssTexts = [];
        for (var i = 0, length = this.cssRules.length; i < length; i++) {
          cssTexts.push(this.cssRules[i].cssText);
        }
        return "@supports " + this.conditionText + " {" + cssTexts.join("") + "}";
      }
    });
    exports.CSSSupportsRule = CSSOM.CSSSupportsRule;
  }
});

// node_modules/cssom/lib/CSSFontFaceRule.js
var require_CSSFontFaceRule = __commonJS({
  "node_modules/cssom/lib/CSSFontFaceRule.js"(exports) {
    var CSSOM = {
      CSSStyleDeclaration: require_CSSStyleDeclaration().CSSStyleDeclaration,
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSFontFaceRule = function CSSFontFaceRule() {
      CSSOM.CSSRule.call(this);
      this.style = new CSSOM.CSSStyleDeclaration();
      this.style.parentRule = this;
    };
    CSSOM.CSSFontFaceRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSFontFaceRule.prototype.constructor = CSSOM.CSSFontFaceRule;
    CSSOM.CSSFontFaceRule.prototype.type = 5;
    Object.defineProperty(CSSOM.CSSFontFaceRule.prototype, "cssText", {
      get: function() {
        return "@font-face {" + this.style.cssText + "}";
      }
    });
    exports.CSSFontFaceRule = CSSOM.CSSFontFaceRule;
  }
});

// node_modules/cssom/lib/CSSHostRule.js
var require_CSSHostRule = __commonJS({
  "node_modules/cssom/lib/CSSHostRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSHostRule = function CSSHostRule() {
      CSSOM.CSSRule.call(this);
      this.cssRules = [];
    };
    CSSOM.CSSHostRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSHostRule.prototype.constructor = CSSOM.CSSHostRule;
    CSSOM.CSSHostRule.prototype.type = 1001;
    Object.defineProperty(CSSOM.CSSHostRule.prototype, "cssText", {
      get: function() {
        var cssTexts = [];
        for (var i = 0, length = this.cssRules.length; i < length; i++) {
          cssTexts.push(this.cssRules[i].cssText);
        }
        return "@host {" + cssTexts.join("") + "}";
      }
    });
    exports.CSSHostRule = CSSOM.CSSHostRule;
  }
});

// node_modules/cssom/lib/CSSKeyframeRule.js
var require_CSSKeyframeRule = __commonJS({
  "node_modules/cssom/lib/CSSKeyframeRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSStyleDeclaration: require_CSSStyleDeclaration().CSSStyleDeclaration
    };
    CSSOM.CSSKeyframeRule = function CSSKeyframeRule() {
      CSSOM.CSSRule.call(this);
      this.keyText = "";
      this.style = new CSSOM.CSSStyleDeclaration();
      this.style.parentRule = this;
    };
    CSSOM.CSSKeyframeRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSKeyframeRule.prototype.constructor = CSSOM.CSSKeyframeRule;
    CSSOM.CSSKeyframeRule.prototype.type = 8;
    Object.defineProperty(CSSOM.CSSKeyframeRule.prototype, "cssText", {
      get: function() {
        return this.keyText + " {" + this.style.cssText + "} ";
      }
    });
    exports.CSSKeyframeRule = CSSOM.CSSKeyframeRule;
  }
});

// node_modules/cssom/lib/CSSKeyframesRule.js
var require_CSSKeyframesRule = __commonJS({
  "node_modules/cssom/lib/CSSKeyframesRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSKeyframesRule = function CSSKeyframesRule() {
      CSSOM.CSSRule.call(this);
      this.name = "";
      this.cssRules = [];
    };
    CSSOM.CSSKeyframesRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSKeyframesRule.prototype.constructor = CSSOM.CSSKeyframesRule;
    CSSOM.CSSKeyframesRule.prototype.type = 7;
    Object.defineProperty(CSSOM.CSSKeyframesRule.prototype, "cssText", {
      get: function() {
        var cssTexts = [];
        for (var i = 0, length = this.cssRules.length; i < length; i++) {
          cssTexts.push("  " + this.cssRules[i].cssText);
        }
        return "@" + (this._vendorPrefix || "") + "keyframes " + this.name + " { \n" + cssTexts.join("\n") + "\n}";
      }
    });
    exports.CSSKeyframesRule = CSSOM.CSSKeyframesRule;
  }
});

// node_modules/cssom/lib/CSSValue.js
var require_CSSValue = __commonJS({
  "node_modules/cssom/lib/CSSValue.js"(exports) {
    var CSSOM = {};
    CSSOM.CSSValue = function CSSValue() {
    };
    CSSOM.CSSValue.prototype = {
      constructor: CSSOM.CSSValue,
      set cssText(text) {
        var name = this._getConstructorName();
        throw new Error('DOMException: property "cssText" of "' + name + '" is readonly and can not be replaced with "' + text + '"!');
      },
      get cssText() {
        var name = this._getConstructorName();
        throw new Error('getter "cssText" of "' + name + '" is not implemented!');
      },
      _getConstructorName: function() {
        var s = this.constructor.toString(), c = s.match(/function\s([^\(]+)/), name = c[1];
        return name;
      }
    };
    exports.CSSValue = CSSOM.CSSValue;
  }
});

// node_modules/cssom/lib/CSSValueExpression.js
var require_CSSValueExpression = __commonJS({
  "node_modules/cssom/lib/CSSValueExpression.js"(exports) {
    var CSSOM = {
      CSSValue: require_CSSValue().CSSValue
    };
    CSSOM.CSSValueExpression = function CSSValueExpression(token, idx) {
      this._token = token;
      this._idx = idx;
    };
    CSSOM.CSSValueExpression.prototype = new CSSOM.CSSValue();
    CSSOM.CSSValueExpression.prototype.constructor = CSSOM.CSSValueExpression;
    CSSOM.CSSValueExpression.prototype.parse = function() {
      var token = this._token, idx = this._idx;
      var character = "", expression = "", error = "", info, paren = [];
      for (; ; ++idx) {
        character = token.charAt(idx);
        if (character === "") {
          error = "css expression error: unfinished expression!";
          break;
        }
        switch (character) {
          case "(":
            paren.push(character);
            expression += character;
            break;
          case ")":
            paren.pop(character);
            expression += character;
            break;
          case "/":
            if (info = this._parseJSComment(token, idx)) {
              if (info.error) {
                error = "css expression error: unfinished comment in expression!";
              } else {
                idx = info.idx;
              }
            } else if (info = this._parseJSRexExp(token, idx)) {
              idx = info.idx;
              expression += info.text;
            } else {
              expression += character;
            }
            break;
          case "'":
          case '"':
            info = this._parseJSString(token, idx, character);
            if (info) {
              idx = info.idx;
              expression += info.text;
            } else {
              expression += character;
            }
            break;
          default:
            expression += character;
            break;
        }
        if (error) {
          break;
        }
        if (paren.length === 0) {
          break;
        }
      }
      var ret;
      if (error) {
        ret = {
          error
        };
      } else {
        ret = {
          idx,
          expression
        };
      }
      return ret;
    };
    CSSOM.CSSValueExpression.prototype._parseJSComment = function(token, idx) {
      var nextChar = token.charAt(idx + 1), text;
      if (nextChar === "/" || nextChar === "*") {
        var startIdx = idx, endIdx, commentEndChar;
        if (nextChar === "/") {
          commentEndChar = "\n";
        } else if (nextChar === "*") {
          commentEndChar = "*/";
        }
        endIdx = token.indexOf(commentEndChar, startIdx + 1 + 1);
        if (endIdx !== -1) {
          endIdx = endIdx + commentEndChar.length - 1;
          text = token.substring(idx, endIdx + 1);
          return {
            idx: endIdx,
            text
          };
        } else {
          var error = "css expression error: unfinished comment in expression!";
          return {
            error
          };
        }
      } else {
        return false;
      }
    };
    CSSOM.CSSValueExpression.prototype._parseJSString = function(token, idx, sep) {
      var endIdx = this._findMatchedIdx(token, idx, sep), text;
      if (endIdx === -1) {
        return false;
      } else {
        text = token.substring(idx, endIdx + sep.length);
        return {
          idx: endIdx,
          text
        };
      }
    };
    CSSOM.CSSValueExpression.prototype._parseJSRexExp = function(token, idx) {
      var before = token.substring(0, idx).replace(/\s+$/, ""), legalRegx = [
        /^$/,
        /\($/,
        /\[$/,
        /\!$/,
        /\+$/,
        /\-$/,
        /\*$/,
        /\/\s+/,
        /\%$/,
        /\=$/,
        /\>$/,
        /<$/,
        /\&$/,
        /\|$/,
        /\^$/,
        /\~$/,
        /\?$/,
        /\,$/,
        /delete$/,
        /in$/,
        /instanceof$/,
        /new$/,
        /typeof$/,
        /void$/
      ];
      var isLegal = legalRegx.some(function(reg) {
        return reg.test(before);
      });
      if (!isLegal) {
        return false;
      } else {
        var sep = "/";
        return this._parseJSString(token, idx, sep);
      }
    };
    CSSOM.CSSValueExpression.prototype._findMatchedIdx = function(token, idx, sep) {
      var startIdx = idx, endIdx;
      var NOT_FOUND = -1;
      while (true) {
        endIdx = token.indexOf(sep, startIdx + 1);
        if (endIdx === -1) {
          endIdx = NOT_FOUND;
          break;
        } else {
          var text = token.substring(idx + 1, endIdx), matched = text.match(/\\+$/);
          if (!matched || matched[0] % 2 === 0) {
            break;
          } else {
            startIdx = endIdx;
          }
        }
      }
      var nextNewLineIdx = token.indexOf("\n", idx + 1);
      if (nextNewLineIdx < endIdx) {
        endIdx = NOT_FOUND;
      }
      return endIdx;
    };
    exports.CSSValueExpression = CSSOM.CSSValueExpression;
  }
});

// node_modules/cssom/lib/MatcherList.js
var require_MatcherList = __commonJS({
  "node_modules/cssom/lib/MatcherList.js"(exports) {
    var CSSOM = {};
    CSSOM.MatcherList = function MatcherList() {
      this.length = 0;
    };
    CSSOM.MatcherList.prototype = {
      constructor: CSSOM.MatcherList,
      get matcherText() {
        return Array.prototype.join.call(this, ", ");
      },
      set matcherText(value) {
        var values = value.split(",");
        var length = this.length = values.length;
        for (var i = 0; i < length; i++) {
          this[i] = values[i].trim();
        }
      },
      appendMatcher: function(matcher) {
        if (Array.prototype.indexOf.call(this, matcher) === -1) {
          this[this.length] = matcher;
          this.length++;
        }
      },
      deleteMatcher: function(matcher) {
        var index = Array.prototype.indexOf.call(this, matcher);
        if (index !== -1) {
          Array.prototype.splice.call(this, index, 1);
        }
      }
    };
    exports.MatcherList = CSSOM.MatcherList;
  }
});

// node_modules/cssom/lib/CSSDocumentRule.js
var require_CSSDocumentRule = __commonJS({
  "node_modules/cssom/lib/CSSDocumentRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      MatcherList: require_MatcherList().MatcherList
    };
    CSSOM.CSSDocumentRule = function CSSDocumentRule() {
      CSSOM.CSSRule.call(this);
      this.matcher = new CSSOM.MatcherList();
      this.cssRules = [];
    };
    CSSOM.CSSDocumentRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSDocumentRule.prototype.constructor = CSSOM.CSSDocumentRule;
    CSSOM.CSSDocumentRule.prototype.type = 10;
    Object.defineProperty(CSSOM.CSSDocumentRule.prototype, "cssText", {
      get: function() {
        var cssTexts = [];
        for (var i = 0, length = this.cssRules.length; i < length; i++) {
          cssTexts.push(this.cssRules[i].cssText);
        }
        return "@-moz-document " + this.matcher.matcherText + " {" + cssTexts.join("") + "}";
      }
    });
    exports.CSSDocumentRule = CSSOM.CSSDocumentRule;
  }
});

// node_modules/cssom/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/cssom/lib/parse.js"(exports) {
    var CSSOM = {};
    CSSOM.parse = function parse(token) {
      var i = 0;
      var state = "before-selector";
      var index;
      var buffer = "";
      var valueParenthesisDepth = 0;
      var SIGNIFICANT_WHITESPACE = {
        "selector": true,
        "value": true,
        "value-parenthesis": true,
        "atRule": true,
        "importRule-begin": true,
        "importRule": true,
        "atBlock": true,
        "conditionBlock": true,
        "documentRule-begin": true
      };
      var styleSheet = new CSSOM.CSSStyleSheet();
      var currentScope = styleSheet;
      var parentRule;
      var ancestorRules = [];
      var hasAncestors = false;
      var prevScope;
      var name, priority = "", styleRule, mediaRule, supportsRule, importRule, fontFaceRule, keyframesRule, documentRule, hostRule;
      var atKeyframesRegExp = /@(-(?:\w+-)+)?keyframes/g;
      var parseError = function(message) {
        var lines = token.substring(0, i).split("\n");
        var lineCount = lines.length;
        var charCount = lines.pop().length + 1;
        var error = new Error(message + " (line " + lineCount + ", char " + charCount + ")");
        error.line = lineCount;
        error["char"] = charCount;
        error.styleSheet = styleSheet;
        throw error;
      };
      for (var character; character = token.charAt(i); i++) {
        switch (character) {
          case " ":
          case "	":
          case "\r":
          case "\n":
          case "\f":
            if (SIGNIFICANT_WHITESPACE[state]) {
              buffer += character;
            }
            break;
          case '"':
            index = i + 1;
            do {
              index = token.indexOf('"', index) + 1;
              if (!index) {
                parseError('Unmatched "');
              }
            } while (token[index - 2] === "\\");
            buffer += token.slice(i, index);
            i = index - 1;
            switch (state) {
              case "before-value":
                state = "value";
                break;
              case "importRule-begin":
                state = "importRule";
                break;
            }
            break;
          case "'":
            index = i + 1;
            do {
              index = token.indexOf("'", index) + 1;
              if (!index) {
                parseError("Unmatched '");
              }
            } while (token[index - 2] === "\\");
            buffer += token.slice(i, index);
            i = index - 1;
            switch (state) {
              case "before-value":
                state = "value";
                break;
              case "importRule-begin":
                state = "importRule";
                break;
            }
            break;
          case "/":
            if (token.charAt(i + 1) === "*") {
              i += 2;
              index = token.indexOf("*/", i);
              if (index === -1) {
                parseError("Missing */");
              } else {
                i = index + 1;
              }
            } else {
              buffer += character;
            }
            if (state === "importRule-begin") {
              buffer += " ";
              state = "importRule";
            }
            break;
          case "@":
            if (token.indexOf("@-moz-document", i) === i) {
              state = "documentRule-begin";
              documentRule = new CSSOM.CSSDocumentRule();
              documentRule.__starts = i;
              i += "-moz-document".length;
              buffer = "";
              break;
            } else if (token.indexOf("@media", i) === i) {
              state = "atBlock";
              mediaRule = new CSSOM.CSSMediaRule();
              mediaRule.__starts = i;
              i += "media".length;
              buffer = "";
              break;
            } else if (token.indexOf("@supports", i) === i) {
              state = "conditionBlock";
              supportsRule = new CSSOM.CSSSupportsRule();
              supportsRule.__starts = i;
              i += "supports".length;
              buffer = "";
              break;
            } else if (token.indexOf("@host", i) === i) {
              state = "hostRule-begin";
              i += "host".length;
              hostRule = new CSSOM.CSSHostRule();
              hostRule.__starts = i;
              buffer = "";
              break;
            } else if (token.indexOf("@import", i) === i) {
              state = "importRule-begin";
              i += "import".length;
              buffer += "@import";
              break;
            } else if (token.indexOf("@font-face", i) === i) {
              state = "fontFaceRule-begin";
              i += "font-face".length;
              fontFaceRule = new CSSOM.CSSFontFaceRule();
              fontFaceRule.__starts = i;
              buffer = "";
              break;
            } else {
              atKeyframesRegExp.lastIndex = i;
              var matchKeyframes = atKeyframesRegExp.exec(token);
              if (matchKeyframes && matchKeyframes.index === i) {
                state = "keyframesRule-begin";
                keyframesRule = new CSSOM.CSSKeyframesRule();
                keyframesRule.__starts = i;
                keyframesRule._vendorPrefix = matchKeyframes[1];
                i += matchKeyframes[0].length - 1;
                buffer = "";
                break;
              } else if (state === "selector") {
                state = "atRule";
              }
            }
            buffer += character;
            break;
          case "{":
            if (state === "selector" || state === "atRule") {
              styleRule.selectorText = buffer.trim();
              styleRule.style.__starts = i;
              buffer = "";
              state = "before-name";
            } else if (state === "atBlock") {
              mediaRule.media.mediaText = buffer.trim();
              if (parentRule) {
                ancestorRules.push(parentRule);
              }
              currentScope = parentRule = mediaRule;
              mediaRule.parentStyleSheet = styleSheet;
              buffer = "";
              state = "before-selector";
            } else if (state === "conditionBlock") {
              supportsRule.conditionText = buffer.trim();
              if (parentRule) {
                ancestorRules.push(parentRule);
              }
              currentScope = parentRule = supportsRule;
              supportsRule.parentStyleSheet = styleSheet;
              buffer = "";
              state = "before-selector";
            } else if (state === "hostRule-begin") {
              if (parentRule) {
                ancestorRules.push(parentRule);
              }
              currentScope = parentRule = hostRule;
              hostRule.parentStyleSheet = styleSheet;
              buffer = "";
              state = "before-selector";
            } else if (state === "fontFaceRule-begin") {
              if (parentRule) {
                fontFaceRule.parentRule = parentRule;
              }
              fontFaceRule.parentStyleSheet = styleSheet;
              styleRule = fontFaceRule;
              buffer = "";
              state = "before-name";
            } else if (state === "keyframesRule-begin") {
              keyframesRule.name = buffer.trim();
              if (parentRule) {
                ancestorRules.push(parentRule);
                keyframesRule.parentRule = parentRule;
              }
              keyframesRule.parentStyleSheet = styleSheet;
              currentScope = parentRule = keyframesRule;
              buffer = "";
              state = "keyframeRule-begin";
            } else if (state === "keyframeRule-begin") {
              styleRule = new CSSOM.CSSKeyframeRule();
              styleRule.keyText = buffer.trim();
              styleRule.__starts = i;
              buffer = "";
              state = "before-name";
            } else if (state === "documentRule-begin") {
              documentRule.matcher.matcherText = buffer.trim();
              if (parentRule) {
                ancestorRules.push(parentRule);
                documentRule.parentRule = parentRule;
              }
              currentScope = parentRule = documentRule;
              documentRule.parentStyleSheet = styleSheet;
              buffer = "";
              state = "before-selector";
            }
            break;
          case ":":
            if (state === "name") {
              name = buffer.trim();
              buffer = "";
              state = "before-value";
            } else {
              buffer += character;
            }
            break;
          case "(":
            if (state === "value") {
              if (buffer.trim() === "expression") {
                var info = new CSSOM.CSSValueExpression(token, i).parse();
                if (info.error) {
                  parseError(info.error);
                } else {
                  buffer += info.expression;
                  i = info.idx;
                }
              } else {
                state = "value-parenthesis";
                valueParenthesisDepth = 1;
                buffer += character;
              }
            } else if (state === "value-parenthesis") {
              valueParenthesisDepth++;
              buffer += character;
            } else {
              buffer += character;
            }
            break;
          case ")":
            if (state === "value-parenthesis") {
              valueParenthesisDepth--;
              if (valueParenthesisDepth === 0)
                state = "value";
            }
            buffer += character;
            break;
          case "!":
            if (state === "value" && token.indexOf("!important", i) === i) {
              priority = "important";
              i += "important".length;
            } else {
              buffer += character;
            }
            break;
          case ";":
            switch (state) {
              case "value":
                styleRule.style.setProperty(name, buffer.trim(), priority);
                priority = "";
                buffer = "";
                state = "before-name";
                break;
              case "atRule":
                buffer = "";
                state = "before-selector";
                break;
              case "importRule":
                importRule = new CSSOM.CSSImportRule();
                importRule.parentStyleSheet = importRule.styleSheet.parentStyleSheet = styleSheet;
                importRule.cssText = buffer + character;
                styleSheet.cssRules.push(importRule);
                buffer = "";
                state = "before-selector";
                break;
              default:
                buffer += character;
                break;
            }
            break;
          case "}":
            switch (state) {
              case "value":
                styleRule.style.setProperty(name, buffer.trim(), priority);
                priority = "";
              case "before-name":
              case "name":
                styleRule.__ends = i + 1;
                if (parentRule) {
                  styleRule.parentRule = parentRule;
                }
                styleRule.parentStyleSheet = styleSheet;
                currentScope.cssRules.push(styleRule);
                buffer = "";
                if (currentScope.constructor === CSSOM.CSSKeyframesRule) {
                  state = "keyframeRule-begin";
                } else {
                  state = "before-selector";
                }
                break;
              case "keyframeRule-begin":
              case "before-selector":
              case "selector":
                if (!parentRule) {
                  parseError("Unexpected }");
                }
                hasAncestors = ancestorRules.length > 0;
                while (ancestorRules.length > 0) {
                  parentRule = ancestorRules.pop();
                  if (parentRule.constructor.name === "CSSMediaRule" || parentRule.constructor.name === "CSSSupportsRule") {
                    prevScope = currentScope;
                    currentScope = parentRule;
                    currentScope.cssRules.push(prevScope);
                    break;
                  }
                  if (ancestorRules.length === 0) {
                    hasAncestors = false;
                  }
                }
                if (!hasAncestors) {
                  currentScope.__ends = i + 1;
                  styleSheet.cssRules.push(currentScope);
                  currentScope = styleSheet;
                  parentRule = null;
                }
                buffer = "";
                state = "before-selector";
                break;
            }
            break;
          default:
            switch (state) {
              case "before-selector":
                state = "selector";
                styleRule = new CSSOM.CSSStyleRule();
                styleRule.__starts = i;
                break;
              case "before-name":
                state = "name";
                break;
              case "before-value":
                state = "value";
                break;
              case "importRule-begin":
                state = "importRule";
                break;
            }
            buffer += character;
            break;
        }
      }
      return styleSheet;
    };
    exports.parse = CSSOM.parse;
    CSSOM.CSSStyleSheet = require_CSSStyleSheet().CSSStyleSheet;
    CSSOM.CSSStyleRule = require_CSSStyleRule().CSSStyleRule;
    CSSOM.CSSImportRule = require_CSSImportRule().CSSImportRule;
    CSSOM.CSSGroupingRule = require_CSSGroupingRule().CSSGroupingRule;
    CSSOM.CSSMediaRule = require_CSSMediaRule().CSSMediaRule;
    CSSOM.CSSConditionRule = require_CSSConditionRule().CSSConditionRule;
    CSSOM.CSSSupportsRule = require_CSSSupportsRule().CSSSupportsRule;
    CSSOM.CSSFontFaceRule = require_CSSFontFaceRule().CSSFontFaceRule;
    CSSOM.CSSHostRule = require_CSSHostRule().CSSHostRule;
    CSSOM.CSSStyleDeclaration = require_CSSStyleDeclaration().CSSStyleDeclaration;
    CSSOM.CSSKeyframeRule = require_CSSKeyframeRule().CSSKeyframeRule;
    CSSOM.CSSKeyframesRule = require_CSSKeyframesRule().CSSKeyframesRule;
    CSSOM.CSSValueExpression = require_CSSValueExpression().CSSValueExpression;
    CSSOM.CSSDocumentRule = require_CSSDocumentRule().CSSDocumentRule;
  }
});

// node_modules/cssom/lib/CSSStyleDeclaration.js
var require_CSSStyleDeclaration = __commonJS({
  "node_modules/cssom/lib/CSSStyleDeclaration.js"(exports) {
    var CSSOM = {};
    CSSOM.CSSStyleDeclaration = function CSSStyleDeclaration() {
      this.length = 0;
      this.parentRule = null;
      this._importants = {};
    };
    CSSOM.CSSStyleDeclaration.prototype = {
      constructor: CSSOM.CSSStyleDeclaration,
      getPropertyValue: function(name) {
        return this[name] || "";
      },
      setProperty: function(name, value, priority) {
        if (this[name]) {
          var index = Array.prototype.indexOf.call(this, name);
          if (index < 0) {
            this[this.length] = name;
            this.length++;
          }
        } else {
          this[this.length] = name;
          this.length++;
        }
        this[name] = value + "";
        this._importants[name] = priority;
      },
      removeProperty: function(name) {
        if (!(name in this)) {
          return "";
        }
        var index = Array.prototype.indexOf.call(this, name);
        if (index < 0) {
          return "";
        }
        var prevValue = this[name];
        this[name] = "";
        Array.prototype.splice.call(this, index, 1);
        return prevValue;
      },
      getPropertyCSSValue: function() {
      },
      getPropertyPriority: function(name) {
        return this._importants[name] || "";
      },
      getPropertyShorthand: function() {
      },
      isPropertyImplicit: function() {
      },
      get cssText() {
        var properties = [];
        for (var i = 0, length = this.length; i < length; ++i) {
          var name = this[i];
          var value = this.getPropertyValue(name);
          var priority = this.getPropertyPriority(name);
          if (priority) {
            priority = " !" + priority;
          }
          properties[i] = name + ": " + value + priority + ";";
        }
        return properties.join(" ");
      },
      set cssText(text) {
        var i, name;
        for (i = this.length; i--; ) {
          name = this[i];
          this[name] = "";
        }
        Array.prototype.splice.call(this, 0, this.length);
        this._importants = {};
        var dummyRule = CSSOM.parse("#bogus{" + text + "}").cssRules[0].style;
        var length = dummyRule.length;
        for (i = 0; i < length; ++i) {
          name = dummyRule[i];
          this.setProperty(dummyRule[i], dummyRule.getPropertyValue(name), dummyRule.getPropertyPriority(name));
        }
      }
    };
    exports.CSSStyleDeclaration = CSSOM.CSSStyleDeclaration;
    CSSOM.parse = require_parse3().parse;
  }
});

// node_modules/cssom/lib/clone.js
var require_clone = __commonJS({
  "node_modules/cssom/lib/clone.js"(exports) {
    var CSSOM = {
      CSSStyleSheet: require_CSSStyleSheet().CSSStyleSheet,
      CSSRule: require_CSSRule().CSSRule,
      CSSStyleRule: require_CSSStyleRule().CSSStyleRule,
      CSSGroupingRule: require_CSSGroupingRule().CSSGroupingRule,
      CSSConditionRule: require_CSSConditionRule().CSSConditionRule,
      CSSMediaRule: require_CSSMediaRule().CSSMediaRule,
      CSSSupportsRule: require_CSSSupportsRule().CSSSupportsRule,
      CSSStyleDeclaration: require_CSSStyleDeclaration().CSSStyleDeclaration,
      CSSKeyframeRule: require_CSSKeyframeRule().CSSKeyframeRule,
      CSSKeyframesRule: require_CSSKeyframesRule().CSSKeyframesRule
    };
    CSSOM.clone = function clone(stylesheet) {
      var cloned = new CSSOM.CSSStyleSheet();
      var rules = stylesheet.cssRules;
      if (!rules) {
        return cloned;
      }
      for (var i = 0, rulesLength = rules.length; i < rulesLength; i++) {
        var rule = rules[i];
        var ruleClone = cloned.cssRules[i] = new rule.constructor();
        var style = rule.style;
        if (style) {
          var styleClone = ruleClone.style = new CSSOM.CSSStyleDeclaration();
          for (var j = 0, styleLength = style.length; j < styleLength; j++) {
            var name = styleClone[j] = style[j];
            styleClone[name] = style[name];
            styleClone._importants[name] = style.getPropertyPriority(name);
          }
          styleClone.length = style.length;
        }
        if (rule.hasOwnProperty("keyText")) {
          ruleClone.keyText = rule.keyText;
        }
        if (rule.hasOwnProperty("selectorText")) {
          ruleClone.selectorText = rule.selectorText;
        }
        if (rule.hasOwnProperty("mediaText")) {
          ruleClone.mediaText = rule.mediaText;
        }
        if (rule.hasOwnProperty("conditionText")) {
          ruleClone.conditionText = rule.conditionText;
        }
        if (rule.hasOwnProperty("cssRules")) {
          ruleClone.cssRules = clone(rule).cssRules;
        }
      }
      return cloned;
    };
    exports.clone = CSSOM.clone;
  }
});

// node_modules/cssom/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/cssom/lib/index.js"(exports) {
    "use strict";
    exports.CSSStyleDeclaration = require_CSSStyleDeclaration().CSSStyleDeclaration;
    exports.CSSRule = require_CSSRule().CSSRule;
    exports.CSSGroupingRule = require_CSSGroupingRule().CSSGroupingRule;
    exports.CSSConditionRule = require_CSSConditionRule().CSSConditionRule;
    exports.CSSStyleRule = require_CSSStyleRule().CSSStyleRule;
    exports.MediaList = require_MediaList().MediaList;
    exports.CSSMediaRule = require_CSSMediaRule().CSSMediaRule;
    exports.CSSSupportsRule = require_CSSSupportsRule().CSSSupportsRule;
    exports.CSSImportRule = require_CSSImportRule().CSSImportRule;
    exports.CSSFontFaceRule = require_CSSFontFaceRule().CSSFontFaceRule;
    exports.CSSHostRule = require_CSSHostRule().CSSHostRule;
    exports.StyleSheet = require_StyleSheet().StyleSheet;
    exports.CSSStyleSheet = require_CSSStyleSheet().CSSStyleSheet;
    exports.CSSKeyframesRule = require_CSSKeyframesRule().CSSKeyframesRule;
    exports.CSSKeyframeRule = require_CSSKeyframeRule().CSSKeyframeRule;
    exports.MatcherList = require_MatcherList().MatcherList;
    exports.CSSDocumentRule = require_CSSDocumentRule().CSSDocumentRule;
    exports.CSSValue = require_CSSValue().CSSValue;
    exports.CSSValueExpression = require_CSSValueExpression().CSSValueExpression;
    exports.parse = require_parse3().parse;
    exports.clone = require_clone().clone;
  }
});

// node_modules/linkedom/cjs/html/style-element.js
var require_style_element = __commonJS({
  "node_modules/linkedom/cjs/html/style-element.js"(exports) {
    "use strict";
    var { parse } = require_lib9();
    var { registerHTMLClass } = require_register_html_class();
    var { SHEET } = require_symbols();
    var { TextElement } = require_text_element();
    var tagName = "style";
    var HTMLStyleElement = class extends TextElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
        this[SHEET] = null;
      }
      get sheet() {
        const sheet = this[SHEET];
        if (sheet !== null) {
          return sheet;
        }
        return this[SHEET] = parse(this.textContent);
      }
      get innerHTML() {
        return super.innerHTML || "";
      }
      set innerHTML(value) {
        super.textContent = value;
        this[SHEET] = null;
      }
      get innerText() {
        return super.innerText || "";
      }
      set innerText(value) {
        super.textContent = value;
        this[SHEET] = null;
      }
      get textContent() {
        return super.textContent || "";
      }
      set textContent(value) {
        super.textContent = value;
        this[SHEET] = null;
      }
    };
    registerHTMLClass(tagName, HTMLStyleElement);
    exports.HTMLStyleElement = HTMLStyleElement;
  }
});

// node_modules/linkedom/cjs/html/time-element.js
var require_time_element = __commonJS({
  "node_modules/linkedom/cjs/html/time-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLTimeElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "time") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLTimeElement = HTMLTimeElement;
  }
});

// node_modules/linkedom/cjs/html/field-set-element.js
var require_field_set_element = __commonJS({
  "node_modules/linkedom/cjs/html/field-set-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLFieldSetElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "fieldset") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLFieldSetElement = HTMLFieldSetElement;
  }
});

// node_modules/linkedom/cjs/html/embed-element.js
var require_embed_element = __commonJS({
  "node_modules/linkedom/cjs/html/embed-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLEmbedElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "embed") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLEmbedElement = HTMLEmbedElement;
  }
});

// node_modules/linkedom/cjs/html/hr-element.js
var require_hr_element = __commonJS({
  "node_modules/linkedom/cjs/html/hr-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLHRElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "hr") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLHRElement = HTMLHRElement;
  }
});

// node_modules/linkedom/cjs/html/progress-element.js
var require_progress_element = __commonJS({
  "node_modules/linkedom/cjs/html/progress-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLProgressElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "progress") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLProgressElement = HTMLProgressElement;
  }
});

// node_modules/linkedom/cjs/html/paragraph-element.js
var require_paragraph_element = __commonJS({
  "node_modules/linkedom/cjs/html/paragraph-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLParagraphElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "p") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLParagraphElement = HTMLParagraphElement;
  }
});

// node_modules/linkedom/cjs/html/table-element.js
var require_table_element = __commonJS({
  "node_modules/linkedom/cjs/html/table-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLTableElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "table") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLTableElement = HTMLTableElement;
  }
});

// node_modules/linkedom/cjs/html/frame-set-element.js
var require_frame_set_element = __commonJS({
  "node_modules/linkedom/cjs/html/frame-set-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLFrameSetElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "frameset") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLFrameSetElement = HTMLFrameSetElement;
  }
});

// node_modules/linkedom/cjs/html/li-element.js
var require_li_element = __commonJS({
  "node_modules/linkedom/cjs/html/li-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLLIElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "li") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLLIElement = HTMLLIElement;
  }
});

// node_modules/linkedom/cjs/html/base-element.js
var require_base_element = __commonJS({
  "node_modules/linkedom/cjs/html/base-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLBaseElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "base") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLBaseElement = HTMLBaseElement;
  }
});

// node_modules/linkedom/cjs/html/data-list-element.js
var require_data_list_element = __commonJS({
  "node_modules/linkedom/cjs/html/data-list-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLDataListElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "datalist") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLDataListElement = HTMLDataListElement;
  }
});

// node_modules/linkedom/cjs/html/input-element.js
var require_input_element = __commonJS({
  "node_modules/linkedom/cjs/html/input-element.js"(exports) {
    "use strict";
    var { registerHTMLClass } = require_register_html_class();
    var { booleanAttribute } = require_attributes();
    var { HTMLElement } = require_element3();
    var tagName = "input";
    var HTMLInputElement = class extends HTMLElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
      }
      get autofocus() {
        return booleanAttribute.get(this, "autofocus") || -1;
      }
      set autofocus(value) {
        booleanAttribute.set(this, "autofocus", value);
      }
      get disabled() {
        return booleanAttribute.get(this, "disabled");
      }
      set disabled(value) {
        booleanAttribute.set(this, "disabled", value);
      }
      get name() {
        return this.getAttribute("name");
      }
      set name(value) {
        this.setAttribute("name", value);
      }
      get placeholder() {
        return this.getAttribute("placeholder");
      }
      set placeholder(value) {
        this.setAttribute("placeholder", value);
      }
      get type() {
        return this.getAttribute("type");
      }
      set type(value) {
        this.setAttribute("type", value);
      }
    };
    registerHTMLClass(tagName, HTMLInputElement);
    exports.HTMLInputElement = HTMLInputElement;
  }
});

// node_modules/linkedom/cjs/html/param-element.js
var require_param_element = __commonJS({
  "node_modules/linkedom/cjs/html/param-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLParamElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "param") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLParamElement = HTMLParamElement;
  }
});

// node_modules/linkedom/cjs/html/media-element.js
var require_media_element = __commonJS({
  "node_modules/linkedom/cjs/html/media-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLMediaElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "media") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLMediaElement = HTMLMediaElement;
  }
});

// node_modules/linkedom/cjs/html/audio-element.js
var require_audio_element = __commonJS({
  "node_modules/linkedom/cjs/html/audio-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLAudioElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "audio") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLAudioElement = HTMLAudioElement;
  }
});

// node_modules/linkedom/cjs/html/heading-element.js
var require_heading_element = __commonJS({
  "node_modules/linkedom/cjs/html/heading-element.js"(exports) {
    "use strict";
    var { registerHTMLClass } = require_register_html_class();
    var { HTMLElement } = require_element3();
    var tagName = "h1";
    var HTMLHeadingElement = class extends HTMLElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
      }
    };
    registerHTMLClass([tagName, "h2", "h3", "h4", "h5", "h6"], HTMLHeadingElement);
    exports.HTMLHeadingElement = HTMLHeadingElement;
  }
});

// node_modules/linkedom/cjs/html/directory-element.js
var require_directory_element = __commonJS({
  "node_modules/linkedom/cjs/html/directory-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLDirectoryElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "dir") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLDirectoryElement = HTMLDirectoryElement;
  }
});

// node_modules/linkedom/cjs/html/quote-element.js
var require_quote_element = __commonJS({
  "node_modules/linkedom/cjs/html/quote-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLQuoteElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "quote") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLQuoteElement = HTMLQuoteElement;
  }
});

// node_modules/linkedom/commonjs/canvas.cjs
var require_canvas = __commonJS({
  "node_modules/linkedom/commonjs/canvas.cjs"(exports, module) {
    try {
      module.exports = __require("canvas");
    } catch (fallback) {
      class Canvas {
        constructor(width, height) {
          this.width = width;
          this.height = height;
        }
        getContext() {
          return null;
        }
        toDataURL() {
          return "";
        }
      }
      module.exports = {
        createCanvas: (width, height) => new Canvas(width, height)
      };
    }
  }
});

// node_modules/linkedom/cjs/html/canvas-element.js
var require_canvas_element = __commonJS({
  "node_modules/linkedom/cjs/html/canvas-element.js"(exports) {
    "use strict";
    var { IMAGE } = require_symbols();
    var { registerHTMLClass } = require_register_html_class();
    var { numericAttribute } = require_attributes();
    var Canvas = ((m) => m.__esModule ? m.default : m)(require_canvas());
    var { HTMLElement } = require_element3();
    var { createCanvas } = Canvas;
    var tagName = "canvas";
    var HTMLCanvasElement = class extends HTMLElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
        this[IMAGE] = createCanvas(300, 150);
      }
      get width() {
        return this[IMAGE].width;
      }
      set width(value) {
        numericAttribute.set(this, "width", value);
        this[IMAGE].width = value;
      }
      get height() {
        return this[IMAGE].height;
      }
      set height(value) {
        numericAttribute.set(this, "height", value);
        this[IMAGE].height = value;
      }
      getContext(type) {
        return this[IMAGE].getContext(type);
      }
      toDataURL(...args) {
        return this[IMAGE].toDataURL(...args);
      }
    };
    registerHTMLClass(tagName, HTMLCanvasElement);
    exports.HTMLCanvasElement = HTMLCanvasElement;
  }
});

// node_modules/linkedom/cjs/html/legend-element.js
var require_legend_element = __commonJS({
  "node_modules/linkedom/cjs/html/legend-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLLegendElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "legend") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLLegendElement = HTMLLegendElement;
  }
});

// node_modules/linkedom/cjs/html/option-element.js
var require_option_element = __commonJS({
  "node_modules/linkedom/cjs/html/option-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLOptionElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "option") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLOptionElement = HTMLOptionElement;
  }
});

// node_modules/linkedom/cjs/html/span-element.js
var require_span_element = __commonJS({
  "node_modules/linkedom/cjs/html/span-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLSpanElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "span") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLSpanElement = HTMLSpanElement;
  }
});

// node_modules/linkedom/cjs/html/meter-element.js
var require_meter_element = __commonJS({
  "node_modules/linkedom/cjs/html/meter-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLMeterElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "meter") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLMeterElement = HTMLMeterElement;
  }
});

// node_modules/linkedom/cjs/html/video-element.js
var require_video_element = __commonJS({
  "node_modules/linkedom/cjs/html/video-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLVideoElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "video") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLVideoElement = HTMLVideoElement;
  }
});

// node_modules/linkedom/cjs/html/table-cell-element.js
var require_table_cell_element = __commonJS({
  "node_modules/linkedom/cjs/html/table-cell-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLTableCellElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "td") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLTableCellElement = HTMLTableCellElement;
  }
});

// node_modules/linkedom/cjs/html/title-element.js
var require_title_element = __commonJS({
  "node_modules/linkedom/cjs/html/title-element.js"(exports) {
    "use strict";
    var { registerHTMLClass } = require_register_html_class();
    var { TextElement } = require_text_element();
    var tagName = "title";
    var HTMLTitleElement = class extends TextElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
      }
    };
    registerHTMLClass(tagName, HTMLTitleElement);
    exports.HTMLTitleElement = HTMLTitleElement;
  }
});

// node_modules/linkedom/cjs/html/output-element.js
var require_output_element = __commonJS({
  "node_modules/linkedom/cjs/html/output-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLOutputElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "output") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLOutputElement = HTMLOutputElement;
  }
});

// node_modules/linkedom/cjs/html/table-row-element.js
var require_table_row_element = __commonJS({
  "node_modules/linkedom/cjs/html/table-row-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLTableRowElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "tr") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLTableRowElement = HTMLTableRowElement;
  }
});

// node_modules/linkedom/cjs/html/data-element.js
var require_data_element = __commonJS({
  "node_modules/linkedom/cjs/html/data-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLDataElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "data") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLDataElement = HTMLDataElement;
  }
});

// node_modules/linkedom/cjs/html/menu-element.js
var require_menu_element = __commonJS({
  "node_modules/linkedom/cjs/html/menu-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLMenuElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "menu") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLMenuElement = HTMLMenuElement;
  }
});

// node_modules/linkedom/cjs/html/select-element.js
var require_select_element = __commonJS({
  "node_modules/linkedom/cjs/html/select-element.js"(exports) {
    "use strict";
    var { registerHTMLClass } = require_register_html_class();
    var { booleanAttribute } = require_attributes();
    var { HTMLElement } = require_element3();
    var { NodeList } = require_node_list();
    var tagName = "select";
    var HTMLSelectElement = class extends HTMLElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
      }
      get options() {
        let children = new NodeList();
        let { firstElementChild } = this;
        while (firstElementChild) {
          if (firstElementChild.tagName === "OPTGROUP")
            children.push(...firstElementChild.children);
          else
            children.push(firstElementChild);
          firstElementChild = firstElementChild.nextElementSibling;
        }
        return children;
      }
      get disabled() {
        return booleanAttribute.get(this, "disabled");
      }
      set disabled(value) {
        booleanAttribute.set(this, "disabled", value);
      }
      get name() {
        return this.getAttribute("name");
      }
      set name(value) {
        this.setAttribute("name", value);
      }
    };
    registerHTMLClass(tagName, HTMLSelectElement);
    exports.HTMLSelectElement = HTMLSelectElement;
  }
});

// node_modules/linkedom/cjs/html/br-element.js
var require_br_element = __commonJS({
  "node_modules/linkedom/cjs/html/br-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLBRElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "br") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLBRElement = HTMLBRElement;
  }
});

// node_modules/linkedom/cjs/html/button-element.js
var require_button_element = __commonJS({
  "node_modules/linkedom/cjs/html/button-element.js"(exports) {
    "use strict";
    var { registerHTMLClass } = require_register_html_class();
    var { booleanAttribute } = require_attributes();
    var { HTMLElement } = require_element3();
    var tagName = "button";
    var HTMLButtonElement = class extends HTMLElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
      }
      get disabled() {
        return booleanAttribute.get(this, "disabled");
      }
      set disabled(value) {
        booleanAttribute.set(this, "disabled", value);
      }
      get name() {
        return this.getAttribute("name");
      }
      set name(value) {
        this.setAttribute("name", value);
      }
      get type() {
        return this.getAttribute("type");
      }
      set type(value) {
        this.setAttribute("type", value);
      }
    };
    registerHTMLClass(tagName, HTMLButtonElement);
    exports.HTMLButtonElement = HTMLButtonElement;
  }
});

// node_modules/linkedom/cjs/html/map-element.js
var require_map_element = __commonJS({
  "node_modules/linkedom/cjs/html/map-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLMapElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "map") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLMapElement = HTMLMapElement;
  }
});

// node_modules/linkedom/cjs/html/opt-group-element.js
var require_opt_group_element = __commonJS({
  "node_modules/linkedom/cjs/html/opt-group-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLOptGroupElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "optgroup") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLOptGroupElement = HTMLOptGroupElement;
  }
});

// node_modules/linkedom/cjs/html/d-list-element.js
var require_d_list_element = __commonJS({
  "node_modules/linkedom/cjs/html/d-list-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLDListElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "dl") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLDListElement = HTMLDListElement;
  }
});

// node_modules/linkedom/cjs/html/text-area-element.js
var require_text_area_element = __commonJS({
  "node_modules/linkedom/cjs/html/text-area-element.js"(exports) {
    "use strict";
    var { registerHTMLClass } = require_register_html_class();
    var { booleanAttribute } = require_attributes();
    var { TextElement } = require_text_element();
    var tagName = "textarea";
    var HTMLTextAreaElement = class extends TextElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
      }
      get disabled() {
        return booleanAttribute.get(this, "disabled");
      }
      set disabled(value) {
        booleanAttribute.set(this, "disabled", value);
      }
      get name() {
        return this.getAttribute("name");
      }
      set name(value) {
        this.setAttribute("name", value);
      }
      get placeholder() {
        return this.getAttribute("placeholder");
      }
      set placeholder(value) {
        this.setAttribute("placeholder", value);
      }
      get type() {
        return this.getAttribute("type");
      }
      set type(value) {
        this.setAttribute("type", value);
      }
      get value() {
        return this.textContent;
      }
      set value(content) {
        this.textContent = content;
      }
    };
    registerHTMLClass(tagName, HTMLTextAreaElement);
    exports.HTMLTextAreaElement = HTMLTextAreaElement;
  }
});

// node_modules/linkedom/cjs/html/font-element.js
var require_font_element = __commonJS({
  "node_modules/linkedom/cjs/html/font-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLFontElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "font") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLFontElement = HTMLFontElement;
  }
});

// node_modules/linkedom/cjs/html/div-element.js
var require_div_element = __commonJS({
  "node_modules/linkedom/cjs/html/div-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLDivElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "div") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLDivElement = HTMLDivElement;
  }
});

// node_modules/linkedom/cjs/html/link-element.js
var require_link_element = __commonJS({
  "node_modules/linkedom/cjs/html/link-element.js"(exports) {
    "use strict";
    var { registerHTMLClass } = require_register_html_class();
    var { booleanAttribute, stringAttribute } = require_attributes();
    var { HTMLElement } = require_element3();
    var tagName = "link";
    var HTMLLinkElement = class extends HTMLElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
      }
      get disabled() {
        return booleanAttribute.get(this, "disabled");
      }
      set disabled(value) {
        booleanAttribute.set(this, "disabled", value);
      }
      get href() {
        return stringAttribute.get(this, "href");
      }
      set href(value) {
        stringAttribute.set(this, "href", value);
      }
      get hreflang() {
        return stringAttribute.get(this, "hreflang");
      }
      set hreflang(value) {
        stringAttribute.set(this, "hreflang", value);
      }
      get media() {
        return stringAttribute.get(this, "media");
      }
      set media(value) {
        stringAttribute.set(this, "media", value);
      }
      get rel() {
        return stringAttribute.get(this, "rel");
      }
      set rel(value) {
        stringAttribute.set(this, "rel", value);
      }
      get type() {
        return stringAttribute.get(this, "type");
      }
      set type(value) {
        stringAttribute.set(this, "type", value);
      }
    };
    registerHTMLClass(tagName, HTMLLinkElement);
    exports.HTMLLinkElement = HTMLLinkElement;
  }
});

// node_modules/linkedom/cjs/html/slot-element.js
var require_slot_element = __commonJS({
  "node_modules/linkedom/cjs/html/slot-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLSlotElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "slot") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLSlotElement = HTMLSlotElement;
  }
});

// node_modules/linkedom/cjs/html/form-element.js
var require_form_element = __commonJS({
  "node_modules/linkedom/cjs/html/form-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLFormElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "form") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLFormElement = HTMLFormElement;
  }
});

// node_modules/linkedom/cjs/html/image-element.js
var require_image_element = __commonJS({
  "node_modules/linkedom/cjs/html/image-element.js"(exports) {
    "use strict";
    var { registerHTMLClass } = require_register_html_class();
    var { numericAttribute, stringAttribute } = require_attributes();
    var { HTMLElement } = require_element3();
    var tagName = "img";
    var HTMLImageElement = class extends HTMLElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
      }
      get alt() {
        return stringAttribute.get(this, "alt");
      }
      set alt(value) {
        stringAttribute.set(this, "alt", value);
      }
      get sizes() {
        return stringAttribute.get(this, "sizes");
      }
      set sizes(value) {
        stringAttribute.set(this, "sizes", value);
      }
      get src() {
        return stringAttribute.get(this, "src");
      }
      set src(value) {
        stringAttribute.set(this, "src", value);
      }
      get srcset() {
        return stringAttribute.get(this, "srcset");
      }
      set srcset(value) {
        stringAttribute.set(this, "srcset", value);
      }
      get title() {
        return stringAttribute.get(this, "title");
      }
      set title(value) {
        stringAttribute.set(this, "title", value);
      }
      get width() {
        return numericAttribute.get(this, "width");
      }
      set width(value) {
        numericAttribute.set(this, "width", value);
      }
      get height() {
        return numericAttribute.get(this, "height");
      }
      set height(value) {
        numericAttribute.set(this, "height", value);
      }
    };
    registerHTMLClass(tagName, HTMLImageElement);
    exports.HTMLImageElement = HTMLImageElement;
  }
});

// node_modules/linkedom/cjs/html/pre-element.js
var require_pre_element = __commonJS({
  "node_modules/linkedom/cjs/html/pre-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLPreElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "pre") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLPreElement = HTMLPreElement;
  }
});

// node_modules/linkedom/cjs/html/u-list-element.js
var require_u_list_element = __commonJS({
  "node_modules/linkedom/cjs/html/u-list-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLUListElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "ul") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLUListElement = HTMLUListElement;
  }
});

// node_modules/linkedom/cjs/html/meta-element.js
var require_meta_element = __commonJS({
  "node_modules/linkedom/cjs/html/meta-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLMetaElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "meta") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLMetaElement = HTMLMetaElement;
  }
});

// node_modules/linkedom/cjs/html/picture-element.js
var require_picture_element = __commonJS({
  "node_modules/linkedom/cjs/html/picture-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLPictureElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "picture") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLPictureElement = HTMLPictureElement;
  }
});

// node_modules/linkedom/cjs/html/area-element.js
var require_area_element = __commonJS({
  "node_modules/linkedom/cjs/html/area-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLAreaElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "area") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLAreaElement = HTMLAreaElement;
  }
});

// node_modules/linkedom/cjs/html/o-list-element.js
var require_o_list_element = __commonJS({
  "node_modules/linkedom/cjs/html/o-list-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLOListElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "ol") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLOListElement = HTMLOListElement;
  }
});

// node_modules/linkedom/cjs/html/table-caption-element.js
var require_table_caption_element = __commonJS({
  "node_modules/linkedom/cjs/html/table-caption-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLTableCaptionElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "caption") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLTableCaptionElement = HTMLTableCaptionElement;
  }
});

// node_modules/linkedom/cjs/html/anchor-element.js
var require_anchor_element = __commonJS({
  "node_modules/linkedom/cjs/html/anchor-element.js"(exports) {
    "use strict";
    var { registerHTMLClass } = require_register_html_class();
    var { stringAttribute } = require_attributes();
    var { HTMLElement } = require_element3();
    var tagName = "a";
    var HTMLAnchorElement = class extends HTMLElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
      }
      get href() {
        return encodeURI(stringAttribute.get(this, "href"));
      }
      set href(value) {
        stringAttribute.set(this, "href", decodeURI(value));
      }
      get download() {
        return encodeURI(stringAttribute.get(this, "download"));
      }
      set download(value) {
        stringAttribute.set(this, "download", decodeURI(value));
      }
      get target() {
        return stringAttribute.get(this, "target");
      }
      set target(value) {
        stringAttribute.set(this, "target", value);
      }
      get type() {
        return stringAttribute.get(this, "type");
      }
      set type(value) {
        stringAttribute.set(this, "type", value);
      }
    };
    registerHTMLClass(tagName, HTMLAnchorElement);
    exports.HTMLAnchorElement = HTMLAnchorElement;
  }
});

// node_modules/linkedom/cjs/html/label-element.js
var require_label_element = __commonJS({
  "node_modules/linkedom/cjs/html/label-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLLabelElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "label") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLLabelElement = HTMLLabelElement;
  }
});

// node_modules/linkedom/cjs/html/unknown-element.js
var require_unknown_element = __commonJS({
  "node_modules/linkedom/cjs/html/unknown-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLUnknownElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "unknown") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLUnknownElement = HTMLUnknownElement;
  }
});

// node_modules/linkedom/cjs/html/mod-element.js
var require_mod_element = __commonJS({
  "node_modules/linkedom/cjs/html/mod-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLModElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "mod") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLModElement = HTMLModElement;
  }
});

// node_modules/linkedom/cjs/html/details-element.js
var require_details_element = __commonJS({
  "node_modules/linkedom/cjs/html/details-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLDetailsElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "details") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLDetailsElement = HTMLDetailsElement;
  }
});

// node_modules/linkedom/cjs/html/source-element.js
var require_source_element = __commonJS({
  "node_modules/linkedom/cjs/html/source-element.js"(exports) {
    "use strict";
    var { registerHTMLClass } = require_register_html_class();
    var { stringAttribute } = require_attributes();
    var { HTMLElement } = require_element3();
    var tagName = "source";
    var HTMLSourceElement = class extends HTMLElement {
      constructor(ownerDocument, localName = tagName) {
        super(ownerDocument, localName);
      }
      get src() {
        return stringAttribute.get(this, "src");
      }
      set src(value) {
        stringAttribute.set(this, "src", value);
      }
      get srcset() {
        return stringAttribute.get(this, "srcset");
      }
      set srcset(value) {
        stringAttribute.set(this, "srcset", value);
      }
      get sizes() {
        return stringAttribute.get(this, "sizes");
      }
      set sizes(value) {
        stringAttribute.set(this, "sizes", value);
      }
      get type() {
        return stringAttribute.get(this, "type");
      }
      set type(value) {
        stringAttribute.set(this, "type", value);
      }
    };
    registerHTMLClass(tagName, HTMLSourceElement);
    exports.HTMLSourceElement = HTMLSourceElement;
  }
});

// node_modules/linkedom/cjs/html/track-element.js
var require_track_element = __commonJS({
  "node_modules/linkedom/cjs/html/track-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLTrackElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "track") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLTrackElement = HTMLTrackElement;
  }
});

// node_modules/linkedom/cjs/html/marquee-element.js
var require_marquee_element = __commonJS({
  "node_modules/linkedom/cjs/html/marquee-element.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var HTMLMarqueeElement = class extends HTMLElement {
      constructor(ownerDocument, localName = "marquee") {
        super(ownerDocument, localName);
      }
    };
    exports.HTMLMarqueeElement = HTMLMarqueeElement;
  }
});

// node_modules/linkedom/cjs/shared/html-classes.js
var require_html_classes = __commonJS({
  "node_modules/linkedom/cjs/shared/html-classes.js"(exports) {
    "use strict";
    var { HTMLElement } = require_element3();
    var { HTMLTemplateElement } = require_template_element();
    var { HTMLHtmlElement } = require_html_element();
    var { HTMLScriptElement } = require_script_element();
    var { HTMLFrameElement } = require_frame_element();
    var { HTMLIFrameElement } = require_i_frame_element();
    var { HTMLObjectElement } = require_object_element();
    var { HTMLHeadElement } = require_head_element();
    var { HTMLBodyElement } = require_body_element();
    var { HTMLStyleElement } = require_style_element();
    var { HTMLTimeElement } = require_time_element();
    var { HTMLFieldSetElement } = require_field_set_element();
    var { HTMLEmbedElement } = require_embed_element();
    var { HTMLHRElement } = require_hr_element();
    var { HTMLProgressElement } = require_progress_element();
    var { HTMLParagraphElement } = require_paragraph_element();
    var { HTMLTableElement } = require_table_element();
    var { HTMLFrameSetElement } = require_frame_set_element();
    var { HTMLLIElement } = require_li_element();
    var { HTMLBaseElement } = require_base_element();
    var { HTMLDataListElement } = require_data_list_element();
    var { HTMLInputElement } = require_input_element();
    var { HTMLParamElement } = require_param_element();
    var { HTMLMediaElement } = require_media_element();
    var { HTMLAudioElement } = require_audio_element();
    var { HTMLHeadingElement } = require_heading_element();
    var { HTMLDirectoryElement } = require_directory_element();
    var { HTMLQuoteElement } = require_quote_element();
    var { HTMLCanvasElement } = require_canvas_element();
    var { HTMLLegendElement } = require_legend_element();
    var { HTMLOptionElement } = require_option_element();
    var { HTMLSpanElement } = require_span_element();
    var { HTMLMeterElement } = require_meter_element();
    var { HTMLVideoElement } = require_video_element();
    var { HTMLTableCellElement } = require_table_cell_element();
    var { HTMLTitleElement } = require_title_element();
    var { HTMLOutputElement } = require_output_element();
    var { HTMLTableRowElement } = require_table_row_element();
    var { HTMLDataElement } = require_data_element();
    var { HTMLMenuElement } = require_menu_element();
    var { HTMLSelectElement } = require_select_element();
    var { HTMLBRElement } = require_br_element();
    var { HTMLButtonElement } = require_button_element();
    var { HTMLMapElement } = require_map_element();
    var { HTMLOptGroupElement } = require_opt_group_element();
    var { HTMLDListElement } = require_d_list_element();
    var { HTMLTextAreaElement } = require_text_area_element();
    var { HTMLFontElement } = require_font_element();
    var { HTMLDivElement } = require_div_element();
    var { HTMLLinkElement } = require_link_element();
    var { HTMLSlotElement } = require_slot_element();
    var { HTMLFormElement } = require_form_element();
    var { HTMLImageElement } = require_image_element();
    var { HTMLPreElement } = require_pre_element();
    var { HTMLUListElement } = require_u_list_element();
    var { HTMLMetaElement } = require_meta_element();
    var { HTMLPictureElement } = require_picture_element();
    var { HTMLAreaElement } = require_area_element();
    var { HTMLOListElement } = require_o_list_element();
    var { HTMLTableCaptionElement } = require_table_caption_element();
    var { HTMLAnchorElement } = require_anchor_element();
    var { HTMLLabelElement } = require_label_element();
    var { HTMLUnknownElement } = require_unknown_element();
    var { HTMLModElement } = require_mod_element();
    var { HTMLDetailsElement } = require_details_element();
    var { HTMLSourceElement } = require_source_element();
    var { HTMLTrackElement } = require_track_element();
    var { HTMLMarqueeElement } = require_marquee_element();
    exports.HTMLElement = HTMLElement;
    exports.HTMLTemplateElement = HTMLTemplateElement;
    exports.HTMLHtmlElement = HTMLHtmlElement;
    exports.HTMLScriptElement = HTMLScriptElement;
    exports.HTMLFrameElement = HTMLFrameElement;
    exports.HTMLIFrameElement = HTMLIFrameElement;
    exports.HTMLObjectElement = HTMLObjectElement;
    exports.HTMLHeadElement = HTMLHeadElement;
    exports.HTMLBodyElement = HTMLBodyElement;
    exports.HTMLStyleElement = HTMLStyleElement;
    exports.HTMLTimeElement = HTMLTimeElement;
    exports.HTMLFieldSetElement = HTMLFieldSetElement;
    exports.HTMLEmbedElement = HTMLEmbedElement;
    exports.HTMLHRElement = HTMLHRElement;
    exports.HTMLProgressElement = HTMLProgressElement;
    exports.HTMLParagraphElement = HTMLParagraphElement;
    exports.HTMLTableElement = HTMLTableElement;
    exports.HTMLFrameSetElement = HTMLFrameSetElement;
    exports.HTMLLIElement = HTMLLIElement;
    exports.HTMLBaseElement = HTMLBaseElement;
    exports.HTMLDataListElement = HTMLDataListElement;
    exports.HTMLInputElement = HTMLInputElement;
    exports.HTMLParamElement = HTMLParamElement;
    exports.HTMLMediaElement = HTMLMediaElement;
    exports.HTMLAudioElement = HTMLAudioElement;
    exports.HTMLHeadingElement = HTMLHeadingElement;
    exports.HTMLDirectoryElement = HTMLDirectoryElement;
    exports.HTMLQuoteElement = HTMLQuoteElement;
    exports.HTMLCanvasElement = HTMLCanvasElement;
    exports.HTMLLegendElement = HTMLLegendElement;
    exports.HTMLOptionElement = HTMLOptionElement;
    exports.HTMLSpanElement = HTMLSpanElement;
    exports.HTMLMeterElement = HTMLMeterElement;
    exports.HTMLVideoElement = HTMLVideoElement;
    exports.HTMLTableCellElement = HTMLTableCellElement;
    exports.HTMLTitleElement = HTMLTitleElement;
    exports.HTMLOutputElement = HTMLOutputElement;
    exports.HTMLTableRowElement = HTMLTableRowElement;
    exports.HTMLDataElement = HTMLDataElement;
    exports.HTMLMenuElement = HTMLMenuElement;
    exports.HTMLSelectElement = HTMLSelectElement;
    exports.HTMLBRElement = HTMLBRElement;
    exports.HTMLButtonElement = HTMLButtonElement;
    exports.HTMLMapElement = HTMLMapElement;
    exports.HTMLOptGroupElement = HTMLOptGroupElement;
    exports.HTMLDListElement = HTMLDListElement;
    exports.HTMLTextAreaElement = HTMLTextAreaElement;
    exports.HTMLFontElement = HTMLFontElement;
    exports.HTMLDivElement = HTMLDivElement;
    exports.HTMLLinkElement = HTMLLinkElement;
    exports.HTMLSlotElement = HTMLSlotElement;
    exports.HTMLFormElement = HTMLFormElement;
    exports.HTMLImageElement = HTMLImageElement;
    exports.HTMLPreElement = HTMLPreElement;
    exports.HTMLUListElement = HTMLUListElement;
    exports.HTMLMetaElement = HTMLMetaElement;
    exports.HTMLPictureElement = HTMLPictureElement;
    exports.HTMLAreaElement = HTMLAreaElement;
    exports.HTMLOListElement = HTMLOListElement;
    exports.HTMLTableCaptionElement = HTMLTableCaptionElement;
    exports.HTMLAnchorElement = HTMLAnchorElement;
    exports.HTMLLabelElement = HTMLLabelElement;
    exports.HTMLUnknownElement = HTMLUnknownElement;
    exports.HTMLModElement = HTMLModElement;
    exports.HTMLDetailsElement = HTMLDetailsElement;
    exports.HTMLSourceElement = HTMLSourceElement;
    exports.HTMLTrackElement = HTMLTrackElement;
    exports.HTMLMarqueeElement = HTMLMarqueeElement;
    var HTMLClasses = {
      HTMLElement,
      HTMLTemplateElement,
      HTMLHtmlElement,
      HTMLScriptElement,
      HTMLFrameElement,
      HTMLIFrameElement,
      HTMLObjectElement,
      HTMLHeadElement,
      HTMLBodyElement,
      HTMLStyleElement,
      HTMLTimeElement,
      HTMLFieldSetElement,
      HTMLEmbedElement,
      HTMLHRElement,
      HTMLProgressElement,
      HTMLParagraphElement,
      HTMLTableElement,
      HTMLFrameSetElement,
      HTMLLIElement,
      HTMLBaseElement,
      HTMLDataListElement,
      HTMLInputElement,
      HTMLParamElement,
      HTMLMediaElement,
      HTMLAudioElement,
      HTMLHeadingElement,
      HTMLDirectoryElement,
      HTMLQuoteElement,
      HTMLCanvasElement,
      HTMLLegendElement,
      HTMLOptionElement,
      HTMLSpanElement,
      HTMLMeterElement,
      HTMLVideoElement,
      HTMLTableCellElement,
      HTMLTitleElement,
      HTMLOutputElement,
      HTMLTableRowElement,
      HTMLDataElement,
      HTMLMenuElement,
      HTMLSelectElement,
      HTMLBRElement,
      HTMLButtonElement,
      HTMLMapElement,
      HTMLOptGroupElement,
      HTMLDListElement,
      HTMLTextAreaElement,
      HTMLFontElement,
      HTMLDivElement,
      HTMLLinkElement,
      HTMLSlotElement,
      HTMLFormElement,
      HTMLImageElement,
      HTMLPreElement,
      HTMLUListElement,
      HTMLMetaElement,
      HTMLPictureElement,
      HTMLAreaElement,
      HTMLOListElement,
      HTMLTableCaptionElement,
      HTMLAnchorElement,
      HTMLLabelElement,
      HTMLUnknownElement,
      HTMLModElement,
      HTMLDetailsElement,
      HTMLSourceElement,
      HTMLTrackElement,
      HTMLMarqueeElement
    };
    exports.HTMLClasses = HTMLClasses;
  }
});

// node_modules/linkedom/cjs/shared/mime.js
var require_mime = __commonJS({
  "node_modules/linkedom/cjs/shared/mime.js"(exports) {
    "use strict";
    var voidElements = { test: () => true };
    var Mime = {
      "text/html": {
        docType: "<!DOCTYPE html>",
        ignoreCase: true,
        voidElements: /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i
      },
      "image/svg+xml": {
        docType: '<?xml version="1.0" encoding="utf-8"?>',
        ignoreCase: false,
        voidElements
      },
      "text/xml": {
        docType: '<?xml version="1.0" encoding="utf-8"?>',
        ignoreCase: false,
        voidElements
      },
      "application/xml": {
        docType: '<?xml version="1.0" encoding="utf-8"?>',
        ignoreCase: false,
        voidElements
      },
      "application/xhtml+xml": {
        docType: '<?xml version="1.0" encoding="utf-8"?>',
        ignoreCase: false,
        voidElements
      }
    };
    exports.Mime = Mime;
  }
});

// node_modules/linkedom/cjs/interface/custom-event.js
var require_custom_event = __commonJS({
  "node_modules/linkedom/cjs/interface/custom-event.js"(exports) {
    "use strict";
    var { Event } = require_event();
    var GlobalCustomEvent = typeof CustomEvent === "function" ? CustomEvent : class CustomEvent extends Event {
      constructor(type, eventInitDict = {}) {
        super(type, eventInitDict);
        this.detail = eventInitDict.detail;
      }
    };
    exports.CustomEvent = GlobalCustomEvent;
  }
});

// node_modules/linkedom/cjs/interface/input-event.js
var require_input_event = __commonJS({
  "node_modules/linkedom/cjs/interface/input-event.js"(exports) {
    "use strict";
    var { Event } = require_event();
    var InputEvent = class extends Event {
      constructor(type, inputEventInit = {}) {
        super(type, inputEventInit);
        this.inputType = inputEventInit.inputType;
        this.data = inputEventInit.data;
        this.dataTransfer = inputEventInit.dataTransfer;
        this.isComposing = inputEventInit.isComposing || false;
        this.ranges = inputEventInit.ranges;
      }
    };
    exports.InputEvent = InputEvent;
  }
});

// node_modules/linkedom/cjs/interface/image.js
var require_image = __commonJS({
  "node_modules/linkedom/cjs/interface/image.js"(exports) {
    "use strict";
    var { HTMLImageElement } = require_image_element();
    var ImageClass = (ownerDocument) => class Image extends HTMLImageElement {
      constructor(width, height) {
        super(ownerDocument);
        switch (arguments.length) {
          case 1:
            this.height = width;
            this.width = width;
            break;
          case 2:
            this.height = height;
            this.width = width;
            break;
        }
      }
    };
    exports.ImageClass = ImageClass;
  }
});

// node_modules/linkedom/cjs/interface/range.js
var require_range = __commonJS({
  "node_modules/linkedom/cjs/interface/range.js"(exports) {
    "use strict";
    var { END, NEXT, PREV, START } = require_symbols();
    var { getEnd, setAdjacent } = require_utils();
    var deleteContents = ({ [START]: start, [END]: end }, fragment = null) => {
      setAdjacent(start[PREV], end[NEXT]);
      do {
        const after = getEnd(start);
        const next = after === end ? after : after[NEXT];
        if (fragment)
          fragment.insertBefore(start, fragment[END]);
        else
          start.remove();
        start = next;
      } while (start !== end);
    };
    var Range = class {
      constructor() {
        this[START] = null;
        this[END] = null;
        this.commonAncestorContainer = null;
      }
      insertNode(newNode) {
        this[END].parentNode.insertBefore(newNode, this[START]);
      }
      selectNode(node) {
        this[START] = node;
        this[END] = getEnd(node);
      }
      surroundContents(parentNode) {
        parentNode.replaceChildren(this.extractContents());
      }
      setStartBefore(node) {
        this[START] = node;
      }
      setStartAfter(node) {
        this[START] = node.nextSibling;
      }
      setEndBefore(node) {
        this[END] = getEnd(node.previousSibling);
      }
      setEndAfter(node) {
        this[END] = getEnd(node);
      }
      cloneContents() {
        let { [START]: start, [END]: end } = this;
        const fragment = start.ownerDocument.createDocumentFragment();
        while (start !== end) {
          fragment.insertBefore(start.cloneNode(true), fragment[END]);
          start = getEnd(start);
          if (start !== end)
            start = start[NEXT];
        }
        return fragment;
      }
      deleteContents() {
        deleteContents(this);
      }
      extractContents() {
        const fragment = this[START].ownerDocument.createDocumentFragment();
        deleteContents(this, fragment);
        return fragment;
      }
      createContextualFragment(html) {
        const template = this.commonAncestorContainer.createElement("template");
        template.innerHTML = html;
        this.selectNode(template.content);
        return template.content;
      }
      cloneRange() {
        const range = new Range();
        range[START] = this[START];
        range[END] = this[END];
        return range;
      }
    };
    exports.Range = Range;
  }
});

// node_modules/linkedom/cjs/interface/tree-walker.js
var require_tree_walker = __commonJS({
  "node_modules/linkedom/cjs/interface/tree-walker.js"(exports) {
    "use strict";
    var {
      DOCUMENT_NODE,
      ELEMENT_NODE,
      TEXT_NODE,
      COMMENT_NODE,
      SHOW_ALL,
      SHOW_ELEMENT,
      SHOW_COMMENT,
      SHOW_TEXT
    } = require_constants();
    var { PRIVATE, END, NEXT } = require_symbols();
    var isOK = ({ nodeType }, mask) => {
      switch (nodeType) {
        case ELEMENT_NODE:
          return mask & SHOW_ELEMENT;
        case TEXT_NODE:
          return mask & SHOW_TEXT;
        case COMMENT_NODE:
          return mask & SHOW_COMMENT;
      }
      return 0;
    };
    var TreeWalker = class {
      constructor(root, whatToShow = SHOW_ALL) {
        this.root = root;
        this.currentNode = root;
        this.whatToShow = whatToShow;
        let { [NEXT]: next, [END]: end } = root;
        if (root.nodeType === DOCUMENT_NODE) {
          const { documentElement } = root;
          next = documentElement;
          end = documentElement[END];
        }
        const nodes = [];
        while (next !== end) {
          if (isOK(next, whatToShow))
            nodes.push(next);
          next = next[NEXT];
        }
        this[PRIVATE] = { i: 0, nodes };
      }
      nextNode() {
        const $ = this[PRIVATE];
        this.currentNode = $.i < $.nodes.length ? $.nodes[$.i++] : null;
        return this.currentNode;
      }
    };
    exports.TreeWalker = TreeWalker;
  }
});

// node_modules/linkedom/cjs/interface/document.js
var require_document = __commonJS({
  "node_modules/linkedom/cjs/interface/document.js"(exports) {
    "use strict";
    var { performance } = require_perf_hooks();
    var { DOCUMENT_NODE, DOCUMENT_FRAGMENT_NODE, DOCUMENT_TYPE_NODE, ELEMENT_NODE, SVG_NAMESPACE } = require_constants();
    var {
      CUSTOM_ELEMENTS,
      DOM_PARSER,
      GLOBALS,
      IMAGE,
      MUTATION_OBSERVER,
      DOCTYPE,
      END,
      NEXT,
      MIME,
      EVENT_TARGET,
      UPGRADE
    } = require_symbols();
    var { Facades, illegalConstructor } = require_facades();
    var { HTMLClasses } = require_html_classes();
    var { Mime } = require_mime();
    var { knownSiblings } = require_utils();
    var { assign, create, defineProperties, setPrototypeOf } = require_object();
    var { NonElementParentNode } = require_non_element_parent_node();
    var { SVGElement } = require_element2();
    var { Attr } = require_attr();
    var { Comment } = require_comment();
    var { CustomElementRegistry } = require_custom_element_registry();
    var { CustomEvent: CustomEvent2 } = require_custom_event();
    var { DocumentFragment } = require_document_fragment();
    var { DocumentType: DocumentType2 } = require_document_type();
    var { Element: Element2 } = require_element();
    var { Event } = require_event();
    var { EventTarget } = require_event_target();
    var { InputEvent } = require_input_event();
    var { ImageClass } = require_image();
    var { MutationObserverClass } = require_mutation_observer();
    var { NamedNodeMap } = require_named_node_map();
    var { NodeList } = require_node_list();
    var { Range } = require_range();
    var { Text } = require_text();
    var { TreeWalker } = require_tree_walker();
    var query = (method, ownerDocument, selectors) => {
      let { [NEXT]: next, [END]: end } = ownerDocument;
      return method.call({ ownerDocument, [NEXT]: next, [END]: end }, selectors);
    };
    var globalExports = assign({}, Facades, HTMLClasses, {
      CustomEvent: CustomEvent2,
      Event,
      EventTarget,
      InputEvent,
      NamedNodeMap,
      NodeList
    });
    var window2 = /* @__PURE__ */ new WeakMap();
    var Document = class extends NonElementParentNode {
      constructor(type) {
        super(null, "#document", DOCUMENT_NODE);
        this[CUSTOM_ELEMENTS] = { active: false, registry: null };
        this[MUTATION_OBSERVER] = { active: false, class: null };
        this[MIME] = Mime[type];
        this[DOCTYPE] = null;
        this[DOM_PARSER] = null;
        this[GLOBALS] = null;
        this[IMAGE] = null;
        this[UPGRADE] = null;
      }
      get defaultView() {
        if (!window2.has(this))
          window2.set(this, new Proxy(globalThis, {
            set: (target, name, value) => {
              switch (name) {
                case "addEventListener":
                case "removeEventListener":
                case "dispatchEvent":
                  this[EVENT_TARGET][name] = value;
                  break;
                default:
                  target[name] = value;
                  break;
              }
              return true;
            },
            get: (globalThis2, name) => {
              switch (name) {
                case "addEventListener":
                case "removeEventListener":
                case "dispatchEvent":
                  if (!this[EVENT_TARGET]) {
                    const et = this[EVENT_TARGET] = new EventTarget();
                    et.dispatchEvent = et.dispatchEvent.bind(et);
                    et.addEventListener = et.addEventListener.bind(et);
                    et.removeEventListener = et.removeEventListener.bind(et);
                  }
                  return this[EVENT_TARGET][name];
                case "document":
                  return this;
                case "navigator":
                  return {
                    userAgent: "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"
                  };
                case "window":
                  return window2.get(this);
                case "customElements":
                  if (!this[CUSTOM_ELEMENTS].registry)
                    this[CUSTOM_ELEMENTS] = new CustomElementRegistry(this);
                  return this[CUSTOM_ELEMENTS];
                case "performance":
                  return performance;
                case "DOMParser":
                  return this[DOM_PARSER];
                case "Image":
                  if (!this[IMAGE])
                    this[IMAGE] = ImageClass(this);
                  return this[IMAGE];
                case "MutationObserver":
                  if (!this[MUTATION_OBSERVER].class)
                    this[MUTATION_OBSERVER] = new MutationObserverClass(this);
                  return this[MUTATION_OBSERVER].class;
              }
              return this[GLOBALS] && this[GLOBALS][name] || globalExports[name] || globalThis2[name];
            }
          }));
        return window2.get(this);
      }
      get doctype() {
        const docType = this[DOCTYPE];
        if (docType)
          return docType;
        const { firstChild } = this;
        if (firstChild && firstChild.nodeType === DOCUMENT_TYPE_NODE)
          return this[DOCTYPE] = firstChild;
        return null;
      }
      set doctype(value) {
        if (/^([a-z:]+)(\s+system|\s+public(\s+"([^"]+)")?)?(\s+"([^"]+)")?/i.test(value)) {
          const { $1: name, $4: publicId, $6: systemId } = RegExp;
          this[DOCTYPE] = new DocumentType2(this, name, publicId, systemId);
          knownSiblings(this, this[DOCTYPE], this[NEXT]);
        }
      }
      get documentElement() {
        return this.firstElementChild;
      }
      get isConnected() {
        return true;
      }
      _getParent() {
        return this[EVENT_TARGET];
      }
      createAttribute(name) {
        return new Attr(this, name);
      }
      createComment(textContent) {
        return new Comment(this, textContent);
      }
      createDocumentFragment() {
        return new DocumentFragment(this);
      }
      createDocumentType(name, publicId, systemId) {
        return new DocumentType2(this, name, publicId, systemId);
      }
      createElement(localName) {
        return new Element2(this, localName);
      }
      createRange() {
        const range = new Range();
        range.commonAncestorContainer = this;
        return range;
      }
      createTextNode(textContent) {
        return new Text(this, textContent);
      }
      createTreeWalker(root, whatToShow = -1) {
        return new TreeWalker(root, whatToShow);
      }
      createNodeIterator(root, whatToShow = -1) {
        return this.createTreeWalker(root, whatToShow);
      }
      createEvent(name) {
        const event = create(name === "Event" ? new Event("") : new CustomEvent2(""));
        event.initEvent = event.initCustomEvent = (type, canBubble = false, cancelable = false, detail) => {
          defineProperties(event, {
            type: { value: type },
            canBubble: { value: canBubble },
            cancelable: { value: cancelable },
            detail: { value: detail }
          });
        };
        return event;
      }
      cloneNode(deep = false) {
        const {
          constructor,
          [CUSTOM_ELEMENTS]: customElements,
          [DOCTYPE]: doctype
        } = this;
        const document2 = new constructor();
        document2[CUSTOM_ELEMENTS] = customElements;
        if (deep) {
          const end = document2[END];
          const { childNodes } = this;
          for (let { length } = childNodes, i = 0; i < length; i++)
            document2.insertBefore(childNodes[i].cloneNode(true), end);
          if (doctype)
            document2[DOCTYPE] = childNodes[0];
        }
        return document2;
      }
      importNode(externalNode) {
        const deep = 1 < arguments.length && !!arguments[1];
        const node = externalNode.cloneNode(deep);
        const { [CUSTOM_ELEMENTS]: customElements } = this;
        const { active } = customElements;
        const upgrade = (element) => {
          const { ownerDocument, nodeType } = element;
          element.ownerDocument = this;
          if (active && ownerDocument !== this && nodeType === ELEMENT_NODE)
            customElements.upgrade(element);
        };
        upgrade(node);
        if (deep) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE: {
              let { [NEXT]: next, [END]: end } = node;
              while (next !== end) {
                if (next.nodeType === ELEMENT_NODE)
                  upgrade(next);
                next = next[NEXT];
              }
              break;
            }
          }
        }
        return node;
      }
      toString() {
        return this.childNodes.join("");
      }
      querySelector(selectors) {
        return query(super.querySelector, this, selectors);
      }
      querySelectorAll(selectors) {
        return query(super.querySelectorAll, this, selectors);
      }
      getElementsByTagNameNS(_, name) {
        return this.getElementsByTagName(name);
      }
      createAttributeNS(_, name) {
        return this.createAttribute(name);
      }
      createElementNS(nsp, localName, options) {
        return nsp === SVG_NAMESPACE ? new SVGElement(this, localName, null) : this.createElement(localName, options);
      }
    };
    exports.Document = Document;
    setPrototypeOf(globalExports.Document = function Document2() {
      illegalConstructor();
    }, Document).prototype = Document.prototype;
  }
});

// node_modules/linkedom/cjs/html/document.js
var require_document2 = __commonJS({
  "node_modules/linkedom/cjs/html/document.js"(exports) {
    "use strict";
    var { ELEMENT_NODE } = require_constants();
    var { CUSTOM_ELEMENTS, END, NEXT } = require_symbols();
    var { htmlClasses } = require_register_html_class();
    var { Document } = require_document();
    var { NodeList } = require_node_list();
    var { customElements } = require_custom_element_registry();
    var { HTMLElement } = require_element3();
    var createHTMLElement = (ownerDocument, builtin, localName, options) => {
      if (!builtin && htmlClasses.has(localName)) {
        const Class = htmlClasses.get(localName);
        return new Class(ownerDocument, localName);
      }
      const { [CUSTOM_ELEMENTS]: { active, registry } } = ownerDocument;
      if (active) {
        const ce = builtin ? options.is : localName;
        if (registry.has(ce)) {
          const { Class } = registry.get(ce);
          const element = new Class(ownerDocument, localName);
          customElements.set(element, { connected: false });
          return element;
        }
      }
      return new HTMLElement(ownerDocument, localName);
    };
    var HTMLDocument = class extends Document {
      constructor() {
        super("text/html");
      }
      get all() {
        const nodeList = new NodeList();
        let { [NEXT]: next, [END]: end } = this;
        while (next !== end) {
          switch (next.nodeType) {
            case ELEMENT_NODE:
              nodeList.push(next);
              break;
          }
          next = next[NEXT];
        }
        return nodeList;
      }
      get head() {
        const { documentElement } = this;
        let { firstElementChild } = documentElement;
        if (!firstElementChild || firstElementChild.tagName !== "HEAD") {
          firstElementChild = this.createElement("head");
          documentElement.prepend(firstElementChild);
        }
        return firstElementChild;
      }
      get body() {
        const { head } = this;
        let { nextElementSibling } = head;
        if (!nextElementSibling || nextElementSibling.tagName !== "BODY") {
          nextElementSibling = this.createElement("body");
          head.after(nextElementSibling);
        }
        return nextElementSibling;
      }
      get title() {
        const { head } = this;
        let title = head.getElementsByTagName("title").shift();
        return title ? title.textContent : "";
      }
      set title(textContent) {
        const { head } = this;
        let title = head.getElementsByTagName("title").shift();
        if (title)
          title.textContent = textContent;
        else {
          head.insertBefore(this.createElement("title"), head.firstChild).textContent = textContent;
        }
      }
      createElement(localName, options) {
        const builtin = !!(options && options.is);
        const element = createHTMLElement(this, builtin, localName, options);
        if (builtin)
          element.setAttribute("is", options.is);
        return element;
      }
    };
    exports.HTMLDocument = HTMLDocument;
  }
});

// node_modules/linkedom/cjs/svg/document.js
var require_document3 = __commonJS({
  "node_modules/linkedom/cjs/svg/document.js"(exports) {
    "use strict";
    var { MIME } = require_symbols();
    var { Document } = require_document();
    var SVGDocument = class extends Document {
      constructor() {
        super("image/svg+xml");
      }
      toString() {
        return this[MIME].docType + super.toString();
      }
    };
    exports.SVGDocument = SVGDocument;
  }
});

// node_modules/linkedom/cjs/xml/document.js
var require_document4 = __commonJS({
  "node_modules/linkedom/cjs/xml/document.js"(exports) {
    "use strict";
    var { MIME } = require_symbols();
    var { Document } = require_document();
    var XMLDocument = class extends Document {
      constructor() {
        super("text/xml");
      }
      toString() {
        return this[MIME].docType + super.toString();
      }
    };
    exports.XMLDocument = XMLDocument;
  }
});

// node_modules/linkedom/cjs/dom/parser.js
var require_parser = __commonJS({
  "node_modules/linkedom/cjs/dom/parser.js"(exports) {
    "use strict";
    var { DOM_PARSER, GLOBALS } = require_symbols();
    var { parseFromString } = require_parse_from_string();
    var { HTMLDocument } = require_document2();
    var { SVGDocument } = require_document3();
    var { XMLDocument } = require_document4();
    var DOMParser = class {
      parseFromString(markupLanguage, mimeType, globals = null) {
        let isHTML = false, document2;
        if (mimeType === "text/html") {
          isHTML = true;
          document2 = new HTMLDocument();
        } else if (mimeType === "image/svg+xml")
          document2 = new SVGDocument();
        else
          document2 = new XMLDocument();
        document2[DOM_PARSER] = DOMParser;
        if (globals)
          document2[GLOBALS] = globals;
        return markupLanguage ? parseFromString(document2, isHTML, markupLanguage) : document2;
      }
    };
    exports.DOMParser = DOMParser;
  }
});

// node_modules/linkedom/cjs/shared/parse-json.js
var require_parse_json = __commonJS({
  "node_modules/linkedom/cjs/shared/parse-json.js"(exports) {
    "use strict";
    var {
      NODE_END,
      ELEMENT_NODE,
      ATTRIBUTE_NODE,
      TEXT_NODE,
      COMMENT_NODE,
      DOCUMENT_NODE,
      DOCUMENT_TYPE_NODE,
      DOCUMENT_FRAGMENT_NODE
    } = require_constants();
    var { END, PREV } = require_symbols();
    var { htmlClasses } = require_register_html_class();
    var { knownBoundaries, knownSiblings } = require_utils();
    var { Attr } = require_attr();
    var { Comment } = require_comment();
    var { DocumentType: DocumentType2 } = require_document_type();
    var { Text } = require_text();
    var { HTMLDocument } = require_document2();
    var { HTMLElement } = require_element3();
    var { SVGElement } = require_element2();
    var { parse } = JSON;
    var append = (parentNode, node, end) => {
      node.parentNode = parentNode;
      knownSiblings(end[PREV], node, end);
    };
    var createHTMLElement = (ownerDocument, localName) => {
      if (htmlClasses.has(localName)) {
        const Class = htmlClasses.get(localName);
        return new Class(ownerDocument, localName);
      }
      return new HTMLElement(ownerDocument, localName);
    };
    var parseJSON = (value) => {
      const array = typeof value === "string" ? parse(value) : value;
      const { length } = array;
      const document2 = new HTMLDocument();
      let parentNode = document2, end = parentNode[END], svg = false, i = 0;
      while (i < length) {
        let nodeType = array[i++];
        switch (nodeType) {
          case ELEMENT_NODE: {
            const localName = array[i++];
            const isSVG = svg || localName === "svg" || localName === "SVG";
            const element = isSVG ? new SVGElement(document2, localName, parentNode.ownerSVGElement || null) : createHTMLElement(document2, localName);
            knownBoundaries(end[PREV], element, end);
            element.parentNode = parentNode;
            parentNode = element;
            end = parentNode[END];
            svg = isSVG;
            break;
          }
          case ATTRIBUTE_NODE: {
            const name = array[i++];
            const value2 = typeof array[i] === "string" ? array[i++] : "";
            const attr = new Attr(document2, name, value2);
            attr.ownerElement = parentNode;
            knownSiblings(end[PREV], attr, end);
            break;
          }
          case TEXT_NODE:
            append(parentNode, new Text(document2, array[i++]), end);
            break;
          case COMMENT_NODE:
            append(parentNode, new Comment(document2, array[i++]), end);
            break;
          case DOCUMENT_TYPE_NODE: {
            const args = [document2];
            while (typeof array[i] === "string")
              args.push(array[i++]);
            if (args.length === 3 && /\.dtd$/i.test(args[2]))
              args.splice(2, 0, "");
            append(parentNode, new DocumentType2(...args), end);
            break;
          }
          case DOCUMENT_FRAGMENT_NODE:
            parentNode = document2.createDocumentFragment();
            end = parentNode[END];
          case DOCUMENT_NODE:
            break;
          default:
            do {
              nodeType -= NODE_END;
              if (svg && !parentNode.ownerSVGElement)
                svg = false;
              parentNode = parentNode.parentNode || parentNode;
            } while (nodeType < 0);
            end = parentNode[END];
            break;
        }
      }
      switch (i && array[0]) {
        case ELEMENT_NODE:
          return document2.firstElementChild;
        case DOCUMENT_FRAGMENT_NODE:
          return parentNode;
      }
      return document2;
    };
    exports.parseJSON = parseJSON;
    var toJSON = (node) => node.toJSON();
    exports.toJSON = toJSON;
  }
});

// node_modules/linkedom/cjs/interface/node-filter.js
var require_node_filter = __commonJS({
  "node_modules/linkedom/cjs/interface/node-filter.js"(exports) {
    "use strict";
    var {
      SHOW_ALL,
      SHOW_ELEMENT,
      SHOW_COMMENT,
      SHOW_TEXT
    } = require_constants();
    var NodeFilter = class {
      static get SHOW_ALL() {
        return SHOW_ALL;
      }
      static get SHOW_ELEMENT() {
        return SHOW_ELEMENT;
      }
      static get SHOW_COMMENT() {
        return SHOW_COMMENT;
      }
      static get SHOW_TEXT() {
        return SHOW_TEXT;
      }
    };
    exports.NodeFilter = NodeFilter;
  }
});

// node_modules/linkedom/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/linkedom/cjs/index.js"(exports) {
    "use strict";
    var { DOMParser } = require_parser();
    var { Document: _Document } = require_document();
    var { illegalConstructor } = require_facades();
    var { setPrototypeOf } = require_object();
    ((m) => {
      exports.parseJSON = m.parseJSON;
      exports.toJSON = m.toJSON;
    })(require_parse_json());
    ((m) => Object.keys(m).map((k) => k !== "default" && (exports[k] = m[k])))(require_facades());
    ((m) => Object.keys(m).map((k) => k !== "default" && (exports[k] = m[k])))(require_html_classes());
    exports.DOMParser = DOMParser;
    ((m) => {
      exports.CustomEvent = m.CustomEvent;
    })(require_custom_event());
    ((m) => {
      exports.Event = m.Event;
    })(require_event());
    ((m) => {
      exports.EventTarget = m.EventTarget;
    })(require_event_target());
    ((m) => {
      exports.InputEvent = m.InputEvent;
    })(require_input_event());
    ((m) => {
      exports.NodeList = m.NodeList;
    })(require_node_list());
    ((m) => {
      exports.NodeFilter = m.NodeFilter;
    })(require_node_filter());
    var parseHTML = (html, globals = null) => new DOMParser().parseFromString(html, "text/html", globals).defaultView;
    exports.parseHTML = parseHTML;
    function Document() {
      illegalConstructor();
    }
    exports.Document = Document;
    setPrototypeOf(Document, _Document).prototype = _Document.prototype;
  }
});

// node_modules/abcjs/src/parse/abc_common.js
var require_abc_common = __commonJS({
  "node_modules/abcjs/src/parse/abc_common.js"(exports, module) {
    var parseCommon = {};
    parseCommon.clone = function(source) {
      var destination = {};
      for (var property in source)
        if (source.hasOwnProperty(property))
          destination[property] = source[property];
      return destination;
    };
    parseCommon.cloneArray = function(source) {
      var destination = [];
      for (var i = 0; i < source.length; i++) {
        destination.push(parseCommon.clone(source[i]));
      }
      return destination;
    };
    parseCommon.cloneHashOfHash = function(source) {
      var destination = {};
      for (var property in source)
        if (source.hasOwnProperty(property))
          destination[property] = parseCommon.clone(source[property]);
      return destination;
    };
    parseCommon.cloneHashOfArrayOfHash = function(source) {
      var destination = {};
      for (var property in source)
        if (source.hasOwnProperty(property))
          destination[property] = parseCommon.cloneArray(source[property]);
      return destination;
    };
    parseCommon.gsub = function(source, pattern, replacement) {
      return source.split(pattern).join(replacement);
    };
    parseCommon.strip = function(str) {
      return str.replace(/^\s+/, "").replace(/\s+$/, "");
    };
    parseCommon.startsWith = function(str, pattern) {
      return str.indexOf(pattern) === 0;
    };
    parseCommon.endsWith = function(str, pattern) {
      var d = str.length - pattern.length;
      return d >= 0 && str.lastIndexOf(pattern) === d;
    };
    parseCommon.each = function(arr, iterator, context) {
      for (var i = 0, length = arr.length; i < length; i++)
        iterator.apply(context, [arr[i], i]);
    };
    parseCommon.last = function(arr) {
      if (arr.length === 0)
        return null;
      return arr[arr.length - 1];
    };
    parseCommon.compact = function(arr) {
      var output = [];
      for (var i = 0; i < arr.length; i++) {
        if (arr[i])
          output.push(arr[i]);
      }
      return output;
    };
    parseCommon.detect = function(arr, iterator) {
      for (var i = 0; i < arr.length; i++) {
        if (iterator(arr[i]))
          return true;
      }
      return false;
    };
    try {
      (function(arr) {
        arr.forEach(function(item) {
          if (item.hasOwnProperty("remove")) {
            return;
          }
          Object.defineProperty(item, "remove", {
            configurable: true,
            enumerable: true,
            writable: true,
            value: function remove() {
              if (this.parentNode !== null)
                this.parentNode.removeChild(this);
            }
          });
        });
      })([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
    } catch (e) {
    }
    module.exports = parseCommon;
  }
});

// node_modules/abcjs/src/parse/abc_parse_directive.js
var require_abc_parse_directive = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_directive.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseDirective = {};
    (function() {
      "use strict";
      var tokenizer;
      var warn;
      var multilineVars;
      var tune;
      var tuneBuilder;
      parseDirective.initialize = function(tokenizer_, warn_, multilineVars_, tune_, tuneBuilder_) {
        tokenizer = tokenizer_;
        warn = warn_;
        multilineVars = multilineVars_;
        tune = tune_;
        tuneBuilder = tuneBuilder_;
        initializeFonts();
      };
      function initializeFonts() {
        multilineVars.annotationfont = { face: "Helvetica", size: 12, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.gchordfont = { face: "Helvetica", size: 12, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.historyfont = { face: '"Times New Roman"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.infofont = { face: '"Times New Roman"', size: 14, weight: "normal", style: "italic", decoration: "none" };
        multilineVars.measurefont = { face: '"Times New Roman"', size: 14, weight: "normal", style: "italic", decoration: "none" };
        multilineVars.partsfont = { face: '"Times New Roman"', size: 15, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.repeatfont = { face: '"Times New Roman"', size: 13, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.textfont = { face: '"Times New Roman"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.tripletfont = { face: "Times", size: 11, weight: "normal", style: "italic", decoration: "none" };
        multilineVars.vocalfont = { face: '"Times New Roman"', size: 13, weight: "bold", style: "normal", decoration: "none" };
        multilineVars.wordsfont = { face: '"Times New Roman"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.composerfont = { face: '"Times New Roman"', size: 14, weight: "normal", style: "italic", decoration: "none" };
        tune.formatting.subtitlefont = { face: '"Times New Roman"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.tempofont = { face: '"Times New Roman"', size: 15, weight: "bold", style: "normal", decoration: "none" };
        tune.formatting.titlefont = { face: '"Times New Roman"', size: 20, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.footerfont = { face: '"Times New Roman"', size: 12, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.headerfont = { face: '"Times New Roman"', size: 12, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.voicefont = { face: '"Times New Roman"', size: 13, weight: "bold", style: "normal", decoration: "none" };
        tune.formatting.tablabelfont = { face: '"Trebuchet MS"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.tabnumberfont = { face: '"Arial"', size: 11, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.tabgracefont = { face: '"Arial"', size: 8, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.annotationfont = multilineVars.annotationfont;
        tune.formatting.gchordfont = multilineVars.gchordfont;
        tune.formatting.historyfont = multilineVars.historyfont;
        tune.formatting.infofont = multilineVars.infofont;
        tune.formatting.measurefont = multilineVars.measurefont;
        tune.formatting.partsfont = multilineVars.partsfont;
        tune.formatting.repeatfont = multilineVars.repeatfont;
        tune.formatting.textfont = multilineVars.textfont;
        tune.formatting.tripletfont = multilineVars.tripletfont;
        tune.formatting.vocalfont = multilineVars.vocalfont;
        tune.formatting.wordsfont = multilineVars.wordsfont;
      }
      var fontTypeCanHaveBox = { gchordfont: true, measurefont: true, partsfont: true, annotationfont: true, composerfont: true, historyfont: true, infofont: true, subtitlefont: true, textfont: true, titlefont: true, voicefont: true };
      var fontTranslation = function(fontFace) {
        switch (fontFace) {
          case "Arial-Italic":
            return { face: "Arial", weight: "normal", style: "italic", decoration: "none" };
          case "Arial-Bold":
            return { face: "Arial", weight: "bold", style: "normal", decoration: "none" };
          case "Bookman-Demi":
            return { face: "Bookman,serif", weight: "bold", style: "normal", decoration: "none" };
          case "Bookman-DemiItalic":
            return { face: "Bookman,serif", weight: "bold", style: "italic", decoration: "none" };
          case "Bookman-Light":
            return { face: "Bookman,serif", weight: "normal", style: "normal", decoration: "none" };
          case "Bookman-LightItalic":
            return { face: "Bookman,serif", weight: "normal", style: "italic", decoration: "none" };
          case "Courier":
            return { face: '"Courier New"', weight: "normal", style: "normal", decoration: "none" };
          case "Courier-Oblique":
            return { face: '"Courier New"', weight: "normal", style: "italic", decoration: "none" };
          case "Courier-Bold":
            return { face: '"Courier New"', weight: "bold", style: "normal", decoration: "none" };
          case "Courier-BoldOblique":
            return { face: '"Courier New"', weight: "bold", style: "italic", decoration: "none" };
          case "AvantGarde-Book":
            return { face: "AvantGarde,Arial", weight: "normal", style: "normal", decoration: "none" };
          case "AvantGarde-BookOblique":
            return { face: "AvantGarde,Arial", weight: "normal", style: "italic", decoration: "none" };
          case "AvantGarde-Demi":
          case "Avant-Garde-Demi":
            return { face: "AvantGarde,Arial", weight: "bold", style: "normal", decoration: "none" };
          case "AvantGarde-DemiOblique":
            return { face: "AvantGarde,Arial", weight: "bold", style: "italic", decoration: "none" };
          case "Helvetica-Oblique":
            return { face: "Helvetica", weight: "normal", style: "italic", decoration: "none" };
          case "Helvetica-Bold":
            return { face: "Helvetica", weight: "bold", style: "normal", decoration: "none" };
          case "Helvetica-BoldOblique":
            return { face: "Helvetica", weight: "bold", style: "italic", decoration: "none" };
          case "Helvetica-Narrow":
            return { face: '"Helvetica Narrow",Helvetica', weight: "normal", style: "normal", decoration: "none" };
          case "Helvetica-Narrow-Oblique":
            return { face: '"Helvetica Narrow",Helvetica', weight: "normal", style: "italic", decoration: "none" };
          case "Helvetica-Narrow-Bold":
            return { face: '"Helvetica Narrow",Helvetica', weight: "bold", style: "normal", decoration: "none" };
          case "Helvetica-Narrow-BoldOblique":
            return { face: '"Helvetica Narrow",Helvetica', weight: "bold", style: "italic", decoration: "none" };
          case "Palatino-Roman":
            return { face: "Palatino", weight: "normal", style: "normal", decoration: "none" };
          case "Palatino-Italic":
            return { face: "Palatino", weight: "normal", style: "italic", decoration: "none" };
          case "Palatino-Bold":
            return { face: "Palatino", weight: "bold", style: "normal", decoration: "none" };
          case "Palatino-BoldItalic":
            return { face: "Palatino", weight: "bold", style: "italic", decoration: "none" };
          case "NewCenturySchlbk-Roman":
            return { face: '"New Century",serif', weight: "normal", style: "normal", decoration: "none" };
          case "NewCenturySchlbk-Italic":
            return { face: '"New Century",serif', weight: "normal", style: "italic", decoration: "none" };
          case "NewCenturySchlbk-Bold":
            return { face: '"New Century",serif', weight: "bold", style: "normal", decoration: "none" };
          case "NewCenturySchlbk-BoldItalic":
            return { face: '"New Century",serif', weight: "bold", style: "italic", decoration: "none" };
          case "Times":
          case "Times-Roman":
          case "Times-Narrow":
          case "Times-Courier":
          case "Times-New-Roman":
            return { face: '"Times New Roman"', weight: "normal", style: "normal", decoration: "none" };
          case "Times-Italic":
          case "Times-Italics":
            return { face: '"Times New Roman"', weight: "normal", style: "italic", decoration: "none" };
          case "Times-Bold":
            return { face: '"Times New Roman"', weight: "bold", style: "normal", decoration: "none" };
          case "Times-BoldItalic":
            return { face: '"Times New Roman"', weight: "bold", style: "italic", decoration: "none" };
          case "ZapfChancery-MediumItalic":
            return { face: '"Zapf Chancery",cursive,serif', weight: "normal", style: "normal", decoration: "none" };
          default:
            return null;
        }
      };
      var getFontParameter = function(tokens, currentSetting, str, position, cmd) {
        function processNumberOnly() {
          var size2 = parseInt(tokens[0].token);
          tokens.shift();
          if (!currentSetting) {
            warn("Can't set just the size of the font since there is no default value.", str, position);
            return { face: '"Times New Roman"', weight: "normal", style: "normal", decoration: "none", size: size2 };
          }
          if (tokens.length === 0) {
            return { face: currentSetting.face, weight: currentSetting.weight, style: currentSetting.style, decoration: currentSetting.decoration, size: size2 };
          }
          if (tokens.length === 1 && tokens[0].token === "box" && fontTypeCanHaveBox[cmd])
            return { face: currentSetting.face, weight: currentSetting.weight, style: currentSetting.style, decoration: currentSetting.decoration, size: size2, box: true };
          warn("Extra parameters in font definition.", str, position);
          return { face: currentSetting.face, weight: currentSetting.weight, style: currentSetting.style, decoration: currentSetting.decoration, size: size2 };
        }
        if (tokens[0].token === "*") {
          tokens.shift();
          if (tokens[0].type === "number")
            return processNumberOnly();
          else {
            warn("Expected font size number after *.", str, position);
          }
        }
        if (tokens[0].type === "number") {
          return processNumberOnly();
        }
        var face = [];
        var size;
        var weight = "normal";
        var style = "normal";
        var decoration = "none";
        var box = false;
        var state = "face";
        var hyphenLast = false;
        while (tokens.length) {
          var currToken = tokens.shift();
          var word = currToken.token.toLowerCase();
          switch (state) {
            case "face":
              if (hyphenLast || word !== "utf" && currToken.type !== "number" && word !== "bold" && word !== "italic" && word !== "underline" && word !== "box") {
                if (face.length > 0 && currToken.token === "-") {
                  hyphenLast = true;
                  face[face.length - 1] = face[face.length - 1] + currToken.token;
                } else {
                  if (hyphenLast) {
                    hyphenLast = false;
                    face[face.length - 1] = face[face.length - 1] + currToken.token;
                  } else
                    face.push(currToken.token);
                }
              } else {
                if (currToken.type === "number") {
                  if (size) {
                    warn("Font size specified twice in font definition.", str, position);
                  } else {
                    size = currToken.token;
                  }
                  state = "modifier";
                } else if (word === "bold")
                  weight = "bold";
                else if (word === "italic")
                  style = "italic";
                else if (word === "underline")
                  decoration = "underline";
                else if (word === "box") {
                  if (fontTypeCanHaveBox[cmd])
                    box = true;
                  else
                    warn(`This font style doesn't support "box"`, str, position);
                  state = "finished";
                } else if (word === "utf") {
                  currToken = tokens.shift();
                  state = "size";
                } else
                  warn("Unknown parameter " + currToken.token + " in font definition.", str, position);
              }
              break;
            case "size":
              if (currToken.type === "number") {
                if (size) {
                  warn("Font size specified twice in font definition.", str, position);
                } else {
                  size = currToken.token;
                }
              } else {
                warn("Expected font size in font definition.", str, position);
              }
              state = "modifier";
              break;
            case "modifier":
              if (word === "bold")
                weight = "bold";
              else if (word === "italic")
                style = "italic";
              else if (word === "underline")
                decoration = "underline";
              else if (word === "box") {
                if (fontTypeCanHaveBox[cmd])
                  box = true;
                else
                  warn(`This font style doesn't support "box"`, str, position);
                state = "finished";
              } else
                warn("Unknown parameter " + currToken.token + " in font definition.", str, position);
              break;
            case "finished":
              warn('Extra characters found after "box" in font definition.', str, position);
              break;
          }
        }
        if (size === void 0) {
          if (!currentSetting) {
            warn("Must specify the size of the font since there is no default value.", str, position);
            size = 12;
          } else
            size = currentSetting.size;
        } else
          size = parseFloat(size);
        face = face.join(" ");
        if (face === "") {
          if (!currentSetting) {
            warn("Must specify the name of the font since there is no default value.", str, position);
            face = "sans-serif";
          } else
            face = currentSetting.face;
        }
        var psFont = fontTranslation(face);
        var font = {};
        if (psFont) {
          font.face = psFont.face;
          font.weight = psFont.weight;
          font.style = psFont.style;
          font.decoration = psFont.decoration;
          font.size = size;
          if (box)
            font.box = true;
          return font;
        }
        font.face = face;
        font.weight = weight;
        font.style = style;
        font.decoration = decoration;
        font.size = size;
        if (box)
          font.box = true;
        return font;
      };
      var getChangingFont = function(cmd, tokens, str) {
        if (tokens.length === 0)
          return 'Directive "' + cmd + '" requires a font as a parameter.';
        multilineVars[cmd] = getFontParameter(tokens, multilineVars[cmd], str, 0, cmd);
        if (multilineVars.is_in_header)
          tune.formatting[cmd] = multilineVars[cmd];
        return null;
      };
      var getGlobalFont = function(cmd, tokens, str) {
        if (tokens.length === 0)
          return 'Directive "' + cmd + '" requires a font as a parameter.';
        tune.formatting[cmd] = getFontParameter(tokens, tune.formatting[cmd], str, 0, cmd);
        return null;
      };
      var setScale = function(cmd, tokens) {
        var scratch = "";
        parseCommon.each(tokens, function(tok) {
          scratch += tok.token;
        });
        var num = parseFloat(scratch);
        if (isNaN(num) || num === 0)
          return 'Directive "' + cmd + '" requires a number as a parameter.';
        tune.formatting.scale = num;
      };
      var drumNames = [
        "acoustic-bass-drum",
        "bass-drum-1",
        "side-stick",
        "acoustic-snare",
        "hand-clap",
        "electric-snare",
        "low-floor-tom",
        "closed-hi-hat",
        "high-floor-tom",
        "pedal-hi-hat",
        "low-tom",
        "open-hi-hat",
        "low-mid-tom",
        "hi-mid-tom",
        "crash-cymbal-1",
        "high-tom",
        "ride-cymbal-1",
        "chinese-cymbal",
        "ride-bell",
        "tambourine",
        "splash-cymbal",
        "cowbell",
        "crash-cymbal-2",
        "vibraslap",
        "ride-cymbal-2",
        "hi-bongo",
        "low-bongo",
        "mute-hi-conga",
        "open-hi-conga",
        "low-conga",
        "high-timbale",
        "low-timbale",
        "high-agogo",
        "low-agogo",
        "cabasa",
        "maracas",
        "short-whistle",
        "long-whistle",
        "short-guiro",
        "long-guiro",
        "claves",
        "hi-wood-block",
        "low-wood-block",
        "mute-cuica",
        "open-cuica",
        "mute-triangle",
        "open-triangle"
      ];
      var interpretPercMap = function(restOfString) {
        var tokens = restOfString.split(/\s+/);
        if (tokens.length !== 2 && tokens.length !== 3)
          return { error: 'Expected parameters "abc-note", "drum-sound", and optionally "note-head"' };
        var key = tokens[0];
        var pitch = parseInt(tokens[1], 10);
        if ((isNaN(pitch) || pitch < 35 || pitch > 81) && tokens[1]) {
          pitch = drumNames.indexOf(tokens[1].toLowerCase()) + 35;
        }
        if (isNaN(pitch) || pitch < 35 || pitch > 81)
          return { error: 'Expected drum name, received "' + tokens[1] + '"' };
        var value = { sound: pitch };
        if (tokens.length === 3)
          value.noteHead = tokens[2];
        return { key, value };
      };
      var getRequiredMeasurement = function(cmd, tokens) {
        var points = tokenizer.getMeasurement(tokens);
        if (points.used === 0 || tokens.length !== 0)
          return { error: 'Directive "' + cmd + '" requires a measurement as a parameter.' };
        return points.value;
      };
      var oneParameterMeasurement = function(cmd, tokens) {
        var points = tokenizer.getMeasurement(tokens);
        if (points.used === 0 || tokens.length !== 0)
          return 'Directive "' + cmd + '" requires a measurement as a parameter.';
        tune.formatting[cmd] = points.value;
        return null;
      };
      var addMultilineVar = function(key, cmd, tokens, min, max) {
        if (tokens.length !== 1 || tokens[0].type !== "number")
          return 'Directive "' + cmd + '" requires a number as a parameter.';
        var i = tokens[0].intt;
        if (min !== void 0 && i < min)
          return 'Directive "' + cmd + '" requires a number greater than or equal to ' + min + " as a parameter.";
        if (max !== void 0 && i > max)
          return 'Directive "' + cmd + '" requires a number less than or equal to ' + max + " as a parameter.";
        multilineVars[key] = i;
        return null;
      };
      var addMultilineVarBool = function(key, cmd, tokens) {
        if (tokens.length === 1 && (tokens[0].token === "true" || tokens[0].token === "false")) {
          multilineVars[key] = tokens[0].token === "true";
          return null;
        }
        var str = addMultilineVar(key, cmd, tokens, 0, 1);
        if (str !== null)
          return str;
        multilineVars[key] = multilineVars[key] === 1;
        return null;
      };
      var addMultilineVarOneParamChoice = function(key, cmd, tokens, choices) {
        if (tokens.length !== 1)
          return 'Directive "' + cmd + '" requires one of [ ' + choices.join(", ") + " ] as a parameter.";
        var choice = tokens[0].token;
        var found = false;
        for (var i = 0; !found && i < choices.length; i++) {
          if (choices[i] === choice)
            found = true;
        }
        if (!found)
          return 'Directive "' + cmd + '" requires one of [ ' + choices.join(", ") + " ] as a parameter.";
        multilineVars[key] = choice;
        return null;
      };
      var midiCmdParam0 = [
        "nobarlines",
        "barlines",
        "beataccents",
        "nobeataccents",
        "droneon",
        "droneoff",
        "drumon",
        "drumoff",
        "fermatafixed",
        "fermataproportional",
        "gchordon",
        "gchordoff",
        "controlcombo",
        "temperamentnormal",
        "noportamento"
      ];
      var midiCmdParam1String = [
        "gchord",
        "ptstress",
        "beatstring"
      ];
      var midiCmdParam1Integer = [
        "bassvol",
        "chordvol",
        "c",
        "channel",
        "beatmod",
        "deltaloudness",
        "drumbars",
        "gracedivider",
        "makechordchannels",
        "randomchordattack",
        "chordattack",
        "stressmodel",
        "transpose",
        "rtranspose",
        "vol",
        "volinc"
      ];
      var midiCmdParam1Integer1OptionalInteger = [
        "program"
      ];
      var midiCmdParam2Integer = [
        "ratio",
        "snt",
        "bendvelocity",
        "pitchbend",
        "control",
        "temperamentlinear"
      ];
      var midiCmdParam4Integer = [
        "beat"
      ];
      var midiCmdParam5Integer = [
        "drone"
      ];
      var midiCmdParam1String1Integer = [
        "portamento"
      ];
      var midiCmdParamFraction = [
        "expand",
        "grace",
        "trim"
      ];
      var midiCmdParam1StringVariableIntegers = [
        "drum",
        "chordname"
      ];
      var parseMidiCommand = function(midi, tune2, restOfString) {
        var midi_cmd = midi.shift().token;
        var midi_params = [];
        if (midiCmdParam0.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 0)
            warn("Unexpected parameter in MIDI " + midi_cmd, restOfString, 0);
        } else if (midiCmdParam1String.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1)
            warn("Expected one parameter in MIDI " + midi_cmd, restOfString, 0);
          else
            midi_params.push(midi[0].token);
        } else if (midiCmdParam1Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1)
            warn("Expected one parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number")
            warn("Expected one integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else
            midi_params.push(midi[0].intt);
        } else if (midiCmdParam1Integer1OptionalInteger.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1 && midi.length !== 2)
            warn("Expected one or two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number")
            warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi.length === 2 && midi[1].type !== "number")
            warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            if (midi.length === 2)
              midi_params.push(midi[1].intt);
          }
        } else if (midiCmdParam2Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 2)
            warn("Expected two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number" || midi[1].type !== "number")
            warn("Expected two integer parameters in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            midi_params.push(midi[1].intt);
          }
        } else if (midiCmdParam1String1Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 2)
            warn("Expected two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "alpha" || midi[1].type !== "number")
            warn("Expected one string and one integer parameters in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].token);
            midi_params.push(midi[1].intt);
          }
        } else if (midi_cmd === "drummap") {
          if (midi.length === 2 && midi[0].type === "alpha" && midi[1].type === "number") {
            if (!tune2.formatting)
              tune2.formatting = {};
            if (!tune2.formatting.midi)
              tune2.formatting.midi = {};
            if (!tune2.formatting.midi.drummap)
              tune2.formatting.midi.drummap = {};
            tune2.formatting.midi.drummap[midi[0].token] = midi[1].intt;
            midi_params = tune2.formatting.midi.drummap;
          } else if (midi.length === 3 && midi[0].type === "punct" && midi[1].type === "alpha" && midi[2].type === "number") {
            if (!tune2.formatting)
              tune2.formatting = {};
            if (!tune2.formatting.midi)
              tune2.formatting.midi = {};
            if (!tune2.formatting.midi.drummap)
              tune2.formatting.midi.drummap = {};
            tune2.formatting.midi.drummap[midi[0].token + midi[1].token] = midi[2].intt;
            midi_params = tune2.formatting.midi.drummap;
          } else {
            warn("Expected one note name and one integer parameter in MIDI " + midi_cmd, restOfString, 0);
          }
        } else if (midiCmdParamFraction.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 3)
            warn("Expected fraction parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number" || midi[1].token !== "/" || midi[2].type !== "number")
            warn("Expected fraction parameter in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            midi_params.push(midi[2].intt);
          }
        } else if (midiCmdParam4Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 4)
            warn("Expected four parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number" || midi[1].type !== "number" || midi[2].type !== "number" || midi[3].type !== "number")
            warn("Expected four integer parameters in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            midi_params.push(midi[1].intt);
            midi_params.push(midi[2].intt);
            midi_params.push(midi[3].intt);
          }
        } else if (midiCmdParam5Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 5)
            warn("Expected five parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number" || midi[1].type !== "number" || midi[2].type !== "number" || midi[3].type !== "number" || midi[4].type !== "number")
            warn("Expected five integer parameters in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            midi_params.push(midi[1].intt);
            midi_params.push(midi[2].intt);
            midi_params.push(midi[3].intt);
            midi_params.push(midi[4].intt);
          }
        } else if (midiCmdParam1Integer1OptionalInteger.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1 || midi.length !== 4)
            warn("Expected one or two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number")
            warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi.length === 4) {
            if (midi[1].token !== "octave")
              warn("Expected octave parameter in MIDI " + midi_cmd, restOfString, 0);
            if (midi[2].token !== "=")
              warn("Expected octave parameter in MIDI " + midi_cmd, restOfString, 0);
            if (midi[3].type !== "number")
              warn("Expected integer parameter for octave in MIDI " + midi_cmd, restOfString, 0);
          } else {
            midi_params.push(midi[0].intt);
            if (midi.length === 4)
              midi_params.push(midi[3].intt);
          }
        } else if (midiCmdParam1StringVariableIntegers.indexOf(midi_cmd) >= 0) {
          if (midi.length < 2)
            warn("Expected string parameter and at least one integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "alpha")
            warn("Expected string parameter and at least one integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else {
            var p = midi.shift();
            midi_params.push(p.token);
            while (midi.length > 0) {
              p = midi.shift();
              if (p.type !== "number")
                warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
              midi_params.push(p.intt);
            }
          }
        }
        if (tuneBuilder.hasBeginMusic())
          tuneBuilder.appendElement("midi", -1, -1, { cmd: midi_cmd, params: midi_params });
        else {
          if (tune2.formatting["midi"] === void 0)
            tune2.formatting["midi"] = {};
          tune2.formatting["midi"][midi_cmd] = midi_params;
        }
      };
      parseDirective.parseFontChangeLine = function(textstr) {
        var textParts = textstr.split("$");
        if (textParts.length > 1 && multilineVars.setfont) {
          var textarr = [{ text: textParts[0] }];
          for (var i = 1; i < textParts.length; i++) {
            if (textParts[i].charAt(0) === "0")
              textarr.push({ text: textParts[i].substring(1) });
            else if (textParts[i].charAt(0) === "1" && multilineVars.setfont[1])
              textarr.push({ font: multilineVars.setfont[1], text: textParts[i].substring(1) });
            else if (textParts[i].charAt(0) === "2" && multilineVars.setfont[2])
              textarr.push({ font: multilineVars.setfont[2], text: textParts[i].substring(1) });
            else if (textParts[i].charAt(0) === "3" && multilineVars.setfont[3])
              textarr.push({ font: multilineVars.setfont[3], text: textParts[i].substring(1) });
            else if (textParts[i].charAt(0) === "4" && multilineVars.setfont[4])
              textarr.push({ font: multilineVars.setfont[4], text: textParts[i].substring(1) });
            else
              textarr[textarr.length - 1].text += "$" + textParts[i];
          }
          if (textarr.length > 1)
            return textarr;
        }
        return textstr;
      };
      var positionChoices = ["auto", "above", "below", "hidden"];
      parseDirective.addDirective = function(str) {
        var tokens = tokenizer.tokenize(str, 0, str.length);
        if (tokens.length === 0 || tokens[0].type !== "alpha")
          return null;
        var restOfString = str.substring(str.indexOf(tokens[0].token) + tokens[0].token.length);
        restOfString = tokenizer.stripComment(restOfString);
        var cmd = tokens.shift().token.toLowerCase();
        var scratch = "";
        var line;
        switch (cmd) {
          case "bagpipes":
            tune.formatting.bagpipes = true;
            break;
          case "flatbeams":
            tune.formatting.flatbeams = true;
            break;
          case "jazzchords":
            tune.formatting.jazzchords = true;
            break;
          case "landscape":
            multilineVars.landscape = true;
            break;
          case "papersize":
            multilineVars.papersize = restOfString;
            break;
          case "graceslurs":
            if (tokens.length !== 1)
              return "Directive graceslurs requires one parameter: 0 or 1";
            if (tokens[0].token === "0" || tokens[0].token === "false")
              tune.formatting.graceSlurs = false;
            else if (tokens[0].token === "1" || tokens[0].token === "true")
              tune.formatting.graceSlurs = true;
            else
              return "Directive graceslurs requires one parameter: 0 or 1 (received " + tokens[0].token + ")";
            break;
          case "stretchlast":
            var sl = parseStretchLast(tokens);
            if (sl.value !== void 0)
              tune.formatting.stretchlast = sl.value;
            if (sl.error)
              return sl.error;
            break;
          case "titlecaps":
            multilineVars.titlecaps = true;
            break;
          case "titleleft":
            tune.formatting.titleleft = true;
            break;
          case "measurebox":
            tune.formatting.measurebox = true;
            break;
          case "vocal":
            return addMultilineVarOneParamChoice("vocalPosition", cmd, tokens, positionChoices);
          case "dynamic":
            return addMultilineVarOneParamChoice("dynamicPosition", cmd, tokens, positionChoices);
          case "gchord":
            return addMultilineVarOneParamChoice("chordPosition", cmd, tokens, positionChoices);
          case "ornament":
            return addMultilineVarOneParamChoice("ornamentPosition", cmd, tokens, positionChoices);
          case "volume":
            return addMultilineVarOneParamChoice("volumePosition", cmd, tokens, positionChoices);
          case "botmargin":
          case "botspace":
          case "composerspace":
          case "indent":
          case "leftmargin":
          case "linesep":
          case "musicspace":
          case "partsspace":
          case "pageheight":
          case "pagewidth":
          case "rightmargin":
          case "staffsep":
          case "staffwidth":
          case "subtitlespace":
          case "sysstaffsep":
          case "systemsep":
          case "textspace":
          case "titlespace":
          case "topmargin":
          case "topspace":
          case "vocalspace":
          case "wordsspace":
            return oneParameterMeasurement(cmd, tokens);
          case "voicescale":
            if (tokens.length !== 1 || tokens[0].type !== "number")
              return "voicescale requires one float as a parameter";
            var voiceScale = tokens.shift();
            if (multilineVars.currentVoice) {
              multilineVars.currentVoice.scale = voiceScale.floatt;
              tuneBuilder.changeVoiceScale(multilineVars.currentVoice.scale);
            }
            return null;
          case "vskip":
            var vskip = Math.round(getRequiredMeasurement(cmd, tokens));
            if (vskip.error)
              return vskip.error;
            tuneBuilder.addSpacing(vskip);
            return null;
          case "scale":
            setScale(cmd, tokens);
            break;
          case "sep":
            if (tokens.length === 0)
              tuneBuilder.addSeparator(14, 14, 85, { startChar: multilineVars.iChar, endChar: multilineVars.iChar + 5 });
            else {
              var points = tokenizer.getMeasurement(tokens);
              if (points.used === 0)
                return 'Directive "' + cmd + '" requires 3 numbers: space above, space below, length of line';
              var spaceAbove = points.value;
              points = tokenizer.getMeasurement(tokens);
              if (points.used === 0)
                return 'Directive "' + cmd + '" requires 3 numbers: space above, space below, length of line';
              var spaceBelow = points.value;
              points = tokenizer.getMeasurement(tokens);
              if (points.used === 0 || tokens.length !== 0)
                return 'Directive "' + cmd + '" requires 3 numbers: space above, space below, length of line';
              var lenLine = points.value;
              tuneBuilder.addSeparator(spaceAbove, spaceBelow, lenLine, { startChar: multilineVars.iChar, endChar: multilineVars.iChar + restOfString.length });
            }
            break;
          case "barsperstaff":
            scratch = addMultilineVar("barsperstaff", cmd, tokens);
            if (scratch !== null)
              return scratch;
            break;
          case "staffnonote":
            if (tokens.length !== 1)
              return "Directive staffnonote requires one parameter: 0 or 1";
            if (tokens[0].token === "0")
              multilineVars.staffnonote = true;
            else if (tokens[0].token === "1")
              multilineVars.staffnonote = false;
            else
              return "Directive staffnonote requires one parameter: 0 or 1 (received " + tokens[0].token + ")";
            break;
          case "printtempo":
            scratch = addMultilineVarBool("printTempo", cmd, tokens);
            if (scratch !== null)
              return scratch;
            break;
          case "partsbox":
            scratch = addMultilineVarBool("partsBox", cmd, tokens);
            if (scratch !== null)
              return scratch;
            multilineVars.partsfont.box = multilineVars.partsBox;
            break;
          case "freegchord":
            scratch = addMultilineVarBool("freegchord", cmd, tokens);
            if (scratch !== null)
              return scratch;
            break;
          case "measurenb":
          case "barnumbers":
            scratch = addMultilineVar("barNumbers", cmd, tokens);
            if (scratch !== null)
              return scratch;
            break;
          case "setbarnb":
            if (tokens.length !== 1 || tokens[0].type !== "number") {
              return "Directive setbarnb requires a number as a parameter.";
            }
            multilineVars.currBarNumber = tuneBuilder.setBarNumberImmediate(tokens[0].intt);
            break;
          case "begintext":
            var textBlock = "";
            line = tokenizer.nextLine();
            while (line && line.indexOf("%%endtext") !== 0) {
              if (parseCommon.startsWith(line, "%%"))
                textBlock += line.substring(2) + "\n";
              else
                textBlock += line + "\n";
              line = tokenizer.nextLine();
            }
            tuneBuilder.addText(textBlock, { startChar: multilineVars.iChar, endChar: multilineVars.iChar + textBlock.length + 7 });
            break;
          case "continueall":
            multilineVars.continueall = true;
            break;
          case "beginps":
            line = tokenizer.nextLine();
            while (line && line.indexOf("%%endps") !== 0) {
              tokenizer.nextLine();
            }
            warn("Postscript ignored", str, 0);
            break;
          case "deco":
            if (restOfString.length > 0)
              multilineVars.ignoredDecorations.push(restOfString.substring(0, restOfString.indexOf(" ")));
            warn("Decoration redefinition ignored", str, 0);
            break;
          case "text":
            var textstr = tokenizer.translateString(restOfString);
            tuneBuilder.addText(parseDirective.parseFontChangeLine(textstr), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + restOfString.length + 7 });
            break;
          case "center":
            var centerstr = tokenizer.translateString(restOfString);
            tuneBuilder.addCentered(parseDirective.parseFontChangeLine(centerstr));
            break;
          case "font":
            break;
          case "setfont":
            var sfTokens = tokenizer.tokenize(restOfString, 0, restOfString.length);
            if (sfTokens.length >= 4) {
              if (sfTokens[0].token === "-" && sfTokens[1].type === "number") {
                var sfNum = parseInt(sfTokens[1].token);
                if (sfNum >= 1 && sfNum <= 4) {
                  if (!multilineVars.setfont)
                    multilineVars.setfont = [];
                  sfTokens.shift();
                  sfTokens.shift();
                  multilineVars.setfont[sfNum] = getFontParameter(sfTokens, multilineVars.setfont[sfNum], str, 0, "setfont");
                }
              }
            }
            break;
          case "gchordfont":
          case "partsfont":
          case "tripletfont":
          case "vocalfont":
          case "textfont":
          case "annotationfont":
          case "historyfont":
          case "infofont":
          case "measurefont":
          case "repeatfont":
          case "wordsfont":
            return getChangingFont(cmd, tokens, str);
          case "composerfont":
          case "subtitlefont":
          case "tempofont":
          case "titlefont":
          case "voicefont":
          case "footerfont":
          case "headerfont":
            return getGlobalFont(cmd, tokens, str);
          case "barlabelfont":
          case "barnumberfont":
          case "barnumfont":
            return getChangingFont("measurefont", tokens, str);
          case "staves":
          case "score":
            multilineVars.score_is_present = true;
            var addVoice = function(id, newStaff2, bracket2, brace2, continueBar2) {
              if (newStaff2 || multilineVars.staves.length === 0) {
                multilineVars.staves.push({ index: multilineVars.staves.length, numVoices: 0 });
              }
              var staff = parseCommon.last(multilineVars.staves);
              if (bracket2 !== void 0 && staff.bracket === void 0)
                staff.bracket = bracket2;
              if (brace2 !== void 0 && staff.brace === void 0)
                staff.brace = brace2;
              if (continueBar2)
                staff.connectBarLines = "end";
              if (multilineVars.voices[id] === void 0) {
                multilineVars.voices[id] = { staffNum: staff.index, index: staff.numVoices };
                staff.numVoices++;
              }
            };
            var openParen = false;
            var openBracket = false;
            var openBrace = false;
            var justOpenParen = false;
            var justOpenBracket = false;
            var justOpenBrace = false;
            var continueBar = false;
            var lastVoice;
            var addContinueBar = function() {
              continueBar = true;
              if (lastVoice) {
                var ty = "start";
                if (lastVoice.staffNum > 0) {
                  if (multilineVars.staves[lastVoice.staffNum - 1].connectBarLines === "start" || multilineVars.staves[lastVoice.staffNum - 1].connectBarLines === "continue")
                    ty = "continue";
                }
                multilineVars.staves[lastVoice.staffNum].connectBarLines = ty;
              }
            };
            while (tokens.length) {
              var t = tokens.shift();
              switch (t.token) {
                case "(":
                  if (openParen)
                    warn("Can't nest parenthesis in %%score", str, t.start);
                  else {
                    openParen = true;
                    justOpenParen = true;
                  }
                  break;
                case ")":
                  if (!openParen || justOpenParen)
                    warn("Unexpected close parenthesis in %%score", str, t.start);
                  else
                    openParen = false;
                  break;
                case "[":
                  if (openBracket)
                    warn("Can't nest brackets in %%score", str, t.start);
                  else {
                    openBracket = true;
                    justOpenBracket = true;
                  }
                  break;
                case "]":
                  if (!openBracket || justOpenBracket)
                    warn("Unexpected close bracket in %%score", str, t.start);
                  else {
                    openBracket = false;
                    multilineVars.staves[lastVoice.staffNum].bracket = "end";
                  }
                  break;
                case "{":
                  if (openBrace)
                    warn("Can't nest braces in %%score", str, t.start);
                  else {
                    openBrace = true;
                    justOpenBrace = true;
                  }
                  break;
                case "}":
                  if (!openBrace || justOpenBrace)
                    warn("Unexpected close brace in %%score", str, t.start);
                  else {
                    openBrace = false;
                    multilineVars.staves[lastVoice.staffNum].brace = "end";
                  }
                  break;
                case "|":
                  addContinueBar();
                  break;
                default:
                  var vc = "";
                  while (t.type === "alpha" || t.type === "number") {
                    vc += t.token;
                    if (t.continueId)
                      t = tokens.shift();
                    else
                      break;
                  }
                  var newStaff = !openParen || justOpenParen;
                  var bracket = justOpenBracket ? "start" : openBracket ? "continue" : void 0;
                  var brace = justOpenBrace ? "start" : openBrace ? "continue" : void 0;
                  addVoice(vc, newStaff, bracket, brace, continueBar);
                  justOpenParen = false;
                  justOpenBracket = false;
                  justOpenBrace = false;
                  continueBar = false;
                  lastVoice = multilineVars.voices[vc];
                  if (cmd === "staves")
                    addContinueBar();
                  break;
              }
            }
            break;
          case "newpage":
            var pgNum = tokenizer.getInt(restOfString);
            tuneBuilder.addNewPage(pgNum.digits === 0 ? -1 : pgNum.value);
            break;
          case "abc":
            var arr = restOfString.split(" ");
            switch (arr[0]) {
              case "-copyright":
              case "-creator":
              case "-edited-by":
              case "-version":
              case "-charset":
                var subCmd = arr.shift();
                tuneBuilder.addMetaText(cmd + subCmd, arr.join(" "), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + restOfString.length + 5 });
                break;
              default:
                return "Unknown directive: " + cmd + arr[0];
            }
            break;
          case "header":
          case "footer":
            var footerStr = tokenizer.getMeat(restOfString, 0, restOfString.length);
            footerStr = restOfString.substring(footerStr.start, footerStr.end);
            if (footerStr.charAt(0) === '"' && footerStr.charAt(footerStr.length - 1) === '"')
              footerStr = footerStr.substring(1, footerStr.length - 1);
            var footerArr = footerStr.split("	");
            var footer = {};
            if (footerArr.length === 1)
              footer = { left: "", center: footerArr[0], right: "" };
            else if (footerArr.length === 2)
              footer = { left: footerArr[0], center: footerArr[1], right: "" };
            else
              footer = { left: footerArr[0], center: footerArr[1], right: footerArr[2] };
            if (footerArr.length > 3)
              warn("Too many tabs in " + cmd + ": " + footerArr.length + " found.", restOfString, 0);
            tuneBuilder.addMetaTextObj(cmd, footer, { startChar: multilineVars.iChar, endChar: multilineVars.iChar + str.length });
            break;
          case "midi":
            var midi = tokenizer.tokenize(restOfString, 0, restOfString.length, true);
            if (midi.length > 0 && midi[0].token === "=")
              midi.shift();
            if (midi.length === 0)
              warn("Expected midi command", restOfString, 0);
            else
              parseMidiCommand(midi, tune, restOfString);
            break;
          case "percmap":
            var percmap = interpretPercMap(restOfString);
            if (percmap.error)
              warn(percmap.error, str, 8);
            else {
              if (!tune.formatting.percmap)
                tune.formatting.percmap = {};
              tune.formatting.percmap[percmap.key] = percmap.value;
            }
            break;
          case "map":
          case "playtempo":
          case "auquality":
          case "continuous":
          case "nobarcheck":
            tune.formatting[cmd] = restOfString;
            break;
          default:
            return "Unknown directive: " + cmd;
        }
        return null;
      };
      parseDirective.globalFormatting = function(formatHash) {
        for (var cmd in formatHash) {
          if (formatHash.hasOwnProperty(cmd)) {
            var value = "" + formatHash[cmd];
            var tokens = tokenizer.tokenize(value, 0, value.length);
            var scratch;
            switch (cmd) {
              case "titlefont":
              case "gchordfont":
              case "composerfont":
              case "footerfont":
              case "headerfont":
              case "historyfont":
              case "infofont":
              case "measurefont":
              case "partsfont":
              case "repeatfont":
              case "subtitlefont":
              case "tempofont":
              case "textfont":
              case "voicefont":
              case "tripletfont":
              case "vocalfont":
              case "wordsfont":
              case "annotationfont":
              case "tablabelfont":
              case "tabnumberfont":
              case "tabgracefont":
                getChangingFont(cmd, tokens, value);
                break;
              case "scale":
                setScale(cmd, tokens);
                break;
              case "partsbox":
                scratch = addMultilineVarBool("partsBox", cmd, tokens);
                if (scratch !== null)
                  warn(scratch);
                multilineVars.partsfont.box = multilineVars.partsBox;
                break;
              case "freegchord":
                scratch = addMultilineVarBool("freegchord", cmd, tokens);
                if (scratch !== null)
                  warn(scratch);
                break;
              case "fontboxpadding":
                if (tokens.length !== 1 || tokens[0].type !== "number")
                  warn('Directive "' + cmd + '" requires a number as a parameter.');
                tune.formatting.fontboxpadding = tokens[0].floatt;
                break;
              case "stretchlast":
                var sl = parseStretchLast(tokens);
                if (sl.value !== void 0)
                  tune.formatting.stretchlast = sl.value;
                if (sl.error)
                  return sl.error;
                break;
              default:
                warn("Formatting directive unrecognized: ", cmd, 0);
            }
          }
        }
      };
      function parseStretchLast(tokens) {
        if (tokens.length === 0)
          return { value: 1 };
        else if (tokens.length === 1) {
          if (tokens[0].type === "number") {
            if (tokens[0].floatt >= 0 || tokens[0].floatt <= 1)
              return { value: tokens[0].floatt };
          } else if (tokens[0].token === "false") {
            return { value: 0 };
          } else if (tokens[0].token === "true") {
            return { value: 1 };
          }
        }
        return { error: "Directive stretchlast requires zero or one parameter: false, true, or number between 0 and 1 (received " + tokens[0].token + ")" };
      }
    })();
    module.exports = parseDirective;
  }
});

// node_modules/abcjs/src/parse/abc_transpose.js
var require_abc_transpose = __commonJS({
  "node_modules/abcjs/src/parse/abc_transpose.js"(exports, module) {
    var transpose = {};
    var keyIndex = {
      "C": 0,
      "C#": 1,
      "Db": 1,
      "D": 2,
      "D#": 3,
      "Eb": 3,
      "E": 4,
      "F": 5,
      "F#": 6,
      "Gb": 6,
      "G": 7,
      "G#": 8,
      "Ab": 8,
      "A": 9,
      "A#": 10,
      "Bb": 10,
      "B": 11
    };
    var newKey = ["C", "Db", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"];
    var newKeyMinor = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "Bb", "B"];
    transpose.keySignature = function(multilineVars, keys, keyName, root, acc, localTranspose) {
      if (multilineVars.clef.type === "perc")
        return { accidentals: keys[keyName], root, acc };
      if (!localTranspose)
        localTranspose = 0;
      multilineVars.localTransposeVerticalMovement = 0;
      multilineVars.localTransposePreferFlats = false;
      var k = keys[keyName];
      if (!k)
        return multilineVars.key;
      multilineVars.localTranspose = (multilineVars.globalTranspose ? multilineVars.globalTranspose : 0) + localTranspose;
      if (!multilineVars.localTranspose)
        return { accidentals: k, root, acc };
      multilineVars.globalTransposeOrigKeySig = k;
      if (multilineVars.localTranspose % 12 === 0) {
        multilineVars.localTransposeVerticalMovement = multilineVars.localTranspose / 12 * 7;
        return { accidentals: k, root, acc };
      }
      var baseKey = keyName[0];
      if (keyName[1] === "b" || keyName[1] === "#") {
        baseKey += keyName[1];
        keyName = keyName.substr(2);
      } else
        keyName = keyName.substr(1);
      var index = keyIndex[baseKey] + multilineVars.localTranspose;
      while (index < 0)
        index += 12;
      if (index > 11)
        index = index % 12;
      var newKeyName = keyName[0] === "m" ? newKeyMinor[index] : newKey[index];
      var transposedKey = newKeyName + keyName;
      var newKeySig = keys[transposedKey];
      if (newKeySig.length > 0 && newKeySig[0].acc === "flat")
        multilineVars.localTransposePreferFlats = true;
      var distance = transposedKey.charCodeAt(0) - baseKey.charCodeAt(0);
      if (multilineVars.localTranspose > 0) {
        if (distance < 0)
          distance += 7;
        else if (distance === 0) {
          if (baseKey[1] === "#" || transposedKey[1] === "b")
            distance += 7;
        }
      } else if (multilineVars.localTranspose < 0) {
        if (distance > 0)
          distance -= 7;
        else if (distance === 0) {
          if (baseKey[1] === "b" || transposedKey[1] === "#")
            distance -= 7;
        }
      }
      if (multilineVars.localTranspose > 0)
        multilineVars.localTransposeVerticalMovement = distance + Math.floor(multilineVars.localTranspose / 12) * 7;
      else
        multilineVars.localTransposeVerticalMovement = distance + Math.ceil(multilineVars.localTranspose / 12) * 7;
      return { accidentals: newKeySig, root: newKeyName[0], acc: newKeyName.length > 1 ? newKeyName[1] : "" };
    };
    var sharpChords = ["C", "C\u266F", "D", "D\u266F", "E", "F", "F\u266F", "G", "G\u266F", "A", "A\u266F", "B"];
    var flatChords = ["C", "D\u266D", "D", "E\u266D", "E", "F", "G\u266D", "G", "A\u266D", "A", "B\u266D", "B"];
    var sharpChordsFree = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    var flatChordsFree = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
    transpose.chordName = function(multilineVars, chord) {
      if (multilineVars.localTranspose && multilineVars.localTranspose % 12 !== 0) {
        var transposeFactor = multilineVars.localTranspose;
        while (transposeFactor < 0)
          transposeFactor += 12;
        if (transposeFactor > 11)
          transposeFactor = transposeFactor % 12;
        if (multilineVars.freegchord) {
          chord = chord.replace(/Cb/g, "`~11`");
          chord = chord.replace(/Db/g, "`~1`");
          chord = chord.replace(/Eb/g, "`~3`");
          chord = chord.replace(/Fb/g, "`~4`");
          chord = chord.replace(/Gb/g, "`~6`");
          chord = chord.replace(/Ab/g, "`~8`");
          chord = chord.replace(/Bb/g, "`~10`");
          chord = chord.replace(/C#/g, "`~1`");
          chord = chord.replace(/D#/g, "`~3`");
          chord = chord.replace(/E#/g, "`~5`");
          chord = chord.replace(/F#/g, "`~6`");
          chord = chord.replace(/G#/g, "`~8`");
          chord = chord.replace(/A#/g, "`~10`");
          chord = chord.replace(/B#/g, "`~0`");
        } else {
          chord = chord.replace(/C♭/g, "`~11`");
          chord = chord.replace(/D♭/g, "`~1`");
          chord = chord.replace(/E♭/g, "`~3`");
          chord = chord.replace(/F♭/g, "`~4`");
          chord = chord.replace(/G♭/g, "`~6`");
          chord = chord.replace(/A♭/g, "`~8`");
          chord = chord.replace(/B♭/g, "`~10`");
          chord = chord.replace(/C♯/g, "`~1`");
          chord = chord.replace(/D♯/g, "`~3`");
          chord = chord.replace(/E♯/g, "`~5`");
          chord = chord.replace(/F♯/g, "`~6`");
          chord = chord.replace(/G♯/g, "`~8`");
          chord = chord.replace(/A♯/g, "`~10`");
          chord = chord.replace(/B♯/g, "`~0`");
        }
        chord = chord.replace(/C/g, "`~0`");
        chord = chord.replace(/D/g, "`~2`");
        chord = chord.replace(/E/g, "`~4`");
        chord = chord.replace(/F/g, "`~5`");
        chord = chord.replace(/G/g, "`~7`");
        chord = chord.replace(/A/g, "`~9`");
        chord = chord.replace(/B/g, "`~11`");
        var arr = chord.split("`");
        for (var i = 0; i < arr.length; i++) {
          if (arr[i][0] === "~") {
            var chordNum = parseInt(arr[i].substr(1), 10);
            chordNum += transposeFactor;
            if (chordNum > 11)
              chordNum -= 12;
            if (multilineVars.freegchord)
              arr[i] = multilineVars.localTransposePreferFlats ? flatChordsFree[chordNum] : sharpChordsFree[chordNum];
            else
              arr[i] = multilineVars.localTransposePreferFlats ? flatChords[chordNum] : sharpChords[chordNum];
          }
        }
        chord = arr.join("");
      }
      return chord;
    };
    var pitchToLetter = ["c", "d", "e", "f", "g", "a", "b"];
    function accidentalChange(origPitch, newPitch, accidental, origKeySig, newKeySig) {
      var origPitchLetter = pitchToLetter[(origPitch + 49) % 7];
      var origAccidental = 0;
      for (var i = 0; i < origKeySig.length; i++) {
        if (origKeySig[i].note.toLowerCase() === origPitchLetter)
          origAccidental = accidentals[origKeySig[i].acc];
      }
      var currentAccidental = accidentals[accidental];
      var delta = currentAccidental - origAccidental;
      var newPitchLetter = pitchToLetter[(newPitch + 49) % 7];
      var newAccidental = 0;
      for (var j = 0; j < newKeySig.accidentals.length; j++) {
        if (newKeySig.accidentals[j].note.toLowerCase() === newPitchLetter)
          newAccidental = accidentals[newKeySig.accidentals[j].acc];
      }
      var calcAccidental = delta + newAccidental;
      if (calcAccidental < -2) {
        newPitch--;
        calcAccidental += newPitchLetter === "c" || newPitchLetter === "f" ? 1 : 2;
      }
      if (calcAccidental > 2) {
        newPitch++;
        calcAccidental -= newPitchLetter === "b" || newPitchLetter === "e" ? 1 : 2;
      }
      return [newPitch, calcAccidental];
    }
    var accidentals = {
      dblflat: -2,
      flat: -1,
      natural: 0,
      sharp: 1,
      dblsharp: 2
    };
    var accidentals2 = {
      "-2": "dblflat",
      "-1": "flat",
      "0": "natural",
      "1": "sharp",
      "2": "dblsharp"
    };
    transpose.note = function(multilineVars, el) {
      if (!multilineVars.localTranspose || multilineVars.clef.type === "perc")
        return;
      var origPitch = el.pitch;
      el.pitch = el.pitch + multilineVars.localTransposeVerticalMovement;
      if (el.accidental) {
        var ret = accidentalChange(origPitch, el.pitch, el.accidental, multilineVars.globalTransposeOrigKeySig, multilineVars.targetKey);
        el.pitch = ret[0];
        el.accidental = accidentals2[ret[1]];
      }
    };
    module.exports = transpose;
  }
});

// node_modules/abcjs/src/parse/abc_parse_key_voice.js
var require_abc_parse_key_voice = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_key_voice.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseDirective = require_abc_parse_directive();
    var transpose = require_abc_transpose();
    var parseKeyVoice = {};
    (function() {
      var tokenizer;
      var warn;
      var multilineVars;
      var tune;
      var tuneBuilder;
      parseKeyVoice.initialize = function(tokenizer_, warn_, multilineVars_, tune_, tuneBuilder_) {
        tokenizer = tokenizer_;
        warn = warn_;
        multilineVars = multilineVars_;
        tune = tune_;
        tuneBuilder = tuneBuilder_;
      };
      parseKeyVoice.standardKey = function(keyName, root, acc, localTranspose) {
        var key1sharp = { acc: "sharp", note: "f" };
        var key2sharp = { acc: "sharp", note: "c" };
        var key3sharp = { acc: "sharp", note: "g" };
        var key4sharp = { acc: "sharp", note: "d" };
        var key5sharp = { acc: "sharp", note: "A" };
        var key6sharp = { acc: "sharp", note: "e" };
        var key7sharp = { acc: "sharp", note: "B" };
        var key1flat = { acc: "flat", note: "B" };
        var key2flat = { acc: "flat", note: "e" };
        var key3flat = { acc: "flat", note: "A" };
        var key4flat = { acc: "flat", note: "d" };
        var key5flat = { acc: "flat", note: "G" };
        var key6flat = { acc: "flat", note: "c" };
        var key7flat = { acc: "flat", note: "F" };
        var keys = {
          "C#": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "A#m": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "G#Mix": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "D#Dor": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "E#Phr": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "F#Lyd": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "B#Loc": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "F#": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "D#m": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "C#Mix": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "G#Dor": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "A#Phr": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "BLyd": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "E#Loc": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "B": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "G#m": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "F#Mix": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "C#Dor": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "D#Phr": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "ELyd": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "A#Loc": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "E": [key1sharp, key2sharp, key3sharp, key4sharp],
          "C#m": [key1sharp, key2sharp, key3sharp, key4sharp],
          "BMix": [key1sharp, key2sharp, key3sharp, key4sharp],
          "F#Dor": [key1sharp, key2sharp, key3sharp, key4sharp],
          "G#Phr": [key1sharp, key2sharp, key3sharp, key4sharp],
          "ALyd": [key1sharp, key2sharp, key3sharp, key4sharp],
          "D#Loc": [key1sharp, key2sharp, key3sharp, key4sharp],
          "A": [key1sharp, key2sharp, key3sharp],
          "F#m": [key1sharp, key2sharp, key3sharp],
          "EMix": [key1sharp, key2sharp, key3sharp],
          "BDor": [key1sharp, key2sharp, key3sharp],
          "C#Phr": [key1sharp, key2sharp, key3sharp],
          "DLyd": [key1sharp, key2sharp, key3sharp],
          "G#Loc": [key1sharp, key2sharp, key3sharp],
          "D": [key1sharp, key2sharp],
          "Bm": [key1sharp, key2sharp],
          "AMix": [key1sharp, key2sharp],
          "EDor": [key1sharp, key2sharp],
          "F#Phr": [key1sharp, key2sharp],
          "GLyd": [key1sharp, key2sharp],
          "C#Loc": [key1sharp, key2sharp],
          "G": [key1sharp],
          "Em": [key1sharp],
          "DMix": [key1sharp],
          "ADor": [key1sharp],
          "BPhr": [key1sharp],
          "CLyd": [key1sharp],
          "F#Loc": [key1sharp],
          "C": [],
          "Am": [],
          "GMix": [],
          "DDor": [],
          "EPhr": [],
          "FLyd": [],
          "BLoc": [],
          "F": [key1flat],
          "Dm": [key1flat],
          "CMix": [key1flat],
          "GDor": [key1flat],
          "APhr": [key1flat],
          "BbLyd": [key1flat],
          "ELoc": [key1flat],
          "Bb": [key1flat, key2flat],
          "Gm": [key1flat, key2flat],
          "FMix": [key1flat, key2flat],
          "CDor": [key1flat, key2flat],
          "DPhr": [key1flat, key2flat],
          "EbLyd": [key1flat, key2flat],
          "ALoc": [key1flat, key2flat],
          "Eb": [key1flat, key2flat, key3flat],
          "Cm": [key1flat, key2flat, key3flat],
          "BbMix": [key1flat, key2flat, key3flat],
          "FDor": [key1flat, key2flat, key3flat],
          "GPhr": [key1flat, key2flat, key3flat],
          "AbLyd": [key1flat, key2flat, key3flat],
          "DLoc": [key1flat, key2flat, key3flat],
          "Ab": [key1flat, key2flat, key3flat, key4flat],
          "Fm": [key1flat, key2flat, key3flat, key4flat],
          "EbMix": [key1flat, key2flat, key3flat, key4flat],
          "BbDor": [key1flat, key2flat, key3flat, key4flat],
          "CPhr": [key1flat, key2flat, key3flat, key4flat],
          "DbLyd": [key1flat, key2flat, key3flat, key4flat],
          "GLoc": [key1flat, key2flat, key3flat, key4flat],
          "Db": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "Bbm": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "AbMix": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "EbDor": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "FPhr": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "GbLyd": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "CLoc": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "Gb": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "Ebm": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "DbMix": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "AbDor": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "BbPhr": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "CbLyd": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "FLoc": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "Cb": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "Abm": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "GbMix": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "DbDor": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "EbPhr": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "FbLyd": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "BbLoc": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "A#": [key1flat, key2flat],
          "B#": [],
          "D#": [key1flat, key2flat, key3flat],
          "E#": [key1flat],
          "G#": [key1flat, key2flat, key3flat, key4flat],
          "Gbm": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "none": []
        };
        return transpose.keySignature(multilineVars, keys, keyName, root, acc, localTranspose);
      };
      var clefLines = {
        "treble": { clef: "treble", pitch: 4, mid: 0 },
        "treble+8": { clef: "treble+8", pitch: 4, mid: 0 },
        "treble-8": { clef: "treble-8", pitch: 4, mid: 0 },
        "treble^8": { clef: "treble+8", pitch: 4, mid: 0 },
        "treble_8": { clef: "treble-8", pitch: 4, mid: 0 },
        "treble1": { clef: "treble", pitch: 2, mid: 2 },
        "treble2": { clef: "treble", pitch: 4, mid: 0 },
        "treble3": { clef: "treble", pitch: 6, mid: -2 },
        "treble4": { clef: "treble", pitch: 8, mid: -4 },
        "treble5": { clef: "treble", pitch: 10, mid: -6 },
        "perc": { clef: "perc", pitch: 6, mid: 0 },
        "none": { clef: "none", mid: 0 },
        "bass": { clef: "bass", pitch: 8, mid: -12 },
        "bass+8": { clef: "bass+8", pitch: 8, mid: -12 },
        "bass-8": { clef: "bass-8", pitch: 8, mid: -12 },
        "bass^8": { clef: "bass+8", pitch: 8, mid: -12 },
        "bass_8": { clef: "bass-8", pitch: 8, mid: -12 },
        "bass+16": { clef: "bass", pitch: 8, mid: -12 },
        "bass-16": { clef: "bass", pitch: 8, mid: -12 },
        "bass^16": { clef: "bass", pitch: 8, mid: -12 },
        "bass_16": { clef: "bass", pitch: 8, mid: -12 },
        "bass1": { clef: "bass", pitch: 2, mid: -6 },
        "bass2": { clef: "bass", pitch: 4, mid: -8 },
        "bass3": { clef: "bass", pitch: 6, mid: -10 },
        "bass4": { clef: "bass", pitch: 8, mid: -12 },
        "bass5": { clef: "bass", pitch: 10, mid: -14 },
        "tenor": { clef: "alto", pitch: 8, mid: -8 },
        "tenor1": { clef: "alto", pitch: 2, mid: -2 },
        "tenor2": { clef: "alto", pitch: 4, mid: -4 },
        "tenor3": { clef: "alto", pitch: 6, mid: -6 },
        "tenor4": { clef: "alto", pitch: 8, mid: -8 },
        "tenor5": { clef: "alto", pitch: 10, mid: -10 },
        "alto": { clef: "alto", pitch: 6, mid: -6 },
        "alto1": { clef: "alto", pitch: 2, mid: -2 },
        "alto2": { clef: "alto", pitch: 4, mid: -4 },
        "alto3": { clef: "alto", pitch: 6, mid: -6 },
        "alto4": { clef: "alto", pitch: 8, mid: -8 },
        "alto5": { clef: "alto", pitch: 10, mid: -10 },
        "alto+8": { clef: "alto+8", pitch: 6, mid: -6 },
        "alto-8": { clef: "alto-8", pitch: 6, mid: -6 },
        "alto^8": { clef: "alto+8", pitch: 6, mid: -6 },
        "alto_8": { clef: "alto-8", pitch: 6, mid: -6 }
      };
      var calcMiddle = function(clef, oct) {
        var value = clefLines[clef];
        var mid = value ? value.mid : 0;
        return mid + oct;
      };
      parseKeyVoice.fixClef = function(clef) {
        var value = clefLines[clef.type];
        if (value) {
          clef.clefPos = value.pitch;
          clef.type = value.clef;
        }
      };
      parseKeyVoice.deepCopyKey = function(key) {
        var ret = { accidentals: [], root: key.root, acc: key.acc, mode: key.mode };
        parseCommon.each(key.accidentals, function(k) {
          ret.accidentals.push(parseCommon.clone(k));
        });
        return ret;
      };
      var pitches = { A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11 };
      parseKeyVoice.addPosToKey = function(clef, key) {
        var mid = clef.verticalPos;
        parseCommon.each(key.accidentals, function(acc) {
          var pitch = pitches[acc.note];
          pitch = pitch - mid;
          acc.verticalPos = pitch;
        });
        if (key.impliedNaturals)
          parseCommon.each(key.impliedNaturals, function(acc) {
            var pitch = pitches[acc.note];
            pitch = pitch - mid;
            acc.verticalPos = pitch;
          });
        if (mid < -10) {
          parseCommon.each(key.accidentals, function(acc) {
            acc.verticalPos -= 7;
            if (acc.verticalPos >= 11 || acc.verticalPos === 10 && acc.acc === "flat")
              acc.verticalPos -= 7;
            if (acc.note === "A" && acc.acc === "sharp")
              acc.verticalPos -= 7;
            if ((acc.note === "G" || acc.note === "F") && acc.acc === "flat")
              acc.verticalPos -= 7;
          });
          if (key.impliedNaturals)
            parseCommon.each(key.impliedNaturals, function(acc) {
              acc.verticalPos -= 7;
              if (acc.verticalPos >= 11 || acc.verticalPos === 10 && acc.acc === "flat")
                acc.verticalPos -= 7;
              if (acc.note === "A" && acc.acc === "sharp")
                acc.verticalPos -= 7;
              if ((acc.note === "G" || acc.note === "F") && acc.acc === "flat")
                acc.verticalPos -= 7;
            });
        } else if (mid < -4) {
          parseCommon.each(key.accidentals, function(acc) {
            acc.verticalPos -= 7;
            if (mid === -8 && (acc.note === "f" || acc.note === "g") && acc.acc === "sharp")
              acc.verticalPos -= 7;
          });
          if (key.impliedNaturals)
            parseCommon.each(key.impliedNaturals, function(acc) {
              acc.verticalPos -= 7;
              if (mid === -8 && (acc.note === "f" || acc.note === "g") && acc.acc === "sharp")
                acc.verticalPos -= 7;
            });
        } else if (mid >= 7) {
          parseCommon.each(key.accidentals, function(acc) {
            acc.verticalPos += 7;
          });
          if (key.impliedNaturals)
            parseCommon.each(key.impliedNaturals, function(acc) {
              acc.verticalPos += 7;
            });
        }
      };
      parseKeyVoice.fixKey = function(clef, key) {
        var fixedKey = parseCommon.clone(key);
        parseKeyVoice.addPosToKey(clef, fixedKey);
        return fixedKey;
      };
      var parseMiddle = function(str) {
        var i = 0;
        var p = str.charAt(i++);
        if (p === "^" || p === "_")
          p = str.charAt(i++);
        var mid = pitches[p];
        if (mid === void 0)
          mid = 6;
        for (; i < str.length; i++) {
          if (str.charAt(i) === ",")
            mid -= 7;
          else if (str.charAt(i) === "'")
            mid += 7;
          else
            break;
        }
        return { mid: mid - 6, str: str.substring(i) };
      };
      var normalizeAccidentals = function(accs) {
        for (var i = 0; i < accs.length; i++) {
          if (accs[i].note === "b")
            accs[i].note = "B";
          else if (accs[i].note === "a")
            accs[i].note = "A";
          else if (accs[i].note === "F")
            accs[i].note = "f";
          else if (accs[i].note === "E")
            accs[i].note = "e";
          else if (accs[i].note === "D")
            accs[i].note = "d";
          else if (accs[i].note === "C")
            accs[i].note = "c";
          else if (accs[i].note === "G" && accs[i].acc === "sharp")
            accs[i].note = "g";
          else if (accs[i].note === "g" && accs[i].acc === "flat")
            accs[i].note = "G";
        }
      };
      parseKeyVoice.parseKey = function(str) {
        if (str.length === 0) {
          str = "none";
        }
        var tokens = tokenizer.tokenize(str, 0, str.length);
        var ret = {};
        if (tokens.length === 0) {
          warn("Must pass in key signature.", str, 0);
          return ret;
        }
        switch (tokens[0].token) {
          case "HP":
            parseDirective.addDirective("bagpipes");
            multilineVars.key = { root: "HP", accidentals: [], acc: "", mode: "" };
            ret.foundKey = true;
            tokens.shift();
            break;
          case "Hp":
            parseDirective.addDirective("bagpipes");
            multilineVars.key = { root: "Hp", accidentals: [{ acc: "natural", note: "g" }, { acc: "sharp", note: "f" }, { acc: "sharp", note: "c" }], acc: "", mode: "" };
            ret.foundKey = true;
            tokens.shift();
            break;
          case "none":
            multilineVars.key = { root: "none", accidentals: [], acc: "", mode: "" };
            ret.foundKey = true;
            tokens.shift();
            break;
          default:
            var retPitch = tokenizer.getKeyPitch(tokens[0].token);
            if (retPitch.len > 0) {
              ret.foundKey = true;
              var acc = "";
              var mode = "";
              if (tokens[0].token.length > 1)
                tokens[0].token = tokens[0].token.substring(1);
              else
                tokens.shift();
              var key = retPitch.token;
              if (tokens.length > 0) {
                var retAcc = tokenizer.getSharpFlat(tokens[0].token);
                if (retAcc.len > 0) {
                  if (tokens[0].token.length > 1)
                    tokens[0].token = tokens[0].token.substring(1);
                  else
                    tokens.shift();
                  key += retAcc.token;
                  acc = retAcc.token;
                }
                if (tokens.length > 0) {
                  var retMode = tokenizer.getMode(tokens[0].token);
                  if (retMode.len > 0) {
                    tokens.shift();
                    key += retMode.token;
                    mode = retMode.token;
                  }
                }
                if (parseKeyVoice.standardKey(key, retPitch.token, acc, 0) === void 0) {
                  warn("Unsupported key signature: " + key, str, 0);
                  return ret;
                }
              }
              var oldKey = parseKeyVoice.deepCopyKey(multilineVars.key);
              var keyCompensate = multilineVars.globalTranspose ? -multilineVars.globalTranspose : 0;
              multilineVars.key = parseKeyVoice.deepCopyKey(parseKeyVoice.standardKey(key, retPitch.token, acc, keyCompensate));
              multilineVars.key.mode = mode;
              if (oldKey) {
                var kk;
                for (var k = 0; k < multilineVars.key.accidentals.length; k++) {
                  for (kk = 0; kk < oldKey.accidentals.length; kk++) {
                    if (oldKey.accidentals[kk].note && multilineVars.key.accidentals[k].note.toLowerCase() === oldKey.accidentals[kk].note.toLowerCase())
                      oldKey.accidentals[kk].note = null;
                  }
                }
                for (kk = 0; kk < oldKey.accidentals.length; kk++) {
                  if (oldKey.accidentals[kk].note) {
                    if (!multilineVars.key.impliedNaturals)
                      multilineVars.key.impliedNaturals = [];
                    multilineVars.key.impliedNaturals.push({ acc: "natural", note: oldKey.accidentals[kk].note });
                  }
                }
              }
            }
            break;
        }
        if (tokens.length === 0)
          return ret;
        if (tokens[0].token === "exp")
          tokens.shift();
        if (tokens.length === 0)
          return ret;
        if (tokens[0].token === "oct")
          tokens.shift();
        if (tokens.length === 0)
          return ret;
        var accs = tokenizer.getKeyAccidentals2(tokens);
        if (accs.warn)
          warn(accs.warn, str, 0);
        if (accs.accs) {
          if (!ret.foundKey) {
            ret.foundKey = true;
            multilineVars.key = { root: "none", acc: "", mode: "", accidentals: [] };
          }
          normalizeAccidentals(accs.accs);
          for (var i = 0; i < accs.accs.length; i++) {
            var found = false;
            for (var j = 0; j < multilineVars.key.accidentals.length && !found; j++) {
              if (multilineVars.key.accidentals[j].note === accs.accs[i].note) {
                found = true;
                if (multilineVars.key.accidentals[j].acc !== accs.accs[i].acc) {
                  multilineVars.key.accidentals[j].acc = accs.accs[i].acc;
                  if (!multilineVars.key.explicitAccidentals)
                    multilineVars.key.explicitAccidentals = [];
                  multilineVars.key.explicitAccidentals.push(accs.accs[i]);
                }
              }
            }
            if (!found) {
              if (!multilineVars.key.explicitAccidentals)
                multilineVars.key.explicitAccidentals = [];
              multilineVars.key.explicitAccidentals.push(accs.accs[i]);
              multilineVars.key.accidentals.push(accs.accs[i]);
              if (multilineVars.key.impliedNaturals) {
                for (var kkk = 0; kkk < multilineVars.key.impliedNaturals.length; kkk++) {
                  if (multilineVars.key.impliedNaturals[kkk].note === accs.accs[i].note)
                    multilineVars.key.impliedNaturals.splice(kkk, 1);
                }
              }
            }
          }
        }
        var token;
        while (tokens.length > 0) {
          switch (tokens[0].token) {
            case "m":
            case "middle":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after middle", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after middle", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after middle=", str, 0);
                return ret;
              }
              var pitch = tokenizer.getPitchFromTokens(tokens);
              if (pitch.warn)
                warn(pitch.warn, str, 0);
              if (pitch.position)
                multilineVars.clef.verticalPos = pitch.position - 6;
              break;
            case "transpose":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after transpose", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after transpose", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after transpose=", str, 0);
                return ret;
              }
              if (tokens[0].type !== "number") {
                warn("Expected number after transpose", str, tokens[0].start);
                break;
              }
              multilineVars.clef.transpose = tokens[0].intt;
              tokens.shift();
              break;
            case "stafflines":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after stafflines", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after stafflines", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after stafflines=", str, 0);
                return ret;
              }
              if (tokens[0].type !== "number") {
                warn("Expected number after stafflines", str, tokens[0].start);
                break;
              }
              multilineVars.clef.stafflines = tokens[0].intt;
              tokens.shift();
              break;
            case "staffscale":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after staffscale", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after staffscale", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after staffscale=", str, 0);
                return ret;
              }
              if (tokens[0].type !== "number") {
                warn("Expected number after staffscale", str, tokens[0].start);
                break;
              }
              multilineVars.clef.staffscale = tokens[0].floatt;
              tokens.shift();
              break;
            case "style":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after style", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after style", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after style=", str, 0);
                return ret;
              }
              switch (tokens[0].token) {
                case "normal":
                case "harmonic":
                case "rhythm":
                case "x":
                case "triangle":
                  multilineVars.style = tokens[0].token;
                  tokens.shift();
                  break;
                default:
                  warn("error parsing style element: " + tokens[0].token, str, tokens[0].start);
                  break;
              }
              break;
            case "clef":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after clef", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after clef", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after clef=", str, 0);
                return ret;
              }
            case "treble":
            case "bass":
            case "alto":
            case "tenor":
            case "perc":
            case "none":
              var clef = tokens.shift();
              switch (clef.token) {
                case "treble":
                case "tenor":
                case "alto":
                case "bass":
                case "perc":
                case "none":
                  break;
                case "C":
                  clef.token = "alto";
                  break;
                case "F":
                  clef.token = "bass";
                  break;
                case "G":
                  clef.token = "treble";
                  break;
                case "c":
                  clef.token = "alto";
                  break;
                case "f":
                  clef.token = "bass";
                  break;
                case "g":
                  clef.token = "treble";
                  break;
                default:
                  warn("Expected clef name. Found " + clef.token, str, clef.start);
                  break;
              }
              if (tokens.length > 0 && tokens[0].type === "number") {
                clef.token += tokens[0].token;
                tokens.shift();
              }
              if (tokens.length > 1 && (tokens[0].token === "-" || tokens[0].token === "+" || tokens[0].token === "^" || tokens[0].token === "_") && tokens[1].token === "8") {
                clef.token += tokens[0].token + tokens[1].token;
                tokens.shift();
                tokens.shift();
              }
              multilineVars.clef = { type: clef.token, verticalPos: calcMiddle(clef.token, 0) };
              if (multilineVars.currentVoice && multilineVars.currentVoice.transpose !== void 0)
                multilineVars.clef.transpose = multilineVars.currentVoice.transpose;
              ret.foundClef = true;
              break;
            default:
              warn("Unknown parameter: " + tokens[0].token, str, tokens[0].start);
              tokens.shift();
          }
        }
        return ret;
      };
      var setCurrentVoice = function(id) {
        multilineVars.currentVoice = multilineVars.voices[id];
        tuneBuilder.setCurrentVoice(multilineVars.currentVoice.staffNum, multilineVars.currentVoice.index);
      };
      parseKeyVoice.parseVoice = function(line, i, e) {
        var ret = tokenizer.getMeat(line, i, e);
        var start = ret.start;
        var end = ret.end;
        var id = tokenizer.getToken(line, start, end);
        if (id.length === 0) {
          warn("Expected a voice id", line, start);
          return;
        }
        var isNew = false;
        if (multilineVars.voices[id] === void 0) {
          multilineVars.voices[id] = {};
          isNew = true;
          if (multilineVars.score_is_present)
            warn("Can't have an unknown V: id when the %score directive is present", line, start);
        }
        start += id.length;
        start += tokenizer.eatWhiteSpace(line, start);
        var staffInfo = { startStaff: isNew };
        var addNextTokenToStaffInfo = function(name) {
          var attr2 = tokenizer.getVoiceToken(line, start, end);
          if (attr2.warn !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.warn, line, start);
          else if (attr2.err !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.err, line, start);
          else if (attr2.token.length === 0 && line.charAt(start) !== '"')
            warn("Expected value for " + name + " in voice", line, start);
          else
            staffInfo[name] = attr2.token;
          start += attr2.len;
        };
        var addNextTokenToVoiceInfo = function(id2, name, type) {
          var attr2 = tokenizer.getVoiceToken(line, start, end);
          if (attr2.warn !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.warn, line, start);
          else if (attr2.err !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.err, line, start);
          else if (attr2.token.length === 0 && line.charAt(start) !== '"')
            warn("Expected value for " + name + " in voice", line, start);
          else {
            if (type === "number")
              attr2.token = parseFloat(attr2.token);
            multilineVars.voices[id2][name] = attr2.token;
          }
          start += attr2.len;
        };
        var getNextToken = function(name, type) {
          var attr2 = tokenizer.getVoiceToken(line, start, end);
          if (attr2.warn !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.warn, line, start);
          else if (attr2.err !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.err, line, start);
          else if (attr2.token.length === 0 && line.charAt(start) !== '"')
            warn("Expected value for " + name + " in voice", line, start);
          else {
            if (type === "number")
              attr2.token = parseFloat(attr2.token);
            return attr2.token;
          }
          start += attr2.len;
        };
        var addNextNoteTokenToVoiceInfo = function(id2, name) {
          var noteToTransposition = {
            "_B": 2,
            "_E": 9,
            "_b": -10,
            "_e": -3
          };
          var attr2 = tokenizer.getVoiceToken(line, start, end);
          if (attr2.warn !== void 0)
            warn("Expected one of (_B, _E, _b, _e) for " + name + " in voice: " + attr2.warn, line, start);
          else if (attr2.token.length === 0 && line.charAt(start) !== '"')
            warn("Expected one of (_B, _E, _b, _e) for " + name + " in voice", line, start);
          else {
            var t = noteToTransposition[attr2.token];
            if (!t)
              warn("Expected one of (_B, _E, _b, _e) for " + name + " in voice", line, start);
            else
              multilineVars.voices[id2][name] = t;
          }
          start += attr2.len;
        };
        while (start < end) {
          var token = tokenizer.getVoiceToken(line, start, end);
          start += token.len;
          if (token.warn) {
            warn("Error parsing voice: " + token.warn, line, start);
          } else {
            var attr = null;
            switch (token.token) {
              case "clef":
              case "cl":
                addNextTokenToStaffInfo("clef");
                var oct = 0;
                if (staffInfo.clef !== void 0) {
                  staffInfo.clef = staffInfo.clef.replace(/[',]/g, "");
                  if (staffInfo.clef.indexOf("+16") !== -1) {
                    oct += 14;
                    staffInfo.clef = staffInfo.clef.replace("+16", "");
                  }
                  staffInfo.verticalPos = calcMiddle(staffInfo.clef, oct);
                }
                break;
              case "treble":
              case "bass":
              case "tenor":
              case "alto":
              case "perc":
              case "none":
              case "treble'":
              case "bass'":
              case "tenor'":
              case "alto'":
              case "none'":
              case "treble''":
              case "bass''":
              case "tenor''":
              case "alto''":
              case "none''":
              case "treble,":
              case "bass,":
              case "tenor,":
              case "alto,":
              case "none,":
              case "treble,,":
              case "bass,,":
              case "tenor,,":
              case "alto,,":
              case "none,,":
                var oct2 = 0;
                staffInfo.clef = token.token.replace(/[',]/g, "");
                staffInfo.verticalPos = calcMiddle(staffInfo.clef, oct2);
                multilineVars.voices[id].clef = token.token;
                break;
              case "staves":
              case "stave":
              case "stv":
                addNextTokenToStaffInfo("staves");
                break;
              case "brace":
              case "brc":
                addNextTokenToStaffInfo("brace");
                break;
              case "bracket":
              case "brk":
                addNextTokenToStaffInfo("bracket");
                break;
              case "name":
              case "nm":
                addNextTokenToStaffInfo("name");
                break;
              case "subname":
              case "sname":
              case "snm":
                addNextTokenToStaffInfo("subname");
                break;
              case "merge":
                staffInfo.startStaff = false;
                break;
              case "stem":
              case "stems":
                attr = tokenizer.getVoiceToken(line, start, end);
                if (attr.warn !== void 0)
                  warn("Expected value for stems in voice: " + attr.warn, line, start);
                else if (attr.err !== void 0)
                  warn("Expected value for stems in voice: " + attr.err, line, start);
                else if (attr.token === "up" || attr.token === "down")
                  multilineVars.voices[id].stem = attr.token;
                else
                  warn("Expected up or down for voice stem", line, start);
                start += attr.len;
                break;
              case "up":
              case "down":
                multilineVars.voices[id].stem = token.token;
                break;
              case "middle":
              case "m":
                addNextTokenToStaffInfo("verticalPos");
                staffInfo.verticalPos = parseMiddle(staffInfo.verticalPos).mid;
                break;
              case "gchords":
              case "gch":
                multilineVars.voices[id].suppressChords = true;
                attr = tokenizer.getVoiceToken(line, start, end);
                if (attr.token === "0")
                  start = start + attr.len;
                break;
              case "space":
              case "spc":
                addNextTokenToStaffInfo("spacing");
                break;
              case "scale":
                addNextTokenToVoiceInfo(id, "scale", "number");
                break;
              case "score":
                addNextNoteTokenToVoiceInfo(id, "scoreTranspose");
                break;
              case "transpose":
                addNextTokenToVoiceInfo(id, "transpose", "number");
                break;
              case "stafflines":
                addNextTokenToVoiceInfo(id, "stafflines", "number");
                break;
              case "staffscale":
                addNextTokenToVoiceInfo(id, "staffscale", "number");
                break;
              case "octave":
                addNextTokenToVoiceInfo(id, "octave", "number");
                break;
              case "volume":
                addNextTokenToVoiceInfo(id, "volume", "number");
                break;
              case "cue":
                var cue = getNextToken("cue", "string");
                if (cue === "on")
                  multilineVars.voices[id].scale = 0.6;
                else
                  multilineVars.voices[id].scale = 1;
                break;
              case "style":
                attr = tokenizer.getVoiceToken(line, start, end);
                if (attr.warn !== void 0)
                  warn("Expected value for style in voice: " + attr.warn, line, start);
                else if (attr.err !== void 0)
                  warn("Expected value for style in voice: " + attr.err, line, start);
                else if (attr.token === "normal" || attr.token === "harmonic" || attr.token === "rhythm" || attr.token === "x" || attr.token === "triangle")
                  multilineVars.voices[id].style = attr.token;
                else
                  warn("Expected one of [normal, harmonic, rhythm, x, triangle] for voice style", line, start);
                start += attr.len;
                break;
            }
          }
          start += tokenizer.eatWhiteSpace(line, start);
        }
        if (staffInfo.startStaff || multilineVars.staves.length === 0) {
          multilineVars.staves.push({ index: multilineVars.staves.length, meter: multilineVars.origMeter });
          if (!multilineVars.score_is_present)
            multilineVars.staves[multilineVars.staves.length - 1].numVoices = 0;
        }
        if (multilineVars.voices[id].staffNum === void 0) {
          multilineVars.voices[id].staffNum = multilineVars.staves.length - 1;
          var vi = 0;
          for (var v in multilineVars.voices) {
            if (multilineVars.voices.hasOwnProperty(v)) {
              if (multilineVars.voices[v].staffNum === multilineVars.voices[id].staffNum)
                vi++;
            }
          }
          multilineVars.voices[id].index = vi - 1;
        }
        var s = multilineVars.staves[multilineVars.voices[id].staffNum];
        if (!multilineVars.score_is_present)
          s.numVoices++;
        if (staffInfo.clef)
          s.clef = { type: staffInfo.clef, verticalPos: staffInfo.verticalPos };
        if (staffInfo.spacing)
          s.spacing_below_offset = staffInfo.spacing;
        if (staffInfo.verticalPos)
          s.verticalPos = staffInfo.verticalPos;
        if (staffInfo.name) {
          if (s.name)
            s.name.push(staffInfo.name);
          else
            s.name = [staffInfo.name];
        }
        if (staffInfo.subname) {
          if (s.subname)
            s.subname.push(staffInfo.subname);
          else
            s.subname = [staffInfo.subname];
        }
        setCurrentVoice(id);
      };
    })();
    module.exports = parseKeyVoice;
  }
});

// node_modules/abcjs/src/parse/abc_parse_header.js
var require_abc_parse_header = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_header.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseDirective = require_abc_parse_directive();
    var parseKeyVoice = require_abc_parse_key_voice();
    var ParseHeader = function(tokenizer, warn, multilineVars, tune, tuneBuilder) {
      this.reset = function(tokenizer2, warn2, multilineVars2, tune2) {
        parseKeyVoice.initialize(tokenizer2, warn2, multilineVars2, tune2, tuneBuilder);
        parseDirective.initialize(tokenizer2, warn2, multilineVars2, tune2, tuneBuilder);
      };
      this.reset(tokenizer, warn, multilineVars, tune);
      this.setTitle = function(title) {
        if (multilineVars.hasMainTitle)
          tuneBuilder.addSubtitle(tokenizer.translateString(tokenizer.stripComment(title)), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + title.length + 2 });
        else {
          var titleStr = tokenizer.translateString(tokenizer.theReverser(tokenizer.stripComment(title)));
          if (multilineVars.titlecaps)
            titleStr = titleStr.toUpperCase();
          tuneBuilder.addMetaText("title", titleStr, { startChar: multilineVars.iChar, endChar: multilineVars.iChar + title.length + 2 });
          multilineVars.hasMainTitle = true;
        }
      };
      this.setMeter = function(line) {
        line = tokenizer.stripComment(line);
        if (line === "C") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "common_time" };
        } else if (line === "C|") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "cut_time" };
        } else if (line === "o") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "tempus_perfectum" };
        } else if (line === "c") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "tempus_imperfectum" };
        } else if (line === "o.") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "tempus_perfectum_prolatio" };
        } else if (line === "c.") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "tempus_imperfectum_prolatio" };
        } else if (line.length === 0 || line.toLowerCase() === "none") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return null;
        } else {
          var tokens = tokenizer.tokenize(line, 0, line.length);
          try {
            var parseNum = function() {
              var ret2 = { value: 0, num: "" };
              var tok = tokens.shift();
              if (tok.token === "(")
                tok = tokens.shift();
              while (1) {
                if (tok.type !== "number")
                  throw "Expected top number of meter";
                ret2.value += parseInt(tok.token);
                ret2.num += tok.token;
                if (tokens.length === 0 || tokens[0].token === "/")
                  return ret2;
                tok = tokens.shift();
                if (tok.token === ")") {
                  if (tokens.length === 0 || tokens[0].token === "/")
                    return ret2;
                  throw "Unexpected paren in meter";
                }
                if (tok.token !== "." && tok.token !== "+")
                  throw "Expected top number of meter";
                ret2.num += tok.token;
                if (tokens.length === 0)
                  throw "Expected top number of meter";
                tok = tokens.shift();
              }
              return ret2;
            };
            var parseFraction = function() {
              var ret2 = parseNum();
              if (tokens.length === 0)
                return ret2;
              var tok = tokens.shift();
              if (tok.token !== "/")
                throw "Expected slash in meter";
              tok = tokens.shift();
              if (tok.type !== "number")
                throw "Expected bottom number of meter";
              ret2.den = tok.token;
              ret2.value = ret2.value / parseInt(ret2.den);
              return ret2;
            };
            if (tokens.length === 0)
              throw "Expected meter definition in M: line";
            var meter = { type: "specified", value: [] };
            var totalLength = 0;
            while (1) {
              var ret = parseFraction();
              totalLength += ret.value;
              var mv = { num: ret.num };
              if (ret.den !== void 0)
                mv.den = ret.den;
              meter.value.push(mv);
              if (tokens.length === 0)
                break;
            }
            if (multilineVars.havent_set_length === true) {
              multilineVars.default_length = totalLength < 0.75 ? 0.0625 : 0.125;
              multilineVars.havent_set_length = false;
            }
            return meter;
          } catch (e) {
            warn(e, line, 0);
          }
        }
        return null;
      };
      this.calcTempo = function(relTempo) {
        var dur = 1 / 4;
        if (multilineVars.meter && multilineVars.meter.type === "specified") {
          dur = 1 / parseInt(multilineVars.meter.value[0].den);
        } else if (multilineVars.origMeter && multilineVars.origMeter.type === "specified") {
          dur = 1 / parseInt(multilineVars.origMeter.value[0].den);
        }
        for (var i = 0; i < relTempo.duration; i++)
          relTempo.duration[i] = dur * relTempo.duration[i];
        return relTempo;
      };
      this.resolveTempo = function() {
        if (multilineVars.tempo) {
          this.calcTempo(multilineVars.tempo);
          tune.metaText.tempo = multilineVars.tempo;
          delete multilineVars.tempo;
        }
      };
      this.addUserDefinition = function(line, start, end) {
        var equals = line.indexOf("=", start);
        if (equals === -1) {
          warn("Need an = in a macro definition", line, start);
          return;
        }
        var before = parseCommon.strip(line.substring(start, equals));
        var after = parseCommon.strip(line.substring(equals + 1));
        if (before.length !== 1) {
          warn("Macro definitions can only be one character", line, start);
          return;
        }
        var legalChars = "HIJKLMNOPQRSTUVWXYhijklmnopqrstuvw~";
        if (legalChars.indexOf(before) === -1) {
          warn("Macro definitions must be H-Y, h-w, or tilde", line, start);
          return;
        }
        if (after.length === 0) {
          warn("Missing macro definition", line, start);
          return;
        }
        if (multilineVars.macros === void 0)
          multilineVars.macros = {};
        multilineVars.macros[before] = after;
      };
      this.setDefaultLength = function(line, start, end) {
        var len = parseCommon.gsub(line.substring(start, end), " ", "");
        var len_arr = len.split("/");
        if (len_arr.length === 2) {
          var n = parseInt(len_arr[0]);
          var d = parseInt(len_arr[1]);
          if (d > 0) {
            multilineVars.default_length = n / d;
            multilineVars.havent_set_length = false;
          }
        } else if (len_arr.length === 1 && len_arr[0] === "1") {
          multilineVars.default_length = 1;
          multilineVars.havent_set_length = false;
        }
      };
      var tempoString = {
        larghissimo: 20,
        adagissimo: 24,
        sostenuto: 28,
        grave: 32,
        largo: 40,
        lento: 50,
        larghetto: 60,
        adagio: 68,
        adagietto: 74,
        andante: 80,
        andantino: 88,
        "marcia moderato": 84,
        "andante moderato": 100,
        moderato: 112,
        allegretto: 116,
        "allegro moderato": 120,
        allegro: 126,
        animato: 132,
        agitato: 140,
        veloce: 148,
        "mosso vivo": 156,
        vivace: 164,
        vivacissimo: 172,
        allegrissimo: 176,
        presto: 184,
        prestissimo: 210
      };
      this.setTempo = function(line, start, end, iChar) {
        try {
          var tokens = tokenizer.tokenize(line, start, end);
          if (tokens.length === 0)
            throw "Missing parameter in Q: field";
          var tempo = { startChar: iChar + start - 2, endChar: iChar + end };
          var delaySet = true;
          var token = tokens.shift();
          if (token.type === "quote") {
            tempo.preString = token.token;
            token = tokens.shift();
            if (tokens.length === 0) {
              if (tempoString[tempo.preString.toLowerCase()]) {
                tempo.bpm = tempoString[tempo.preString.toLowerCase()];
                tempo.suppressBpm = true;
              }
              return { type: "immediate", tempo };
            }
          }
          if (token.type === "alpha" && token.token === "C") {
            if (tokens.length === 0)
              throw "Missing tempo after C in Q: field";
            token = tokens.shift();
            if (token.type === "punct" && token.token === "=") {
              if (tokens.length === 0)
                throw "Missing tempo after = in Q: field";
              token = tokens.shift();
              if (token.type !== "number")
                throw "Expected number after = in Q: field";
              tempo.duration = [1];
              tempo.bpm = parseInt(token.token);
            } else if (token.type === "number") {
              tempo.duration = [parseInt(token.token)];
              if (tokens.length === 0)
                throw "Missing = after duration in Q: field";
              token = tokens.shift();
              if (token.type !== "punct" || token.token !== "=")
                throw "Expected = after duration in Q: field";
              if (tokens.length === 0)
                throw "Missing tempo after = in Q: field";
              token = tokens.shift();
              if (token.type !== "number")
                throw "Expected number after = in Q: field";
              tempo.bpm = parseInt(token.token);
            } else
              throw "Expected number or equal after C in Q: field";
          } else if (token.type === "number") {
            var num = parseInt(token.token);
            if (tokens.length === 0 || tokens[0].type === "quote") {
              tempo.duration = [1];
              tempo.bpm = num;
            } else {
              delaySet = false;
              token = tokens.shift();
              if (token.type !== "punct" && token.token !== "/")
                throw "Expected fraction in Q: field";
              token = tokens.shift();
              if (token.type !== "number")
                throw "Expected fraction in Q: field";
              var den = parseInt(token.token);
              tempo.duration = [num / den];
              while (tokens.length > 0 && tokens[0].token !== "=" && tokens[0].type !== "quote") {
                token = tokens.shift();
                if (token.type !== "number")
                  throw "Expected fraction in Q: field";
                num = parseInt(token.token);
                token = tokens.shift();
                if (token.type !== "punct" && token.token !== "/")
                  throw "Expected fraction in Q: field";
                token = tokens.shift();
                if (token.type !== "number")
                  throw "Expected fraction in Q: field";
                den = parseInt(token.token);
                tempo.duration.push(num / den);
              }
              token = tokens.shift();
              if (token.type !== "punct" && token.token !== "=")
                throw "Expected = in Q: field";
              token = tokens.shift();
              if (token.type !== "number")
                throw "Expected tempo in Q: field";
              tempo.bpm = parseInt(token.token);
            }
          } else
            throw "Unknown value in Q: field";
          if (tokens.length !== 0) {
            token = tokens.shift();
            if (token.type === "quote") {
              tempo.postString = token.token;
              token = tokens.shift();
            }
            if (tokens.length !== 0)
              throw "Unexpected string at end of Q: field";
          }
          if (multilineVars.printTempo === false)
            tempo.suppress = true;
          return { type: delaySet ? "delaySet" : "immediate", tempo };
        } catch (msg) {
          warn(msg, line, start);
          return { type: "none" };
        }
      };
      this.letter_to_inline_header = function(line, i, startLine) {
        var ws = tokenizer.eatWhiteSpace(line, i);
        i += ws;
        if (line.length >= i + 5 && line.charAt(i) === "[" && line.charAt(i + 2) === ":") {
          var e = line.indexOf("]", i);
          var startChar = multilineVars.iChar + i;
          var endChar = multilineVars.iChar + e + 1;
          switch (line.substring(i, i + 3)) {
            case "[I:":
              var err = parseDirective.addDirective(line.substring(i + 3, e));
              if (err)
                warn(err, line, i);
              return [e - i + 1 + ws];
            case "[M:":
              var meter = this.setMeter(line.substring(i + 3, e));
              if (tuneBuilder.hasBeginMusic() && meter)
                tuneBuilder.appendStartingElement("meter", startChar, endChar, meter);
              else
                multilineVars.meter = meter;
              return [e - i + 1 + ws];
            case "[K:":
              var result = parseKeyVoice.parseKey(line.substring(i + 3, e));
              if (result.foundClef && tuneBuilder.hasBeginMusic())
                tuneBuilder.appendStartingElement("clef", startChar, endChar, multilineVars.clef);
              if (result.foundKey && tuneBuilder.hasBeginMusic())
                tuneBuilder.appendStartingElement("key", startChar, endChar, parseKeyVoice.fixKey(multilineVars.clef, multilineVars.key));
              return [e - i + 1 + ws];
            case "[P:":
              if (startLine || tune.lines.length <= tune.lineNum)
                multilineVars.partForNextLine = { title: line.substring(i + 3, e), startChar, endChar };
              else
                tuneBuilder.appendElement("part", startChar, endChar, { title: line.substring(i + 3, e) });
              return [e - i + 1 + ws];
            case "[L:":
              this.setDefaultLength(line, i + 3, e);
              return [e - i + 1 + ws];
            case "[Q:":
              if (e > 0) {
                var tempo = this.setTempo(line, i + 3, e, multilineVars.iChar);
                if (tempo.type === "delaySet") {
                  if (tuneBuilder.hasBeginMusic())
                    tuneBuilder.appendElement("tempo", startChar, endChar, this.calcTempo(tempo.tempo));
                  else
                    multilineVars.tempoForNextLine = ["tempo", startChar, endChar, this.calcTempo(tempo.tempo)];
                } else if (tempo.type === "immediate") {
                  if (!startLine && tuneBuilder.hasBeginMusic())
                    tuneBuilder.appendElement("tempo", startChar, endChar, tempo.tempo);
                  else
                    multilineVars.tempoForNextLine = ["tempo", startChar, endChar, tempo.tempo];
                }
                return [e - i + 1 + ws, line.charAt(i + 1), line.substring(i + 3, e)];
              }
              break;
            case "[V:":
              if (e > 0) {
                parseKeyVoice.parseVoice(line, i + 3, e);
                return [e - i + 1 + ws, line.charAt(i + 1), line.substring(i + 3, e)];
              }
              break;
            default:
          }
        }
        return [0];
      };
      this.letter_to_body_header = function(line, i) {
        if (line.length >= i + 3) {
          switch (line.substring(i, i + 2)) {
            case "I:":
              var err = parseDirective.addDirective(line.substring(i + 2));
              if (err)
                warn(err, line, i);
              return [line.length];
            case "M:":
              var meter = this.setMeter(line.substring(i + 2));
              if (tuneBuilder.hasBeginMusic() && meter)
                tuneBuilder.appendStartingElement("meter", multilineVars.iChar + i, multilineVars.iChar + line.length, meter);
              return [line.length];
            case "K:":
              var result = parseKeyVoice.parseKey(line.substring(i + 2));
              if (result.foundClef && tuneBuilder.hasBeginMusic())
                tuneBuilder.appendStartingElement("clef", multilineVars.iChar + i, multilineVars.iChar + line.length, multilineVars.clef);
              if (result.foundKey && tuneBuilder.hasBeginMusic())
                tuneBuilder.appendStartingElement("key", multilineVars.iChar + i, multilineVars.iChar + line.length, parseKeyVoice.fixKey(multilineVars.clef, multilineVars.key));
              return [line.length];
            case "P:":
              if (tuneBuilder.hasBeginMusic())
                tuneBuilder.appendElement("part", multilineVars.iChar + i, multilineVars.iChar + line.length, { title: line.substring(i + 2) });
              return [line.length];
            case "L:":
              this.setDefaultLength(line, i + 2, line.length);
              return [line.length];
            case "Q:":
              var e = line.indexOf("", i + 2);
              if (e === -1)
                e = line.length;
              var tempo = this.setTempo(line, i + 2, e, multilineVars.iChar);
              if (tempo.type === "delaySet")
                tuneBuilder.appendElement("tempo", multilineVars.iChar + i, multilineVars.iChar + line.length, this.calcTempo(tempo.tempo));
              else if (tempo.type === "immediate")
                tuneBuilder.appendElement("tempo", multilineVars.iChar + i, multilineVars.iChar + line.length, tempo.tempo);
              return [e, line.charAt(i), parseCommon.strip(line.substring(i + 2))];
            case "V:":
              parseKeyVoice.parseVoice(line, i + 2, line.length);
              return [line.length, line.charAt(i), parseCommon.strip(line.substring(i + 2))];
            default:
          }
        }
        return [0];
      };
      var metaTextHeaders = {
        A: "author",
        B: "book",
        C: "composer",
        D: "discography",
        F: "url",
        G: "group",
        I: "instruction",
        N: "notes",
        O: "origin",
        R: "rhythm",
        S: "source",
        W: "unalignedWords",
        Z: "transcription"
      };
      this.parseHeader = function(line) {
        var field = metaTextHeaders[line.charAt(0)];
        if (field !== void 0) {
          if (field === "unalignedWords")
            tuneBuilder.addMetaTextArray(field, parseDirective.parseFontChangeLine(tokenizer.translateString(tokenizer.stripComment(line.substring(2)))), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + line.length });
          else
            tuneBuilder.addMetaText(field, tokenizer.translateString(tokenizer.stripComment(line.substring(2))), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + line.length });
          return {};
        } else {
          var startChar = multilineVars.iChar;
          var endChar = startChar + line.length;
          switch (line.charAt(0)) {
            case "H":
              tuneBuilder.addMetaText("history", tokenizer.translateString(tokenizer.stripComment(line.substring(2))), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + line.length });
              line = tokenizer.peekLine();
              while (line && line.charAt(1) !== ":") {
                tokenizer.nextLine();
                tuneBuilder.addMetaText("history", tokenizer.translateString(tokenizer.stripComment(line)), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + line.length });
                line = tokenizer.peekLine();
              }
              break;
            case "K":
              this.resolveTempo();
              var result = parseKeyVoice.parseKey(line.substring(2));
              if (!multilineVars.is_in_header && tuneBuilder.hasBeginMusic()) {
                if (result.foundClef)
                  tuneBuilder.appendStartingElement("clef", startChar, endChar, multilineVars.clef);
                if (result.foundKey)
                  tuneBuilder.appendStartingElement("key", startChar, endChar, parseKeyVoice.fixKey(multilineVars.clef, multilineVars.key));
              }
              multilineVars.is_in_header = false;
              break;
            case "L":
              this.setDefaultLength(line, 2, line.length);
              break;
            case "M":
              multilineVars.origMeter = multilineVars.meter = this.setMeter(line.substring(2));
              break;
            case "P":
              if (multilineVars.is_in_header)
                tuneBuilder.addMetaText("partOrder", tokenizer.translateString(tokenizer.stripComment(line.substring(2))), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + line.length });
              else
                multilineVars.partForNextLine = { title: tokenizer.translateString(tokenizer.stripComment(line.substring(2))), startChar, endChar };
              break;
            case "Q":
              var tempo = this.setTempo(line, 2, line.length, multilineVars.iChar);
              if (tempo.type === "delaySet")
                multilineVars.tempo = tempo.tempo;
              else if (tempo.type === "immediate") {
                if (!tune.metaText.tempo)
                  tune.metaText.tempo = tempo.tempo;
                else
                  multilineVars.tempoForNextLine = ["tempo", startChar, endChar, tempo.tempo];
              }
              break;
            case "T":
              this.setTitle(line.substring(2));
              break;
            case "U":
              this.addUserDefinition(line, 2, line.length);
              break;
            case "V":
              parseKeyVoice.parseVoice(line, 2, line.length);
              if (!multilineVars.is_in_header)
                return { newline: true };
              break;
            case "s":
              return { symbols: true };
            case "w":
              return { words: true };
            case "X":
              break;
            case "E":
            case "m":
              warn("Ignored header", line, 0);
              break;
            default:
              return { regular: true };
          }
        }
        return {};
      };
    };
    module.exports = ParseHeader;
  }
});

// node_modules/abcjs/src/parse/abc_parse_music.js
var require_abc_parse_music = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_music.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseKeyVoice = require_abc_parse_key_voice();
    var transpose = require_abc_transpose();
    var tokenizer;
    var warn;
    var multilineVars;
    var tune;
    var tuneBuilder;
    var header;
    var MusicParser = function(_tokenizer, _warn, _multilineVars, _tune, _tuneBuilder, _header) {
      tokenizer = _tokenizer;
      warn = _warn;
      multilineVars = _multilineVars;
      tune = _tune;
      tuneBuilder = _tuneBuilder;
      header = _header;
      this.lineContinuation = false;
    };
    var nonDecorations = "ABCDEFGabcdefgxyzZ[]|^_{";
    var isInTie = function(multilineVars2, overlayLevel, el2) {
      if (multilineVars2.inTie[overlayLevel] === void 0)
        return false;
      var voiceIndex = multilineVars2.currentVoice ? multilineVars2.currentVoice.index : 0;
      if (multilineVars2.inTie[overlayLevel][voiceIndex]) {
        if (el2.pitches !== void 0 || el2.rest.type !== "spacer")
          return true;
      }
      return false;
    };
    var el = {};
    MusicParser.prototype.parseMusic = function(line) {
      header.resolveTempo();
      multilineVars.is_in_header = false;
      var i = 0;
      var startOfLine = multilineVars.iChar;
      while (tokenizer.isWhiteSpace(line.charAt(i)) && i < line.length)
        i++;
      if (i === line.length || line.charAt(i) === "%")
        return;
      var delayStartNewLine = multilineVars.start_new_line;
      if (multilineVars.continueall === void 0)
        multilineVars.start_new_line = true;
      else
        multilineVars.start_new_line = false;
      var tripletNotesLeft = 0;
      var retHeader = header.letter_to_body_header(line, i);
      if (retHeader[0] > 0) {
        i += retHeader[0];
        if (retHeader[1] === "V")
          this.startNewLine();
      }
      var overlayLevel = 0;
      while (i < line.length) {
        var startI = i;
        if (line.charAt(i) === "%")
          break;
        var retInlineHeader = header.letter_to_inline_header(line, i, delayStartNewLine);
        if (retInlineHeader[0] > 0) {
          i += retInlineHeader[0];
          if (retInlineHeader[1] === "V")
            delayStartNewLine = true;
        } else {
          if (!tuneBuilder.hasBeginMusic() || delayStartNewLine && !this.lineContinuation) {
            this.startNewLine();
            delayStartNewLine = false;
          }
          var ret;
          while (1) {
            ret = tokenizer.eatWhiteSpace(line, i);
            if (ret > 0) {
              i += ret;
            }
            if (i > 0 && line.charAt(i - 1) === "") {
              ret = header.letter_to_body_header(line, i);
              if (ret[0] > 0) {
                if (ret[1] === "V")
                  this.startNewLine();
                i = ret[0];
                multilineVars.start_new_line = false;
              }
            }
            ret = letter_to_spacer(line, i);
            if (ret[0] > 0) {
              i += ret[0];
            }
            ret = letter_to_chord(line, i);
            if (ret[0] > 0) {
              if (!el.chord)
                el.chord = [];
              var chordName = tokenizer.translateString(ret[1]);
              chordName = chordName.replace(/;/g, "\n");
              var addedChord = false;
              for (var ci = 0; ci < el.chord.length; ci++) {
                if (el.chord[ci].position === ret[2]) {
                  addedChord = true;
                  el.chord[ci].name += "\n" + chordName;
                }
              }
              if (addedChord === false) {
                if (ret[2] === null && ret[3])
                  el.chord.push({ name: chordName, rel_position: ret[3] });
                else
                  el.chord.push({ name: chordName, position: ret[2] });
              }
              i += ret[0];
              var ii = tokenizer.skipWhiteSpace(line.substring(i));
              if (ii > 0)
                el.force_end_beam_last = true;
              i += ii;
            } else {
              if (nonDecorations.indexOf(line.charAt(i)) === -1)
                ret = letter_to_accent(line, i);
              else
                ret = [0];
              if (ret[0] > 0) {
                if (ret[1] === null) {
                  if (i + 1 < line.length)
                    this.startNewLine();
                } else if (ret[1].length > 0) {
                  if (ret[1].indexOf("style=") === 0) {
                    el.style = ret[1].substr(6);
                  } else {
                    if (el.decoration === void 0)
                      el.decoration = [];
                    if (ret[1] === "beambr1")
                      el.beambr = 1;
                    else if (ret[1] === "beambr2")
                      el.beambr = 2;
                    else
                      el.decoration.push(ret[1]);
                  }
                }
                i += ret[0];
              } else {
                ret = letter_to_grace(line, i);
                if (ret[0] > 0) {
                  el.gracenotes = ret[1];
                  i += ret[0];
                } else
                  break;
              }
            }
          }
          ret = letter_to_bar(line, i);
          if (ret[0] > 0) {
            overlayLevel = 0;
            if (el.gracenotes !== void 0) {
              el.rest = { type: "spacer" };
              el.duration = 0.125;
              multilineVars.addFormattingOptions(el, tune.formatting, "note");
              tuneBuilder.appendElement("note", startOfLine + i, startOfLine + i + ret[0], el);
              multilineVars.measureNotEmpty = true;
              el = {};
            }
            var bar = { type: ret[1] };
            if (bar.type.length === 0)
              warn("Unknown bar type", line, i);
            else {
              if (multilineVars.inEnding && bar.type !== "bar_thin") {
                bar.endEnding = true;
                multilineVars.inEnding = false;
              }
              if (ret[2]) {
                bar.startEnding = ret[2];
                if (multilineVars.inEnding)
                  bar.endEnding = true;
                multilineVars.inEnding = true;
                if (ret[1] === "bar_right_repeat") {
                  multilineVars.restoreStartEndingHoldOvers();
                } else {
                  multilineVars.duplicateStartEndingHoldOvers();
                }
              }
              if (el.decoration !== void 0)
                bar.decoration = el.decoration;
              if (el.chord !== void 0)
                bar.chord = el.chord;
              if (bar.startEnding && multilineVars.barFirstEndingNum === void 0)
                multilineVars.barFirstEndingNum = multilineVars.currBarNumber;
              else if (bar.startEnding && bar.endEnding && multilineVars.barFirstEndingNum)
                multilineVars.currBarNumber = multilineVars.barFirstEndingNum;
              else if (bar.endEnding)
                multilineVars.barFirstEndingNum = void 0;
              if (bar.type !== "bar_invisible" && multilineVars.measureNotEmpty) {
                var isFirstVoice = multilineVars.currentVoice === void 0 || multilineVars.currentVoice.staffNum === 0 && multilineVars.currentVoice.index === 0;
                if (isFirstVoice) {
                  multilineVars.currBarNumber++;
                  if (multilineVars.barNumbers && multilineVars.currBarNumber % multilineVars.barNumbers === 0)
                    bar.barNumber = multilineVars.currBarNumber;
                }
              }
              multilineVars.addFormattingOptions(el, tune.formatting, "bar");
              tuneBuilder.appendElement("bar", startOfLine + i, startOfLine + i + ret[0], bar);
              multilineVars.measureNotEmpty = false;
              el = {};
            }
            i += ret[0];
          } else if (line[i] === "&") {
            ret = letter_to_overlay(line, i);
            if (ret[0] > 0) {
              tuneBuilder.appendElement("overlay", startOfLine, startOfLine + 1, {});
              i += 1;
              overlayLevel++;
            }
          } else {
            ret = letter_to_open_slurs_and_triplets(line, i);
            if (ret.consumed > 0) {
              if (ret.startSlur !== void 0)
                el.startSlur = ret.startSlur;
              if (ret.dottedSlur)
                el.dottedSlur = true;
              if (ret.triplet !== void 0) {
                if (tripletNotesLeft > 0)
                  warn("Can't nest triplets", line, i);
                else {
                  el.startTriplet = ret.triplet;
                  el.tripletMultiplier = ret.tripletQ / ret.triplet;
                  el.tripletR = ret.num_notes;
                  tripletNotesLeft = ret.num_notes === void 0 ? ret.triplet : ret.num_notes;
                }
              }
              i += ret.consumed;
            }
            if (line.charAt(i) === "[") {
              var chordStartChar = i;
              i++;
              var chordDuration = null;
              var rememberEndBeam = false;
              var done = false;
              while (!done) {
                var accent = letter_to_accent(line, i);
                if (accent[0] > 0) {
                  i += accent[0];
                }
                var chordNote = getCoreNote(line, i, {}, false);
                if (chordNote !== null && chordNote.pitch !== void 0) {
                  if (accent[0] > 0) {
                    if (accent[1].indexOf("style=") !== 0) {
                      if (el.decoration === void 0)
                        el.decoration = [];
                      el.decoration.push(accent[1]);
                    }
                  }
                  if (chordNote.end_beam) {
                    el.end_beam = true;
                    delete chordNote.end_beam;
                  }
                  if (el.pitches === void 0) {
                    el.duration = chordNote.duration;
                    el.pitches = [chordNote];
                  } else
                    el.pitches.push(chordNote);
                  delete chordNote.duration;
                  if (accent[0] > 0) {
                    if (accent[1].indexOf("style=") === 0) {
                      el.pitches[el.pitches.length - 1].style = accent[1].substr(6);
                    }
                  }
                  if (multilineVars.inTieChord[el.pitches.length]) {
                    chordNote.endTie = true;
                    multilineVars.inTieChord[el.pitches.length] = void 0;
                  }
                  if (chordNote.startTie)
                    multilineVars.inTieChord[el.pitches.length] = true;
                  i = chordNote.endChar;
                  delete chordNote.endChar;
                } else if (line.charAt(i) === " ") {
                  warn("Spaces are not allowed in chords", line, i);
                  i++;
                } else {
                  if (i < line.length && line.charAt(i) === "]") {
                    i++;
                    if (multilineVars.next_note_duration !== 0) {
                      el.duration = el.duration * multilineVars.next_note_duration;
                      multilineVars.next_note_duration = 0;
                    }
                    if (isInTie(multilineVars, overlayLevel, el)) {
                      parseCommon.each(el.pitches, function(pitch) {
                        pitch.endTie = true;
                      });
                      setIsInTie(multilineVars, overlayLevel, false);
                    }
                    if (tripletNotesLeft > 0 && !(el.rest && el.rest.type === "spacer")) {
                      tripletNotesLeft--;
                      if (tripletNotesLeft === 0) {
                        el.endTriplet = true;
                      }
                    }
                    var postChordDone = false;
                    while (i < line.length && !postChordDone) {
                      switch (line.charAt(i)) {
                        case " ":
                        case "	":
                          addEndBeam(el);
                          break;
                        case ")":
                          if (el.endSlur === void 0)
                            el.endSlur = 1;
                          else
                            el.endSlur++;
                          break;
                        case "-":
                          parseCommon.each(el.pitches, function(pitch) {
                            pitch.startTie = {};
                          });
                          setIsInTie(multilineVars, overlayLevel, true);
                          break;
                        case ">":
                        case "<":
                          var br2 = getBrokenRhythm(line, i);
                          i += br2[0] - 1;
                          multilineVars.next_note_duration = br2[2];
                          if (chordDuration)
                            chordDuration = chordDuration * br2[1];
                          else
                            chordDuration = br2[1];
                          break;
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "8":
                        case "9":
                        case "/":
                          var fraction = tokenizer.getFraction(line, i);
                          chordDuration = fraction.value;
                          i = fraction.index;
                          if (line.charAt(i) === " ")
                            rememberEndBeam = true;
                          if (line.charAt(i) === "-" || line.charAt(i) === ")" || line.charAt(i) === " " || line.charAt(i) === "<" || line.charAt(i) === ">")
                            i--;
                          else
                            postChordDone = true;
                          break;
                        default:
                          postChordDone = true;
                          break;
                      }
                      if (!postChordDone) {
                        i++;
                      }
                    }
                  } else
                    warn("Expected ']' to end the chords", line, i);
                  if (el.pitches !== void 0) {
                    if (chordDuration !== null) {
                      el.duration = el.duration * chordDuration;
                      if (rememberEndBeam)
                        addEndBeam(el);
                    }
                    multilineVars.addFormattingOptions(el, tune.formatting, "note");
                    tuneBuilder.appendElement("note", startOfLine + startI, startOfLine + i, el);
                    multilineVars.measureNotEmpty = true;
                    el = {};
                  }
                  done = true;
                }
              }
            } else {
              var el2 = {};
              var core = getCoreNote(line, i, el2, true);
              if (el2.endTie !== void 0)
                setIsInTie(multilineVars, overlayLevel, true);
              if (core !== null) {
                if (core.pitch !== void 0) {
                  el.pitches = [{}];
                  if (core.accidental !== void 0)
                    el.pitches[0].accidental = core.accidental;
                  el.pitches[0].pitch = core.pitch;
                  el.pitches[0].name = core.name;
                  if (core.midipitch || core.midipitch === 0)
                    el.pitches[0].midipitch = core.midipitch;
                  if (core.endSlur !== void 0)
                    el.pitches[0].endSlur = core.endSlur;
                  if (core.endTie !== void 0)
                    el.pitches[0].endTie = core.endTie;
                  if (core.startSlur !== void 0)
                    el.pitches[0].startSlur = core.startSlur;
                  if (el.startSlur !== void 0)
                    el.pitches[0].startSlur = el.startSlur;
                  if (el.dottedSlur !== void 0)
                    el.pitches[0].dottedSlur = true;
                  if (core.startTie !== void 0)
                    el.pitches[0].startTie = core.startTie;
                  if (el.startTie !== void 0)
                    el.pitches[0].startTie = el.startTie;
                } else {
                  el.rest = core.rest;
                  if (core.endSlur !== void 0)
                    el.endSlur = core.endSlur;
                  if (core.endTie !== void 0)
                    el.rest.endTie = core.endTie;
                  if (core.startSlur !== void 0)
                    el.startSlur = core.startSlur;
                  if (core.startTie !== void 0)
                    el.rest.startTie = core.startTie;
                  if (el.startTie !== void 0)
                    el.rest.startTie = el.startTie;
                }
                if (core.chord !== void 0)
                  el.chord = core.chord;
                if (core.duration !== void 0)
                  el.duration = core.duration;
                if (core.decoration !== void 0)
                  el.decoration = core.decoration;
                if (core.graceNotes !== void 0)
                  el.graceNotes = core.graceNotes;
                delete el.startSlur;
                delete el.dottedSlur;
                if (isInTie(multilineVars, overlayLevel, el)) {
                  if (el.pitches !== void 0) {
                    el.pitches[0].endTie = true;
                  } else if (el.rest.type !== "spacer") {
                    el.rest.endTie = true;
                  }
                  setIsInTie(multilineVars, overlayLevel, false);
                }
                if (core.startTie || el.startTie)
                  setIsInTie(multilineVars, overlayLevel, true);
                i = core.endChar;
                if (tripletNotesLeft > 0 && !(core.rest && core.rest.type === "spacer")) {
                  tripletNotesLeft--;
                  if (tripletNotesLeft === 0) {
                    el.endTriplet = true;
                  }
                }
                if (core.end_beam)
                  addEndBeam(el);
                if (el.rest && el.rest.type === "rest" && el.duration === 1 && durationOfMeasure(multilineVars) <= 1) {
                  el.rest.type = "whole";
                  el.duration = durationOfMeasure(multilineVars);
                }
                var durations = [
                  0.5,
                  0.75,
                  0.875,
                  0.9375,
                  0.96875,
                  0.984375,
                  0.25,
                  0.375,
                  0.4375,
                  0.46875,
                  0.484375,
                  0.4921875,
                  0.125,
                  0.1875,
                  0.21875,
                  0.234375,
                  0.2421875,
                  0.24609375,
                  0.0625,
                  0.09375,
                  0.109375,
                  0.1171875,
                  0.12109375,
                  0.123046875,
                  0.03125,
                  0.046875,
                  0.0546875,
                  0.05859375,
                  0.060546875,
                  0.0615234375,
                  0.015625,
                  0.0234375,
                  0.02734375,
                  0.029296875,
                  0.0302734375,
                  0.03076171875
                ];
                if (el.duration < 1 && durations.indexOf(el.duration) === -1 && el.duration !== 0) {
                  if (!el.rest || el.rest.type !== "spacer")
                    warn("Duration not representable: " + line.substring(startI, i), line, i);
                }
                multilineVars.addFormattingOptions(el, tune.formatting, "note");
                tuneBuilder.appendElement("note", startOfLine + startI, startOfLine + i, el);
                multilineVars.measureNotEmpty = true;
                el = {};
              }
            }
            if (i === startI) {
              if (line.charAt(i) !== " " && line.charAt(i) !== "`")
                warn("Unknown character ignored", line, i);
              i++;
            }
          }
        }
      }
      this.lineContinuation = line.indexOf("") >= 0 || retHeader[0] > 0;
      if (!this.lineContinuation) {
        el = {};
      }
    };
    var setIsInTie = function(multilineVars2, overlayLevel, value) {
      var voiceIndex = multilineVars2.currentVoice ? multilineVars2.currentVoice.index : 0;
      if (multilineVars2.inTie[overlayLevel] === void 0)
        multilineVars2.inTie[overlayLevel] = [];
      multilineVars2.inTie[overlayLevel][voiceIndex] = value;
    };
    var letter_to_chord = function(line, i) {
      if (line.charAt(i) === '"') {
        var chord = tokenizer.getBrackettedSubstring(line, i, 5);
        if (!chord[2])
          warn("Missing the closing quote while parsing the chord symbol", line, i);
        if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === "^") {
          chord[1] = chord[1].substring(1);
          chord[2] = "above";
        } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === "_") {
          chord[1] = chord[1].substring(1);
          chord[2] = "below";
        } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === "<") {
          chord[1] = chord[1].substring(1);
          chord[2] = "left";
        } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === ">") {
          chord[1] = chord[1].substring(1);
          chord[2] = "right";
        } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === "@") {
          chord[1] = chord[1].substring(1);
          var x = tokenizer.getFloat(chord[1]);
          if (x.digits === 0)
            warn("Missing first position in absolutely positioned annotation.", line, i);
          chord[1] = chord[1].substring(x.digits);
          if (chord[1][0] !== ",")
            warn("Missing comma absolutely positioned annotation.", line, i);
          chord[1] = chord[1].substring(1);
          var y = tokenizer.getFloat(chord[1]);
          if (y.digits === 0)
            warn("Missing second position in absolutely positioned annotation.", line, i);
          chord[1] = chord[1].substring(y.digits);
          var ws = tokenizer.skipWhiteSpace(chord[1]);
          chord[1] = chord[1].substring(ws);
          chord[2] = null;
          chord[3] = { x: x.value, y: y.value };
        } else {
          if (multilineVars.freegchord !== true) {
            chord[1] = chord[1].replace(/([ABCDEFG0-9])b/g, "$1\u266D");
            chord[1] = chord[1].replace(/([ABCDEFG0-9])#/g, "$1\u266F");
            chord[1] = chord[1].replace(/^([ABCDEFG])([♯♭]?)o([^A-Za-z])/g, "$1$2\xB0$3");
            chord[1] = chord[1].replace(/^([ABCDEFG])([♯♭]?)o$/g, "$1$2\xB0");
            chord[1] = chord[1].replace(/^([ABCDEFG])([♯♭]?)0([^A-Za-z])/g, "$1$2\xF8$3");
            chord[1] = chord[1].replace(/^([ABCDEFG])([♯♭]?)\^([^A-Za-z])/g, "$1$2\u2206$3");
          }
          chord[2] = "default";
          chord[1] = transpose.chordName(multilineVars, chord[1]);
        }
        return chord;
      }
      return [0, ""];
    };
    var letter_to_grace = function(line, i) {
      if (line.charAt(i) === "{") {
        var gra = tokenizer.getBrackettedSubstring(line, i, 1, "}");
        if (!gra[2])
          warn("Missing the closing '}' while parsing grace note", line, i);
        if (line[i + gra[0]] === ")") {
          gra[0]++;
          gra[1] += ")";
        }
        var gracenotes = [];
        var ii = 0;
        var inTie = false;
        while (ii < gra[1].length) {
          var acciaccatura = false;
          if (gra[1].charAt(ii) === "/") {
            acciaccatura = true;
            ii++;
          }
          var note = getCoreNote(gra[1], ii, {}, false);
          if (note !== null) {
            note.duration = note.duration / (multilineVars.default_length * 8);
            if (acciaccatura)
              note.acciaccatura = true;
            gracenotes.push(note);
            if (inTie) {
              note.endTie = true;
              inTie = false;
            }
            if (note.startTie)
              inTie = true;
            ii = note.endChar;
            delete note.endChar;
            if (note.end_beam) {
              note.endBeam = true;
              delete note.end_beam;
            }
          } else {
            if (gra[1].charAt(ii) === " ") {
              if (gracenotes.length > 0)
                gracenotes[gracenotes.length - 1].endBeam = true;
            } else
              warn("Unknown character '" + gra[1].charAt(ii) + "' while parsing grace note", line, i);
            ii++;
          }
        }
        if (gracenotes.length)
          return [gra[0], gracenotes];
      }
      return [0];
    };
    function letter_to_overlay(line, i) {
      if (line.charAt(i) === "&") {
        var start = i;
        while (line.charAt(i) && line.charAt(i) !== ":" && line.charAt(i) !== "|")
          i++;
        return [i - start, line.substring(start + 1, i)];
      }
      return [0];
    }
    function durationOfMeasure(multilineVars2) {
      var meter = multilineVars2.origMeter;
      if (!meter || meter.type !== "specified")
        return 1;
      if (!meter.value || meter.value.length === 0)
        return 1;
      return parseInt(meter.value[0].num, 10) / parseInt(meter.value[0].den, 10);
    }
    var legalAccents = [
      "trill",
      "lowermordent",
      "uppermordent",
      "mordent",
      "pralltriller",
      "accent",
      "fermata",
      "invertedfermata",
      "tenuto",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "+",
      "wedge",
      "open",
      "thumb",
      "snap",
      "turn",
      "roll",
      "breath",
      "shortphrase",
      "mediumphrase",
      "longphrase",
      "segno",
      "coda",
      "D.S.",
      "D.C.",
      "fine",
      "beambr1",
      "beambr2",
      "slide",
      "marcato",
      "upbow",
      "downbow",
      "/",
      "//",
      "///",
      "////",
      "trem1",
      "trem2",
      "trem3",
      "trem4",
      "turnx",
      "invertedturn",
      "invertedturnx",
      "trill(",
      "trill)",
      "arpeggio",
      "xstem",
      "mark",
      "umarcato",
      "style=normal",
      "style=harmonic",
      "style=rhythm",
      "style=x",
      "style=triangle"
    ];
    var volumeDecorations = [
      "p",
      "pp",
      "f",
      "ff",
      "mf",
      "mp",
      "ppp",
      "pppp",
      "fff",
      "ffff",
      "sfz"
    ];
    var dynamicDecorations = [
      "crescendo(",
      "crescendo)",
      "diminuendo(",
      "diminuendo)"
    ];
    var accentPseudonyms = [
      ["<", "accent"],
      [">", "accent"],
      ["tr", "trill"],
      ["plus", "+"],
      ["emphasis", "accent"],
      ["^", "umarcato"],
      ["marcato", "umarcato"]
    ];
    var accentDynamicPseudonyms = [
      ["<(", "crescendo("],
      ["<)", "crescendo)"],
      [">(", "diminuendo("],
      [">)", "diminuendo)"]
    ];
    var letter_to_accent = function(line, i) {
      var macro = multilineVars.macros[line.charAt(i)];
      if (macro !== void 0) {
        if (macro.charAt(0) === "!" || macro.charAt(0) === "+")
          macro = macro.substring(1);
        if (macro.charAt(macro.length - 1) === "!" || macro.charAt(macro.length - 1) === "+")
          macro = macro.substring(0, macro.length - 1);
        if (parseCommon.detect(legalAccents, function(acc) {
          return macro === acc;
        }))
          return [1, macro];
        else if (parseCommon.detect(volumeDecorations, function(acc) {
          return macro === acc;
        })) {
          if (multilineVars.volumePosition === "hidden")
            macro = "";
          return [1, macro];
        } else if (parseCommon.detect(dynamicDecorations, function(acc) {
          if (multilineVars.dynamicPosition === "hidden")
            macro = "";
          return macro === acc;
        })) {
          return [1, macro];
        } else {
          if (!parseCommon.detect(multilineVars.ignoredDecorations, function(dec) {
            return macro === dec;
          }))
            warn("Unknown macro: " + macro, line, i);
          return [1, ""];
        }
      }
      switch (line.charAt(i)) {
        case ".":
          if (line[i + 1] === "(" || line[i + 1] === "-")
            break;
          return [1, "staccato"];
        case "u":
          return [1, "upbow"];
        case "v":
          return [1, "downbow"];
        case "~":
          return [1, "irishroll"];
        case "!":
        case "+":
          var ret = tokenizer.getBrackettedSubstring(line, i, 5);
          if (ret[1].length > 1 && (ret[1].charAt(0) === "^" || ret[1].charAt(0) === "_"))
            ret[1] = ret[1].substring(1);
          if (parseCommon.detect(legalAccents, function(acc) {
            return ret[1] === acc;
          }))
            return ret;
          if (parseCommon.detect(volumeDecorations, function(acc) {
            return ret[1] === acc;
          })) {
            if (multilineVars.volumePosition === "hidden")
              ret[1] = "";
            return ret;
          }
          if (parseCommon.detect(dynamicDecorations, function(acc) {
            return ret[1] === acc;
          })) {
            if (multilineVars.dynamicPosition === "hidden")
              ret[1] = "";
            return ret;
          }
          if (parseCommon.detect(accentPseudonyms, function(acc) {
            if (ret[1] === acc[0]) {
              ret[1] = acc[1];
              return true;
            } else
              return false;
          }))
            return ret;
          if (parseCommon.detect(accentDynamicPseudonyms, function(acc) {
            if (ret[1] === acc[0]) {
              ret[1] = acc[1];
              return true;
            } else
              return false;
          })) {
            if (multilineVars.dynamicPosition === "hidden")
              ret[1] = "";
            return ret;
          }
          if (line.charAt(i) === "!" && (ret[0] === 1 || line.charAt(i + ret[0] - 1) !== "!"))
            return [1, null];
          warn("Unknown decoration: " + ret[1], line, i);
          ret[1] = "";
          return ret;
        case "H":
          return [1, "fermata"];
        case "J":
          return [1, "slide"];
        case "L":
          return [1, "accent"];
        case "M":
          return [1, "mordent"];
        case "O":
          return [1, "coda"];
        case "P":
          return [1, "pralltriller"];
        case "R":
          return [1, "roll"];
        case "S":
          return [1, "segno"];
        case "T":
          return [1, "trill"];
      }
      return [0, 0];
    };
    var letter_to_spacer = function(line, i) {
      var start = i;
      while (tokenizer.isWhiteSpace(line.charAt(i)))
        i++;
      return [i - start];
    };
    var letter_to_bar = function(line, curr_pos) {
      var ret = tokenizer.getBarLine(line, curr_pos);
      if (ret.len === 0)
        return [0, ""];
      if (ret.warn) {
        warn(ret.warn, line, curr_pos);
        return [ret.len, ""];
      }
      for (var ws = 0; ws < line.length; ws++)
        if (line.charAt(curr_pos + ret.len + ws) !== " ")
          break;
      var orig_bar_len = ret.len;
      if (line.charAt(curr_pos + ret.len + ws) === "[") {
        ret.len += ws + 1;
      }
      if (line.charAt(curr_pos + ret.len) === '"' && line.charAt(curr_pos + ret.len - 1) === "[") {
        var ending = tokenizer.getBrackettedSubstring(line, curr_pos + ret.len, 5);
        return [ret.len + ending[0], ret.token, ending[1]];
      }
      var retRep = tokenizer.getTokenOf(line.substring(curr_pos + ret.len), "1234567890-,");
      if (retRep.len === 0 || retRep.token[0] === "-")
        return [orig_bar_len, ret.token];
      return [ret.len + retRep.len, ret.token, retRep.token];
    };
    var tripletQ = {
      2: 3,
      3: 2,
      4: 3,
      5: 2,
      6: 2,
      7: 2,
      8: 3,
      9: 2
    };
    var letter_to_open_slurs_and_triplets = function(line, i) {
      var ret = {};
      var start = i;
      if (line[i] === "." && line[i + 1] === "(") {
        ret.dottedSlur = true;
        i++;
      }
      while (line.charAt(i) === "(" || tokenizer.isWhiteSpace(line.charAt(i))) {
        if (line.charAt(i) === "(") {
          if (i + 1 < line.length && (line.charAt(i + 1) >= "2" && line.charAt(i + 1) <= "9")) {
            if (ret.triplet !== void 0)
              warn("Can't nest triplets", line, i);
            else {
              ret.triplet = line.charAt(i + 1) - "0";
              ret.tripletQ = tripletQ[ret.triplet];
              ret.num_notes = ret.triplet;
              if (i + 2 < line.length && line.charAt(i + 2) === ":") {
                if (i + 3 < line.length && line.charAt(i + 3) === ":") {
                  if (i + 4 < line.length && (line.charAt(i + 4) >= "1" && line.charAt(i + 4) <= "9")) {
                    ret.num_notes = line.charAt(i + 4) - "0";
                    i += 3;
                  } else
                    warn("expected number after the two colons after the triplet to mark the duration", line, i);
                } else if (i + 3 < line.length && (line.charAt(i + 3) >= "1" && line.charAt(i + 3) <= "9")) {
                  ret.tripletQ = line.charAt(i + 3) - "0";
                  if (i + 4 < line.length && line.charAt(i + 4) === ":") {
                    if (i + 5 < line.length && (line.charAt(i + 5) >= "1" && line.charAt(i + 5) <= "9")) {
                      ret.num_notes = line.charAt(i + 5) - "0";
                      i += 4;
                    }
                  } else {
                    i += 2;
                  }
                } else
                  warn("expected number after the triplet to mark the duration", line, i);
              }
            }
            i++;
          } else {
            if (ret.startSlur === void 0)
              ret.startSlur = 1;
            else
              ret.startSlur++;
          }
        }
        i++;
      }
      ret.consumed = i - start;
      return ret;
    };
    MusicParser.prototype.startNewLine = function() {
      var params = { startChar: -1, endChar: -1 };
      if (multilineVars.partForNextLine.title)
        params.part = multilineVars.partForNextLine;
      params.clef = multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].clef !== void 0 ? parseCommon.clone(multilineVars.staves[multilineVars.currentVoice.staffNum].clef) : parseCommon.clone(multilineVars.clef);
      var scoreTranspose = multilineVars.currentVoice ? multilineVars.currentVoice.scoreTranspose : 0;
      params.key = parseKeyVoice.standardKey(multilineVars.key.root + multilineVars.key.acc + multilineVars.key.mode, multilineVars.key.root, multilineVars.key.acc, scoreTranspose);
      params.key.mode = multilineVars.key.mode;
      if (multilineVars.key.impliedNaturals)
        params.key.impliedNaturals = multilineVars.key.impliedNaturals;
      if (multilineVars.key.explicitAccidentals) {
        for (var i = 0; i < multilineVars.key.explicitAccidentals.length; i++) {
          var found = false;
          for (var j = 0; j < params.key.accidentals.length; j++) {
            if (params.key.accidentals[j].note === multilineVars.key.explicitAccidentals[i].note) {
              params.key.accidentals[j].acc = multilineVars.key.explicitAccidentals[i].acc;
              found = true;
            }
          }
          if (!found)
            params.key.accidentals.push(multilineVars.key.explicitAccidentals[i]);
        }
      }
      multilineVars.targetKey = params.key;
      if (params.key.explicitAccidentals)
        delete params.key.explicitAccidentals;
      parseKeyVoice.addPosToKey(params.clef, params.key);
      if (multilineVars.meter !== null) {
        if (multilineVars.currentVoice) {
          parseCommon.each(multilineVars.staves, function(st) {
            st.meter = multilineVars.meter;
          });
          params.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;
          multilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;
        } else
          params.meter = multilineVars.meter;
        multilineVars.meter = null;
      } else if (multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].meter) {
        params.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;
        multilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;
      }
      if (multilineVars.currentVoice && multilineVars.currentVoice.name)
        params.name = multilineVars.currentVoice.name;
      if (multilineVars.vocalfont)
        params.vocalfont = multilineVars.vocalfont;
      if (multilineVars.tripletfont)
        params.tripletfont = multilineVars.tripletfont;
      if (multilineVars.gchordfont)
        params.gchordfont = multilineVars.gchordfont;
      if (multilineVars.style)
        params.style = multilineVars.style;
      if (multilineVars.currentVoice) {
        var staff = multilineVars.staves[multilineVars.currentVoice.staffNum];
        if (staff.brace)
          params.brace = staff.brace;
        if (staff.bracket)
          params.bracket = staff.bracket;
        if (staff.connectBarLines)
          params.connectBarLines = staff.connectBarLines;
        if (staff.name)
          params.name = staff.name[multilineVars.currentVoice.index];
        if (staff.subname)
          params.subname = staff.subname[multilineVars.currentVoice.index];
        if (multilineVars.currentVoice.stem)
          params.stem = multilineVars.currentVoice.stem;
        if (multilineVars.currentVoice.stafflines)
          params.stafflines = multilineVars.currentVoice.stafflines;
        if (multilineVars.currentVoice.staffscale)
          params.staffscale = multilineVars.currentVoice.staffscale;
        if (multilineVars.currentVoice.scale)
          params.scale = multilineVars.currentVoice.scale;
        if (multilineVars.currentVoice.style)
          params.style = multilineVars.currentVoice.style;
        if (multilineVars.currentVoice.transpose)
          params.clef.transpose = multilineVars.currentVoice.transpose;
      }
      var isFirstVoice = multilineVars.currentVoice === void 0 || multilineVars.currentVoice.staffNum === 0 && multilineVars.currentVoice.index === 0;
      if (multilineVars.barNumbers === 0 && isFirstVoice && multilineVars.currBarNumber !== 1)
        params.barNumber = multilineVars.currBarNumber;
      tuneBuilder.startNewLine(params);
      if (multilineVars.key.impliedNaturals)
        delete multilineVars.key.impliedNaturals;
      multilineVars.partForNextLine = {};
      if (multilineVars.tempoForNextLine.length === 4)
        tuneBuilder.appendElement(multilineVars.tempoForNextLine[0], multilineVars.tempoForNextLine[1], multilineVars.tempoForNextLine[2], multilineVars.tempoForNextLine[3]);
      multilineVars.tempoForNextLine = [];
    };
    var addEndBeam = function(el2) {
      if (el2.duration !== void 0 && el2.duration < 0.25)
        el2.end_beam = true;
      return el2;
    };
    var pitches = { A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11 };
    var rests = { x: "invisible", X: "invisible-multimeasure", y: "spacer", z: "rest", Z: "multimeasure" };
    var accMap = { "dblflat": "__", "flat": "_", "natural": "=", "sharp": "^", "dblsharp": "^^", "quarterflat": "_/", "quartersharp": "^/" };
    var getCoreNote = function(line, index, el2, canHaveBrokenRhythm) {
      var isComplete = function(state2) {
        return state2 === "octave" || state2 === "duration" || state2 === "Zduration" || state2 === "broken_rhythm" || state2 === "end_slur";
      };
      var dottedTie;
      if (line[index] === "." && line[index + 1] === "-") {
        dottedTie = true;
        index++;
      }
      var state = "startSlur";
      var durationSetByPreviousNote = false;
      while (1) {
        switch (line.charAt(index)) {
          case "(":
            if (state === "startSlur") {
              if (el2.startSlur === void 0)
                el2.startSlur = 1;
              else
                el2.startSlur++;
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else
              return null;
            break;
          case ")":
            if (isComplete(state)) {
              if (el2.endSlur === void 0)
                el2.endSlur = 1;
              else
                el2.endSlur++;
            } else
              return null;
            break;
          case "^":
            if (state === "startSlur") {
              el2.accidental = "sharp";
              state = "sharp2";
            } else if (state === "sharp2") {
              el2.accidental = "dblsharp";
              state = "pitch";
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else
              return null;
            break;
          case "_":
            if (state === "startSlur") {
              el2.accidental = "flat";
              state = "flat2";
            } else if (state === "flat2") {
              el2.accidental = "dblflat";
              state = "pitch";
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else
              return null;
            break;
          case "=":
            if (state === "startSlur") {
              el2.accidental = "natural";
              state = "pitch";
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else
              return null;
            break;
          case "A":
          case "B":
          case "C":
          case "D":
          case "E":
          case "F":
          case "G":
          case "a":
          case "b":
          case "c":
          case "d":
          case "e":
          case "f":
          case "g":
            if (state === "startSlur" || state === "sharp2" || state === "flat2" || state === "pitch") {
              el2.pitch = pitches[line.charAt(index)];
              el2.name = line.charAt(index);
              if (el2.accidental)
                el2.name = accMap[el2.accidental] + el2.name;
              transpose.note(multilineVars, el2);
              state = "octave";
              if (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {
                el2.duration = multilineVars.default_length * multilineVars.next_note_duration;
                multilineVars.next_note_duration = 0;
                durationSetByPreviousNote = true;
              } else
                el2.duration = multilineVars.default_length;
              if (multilineVars.clef && multilineVars.clef.type === "perc" || multilineVars.currentVoice && multilineVars.currentVoice.clef === "perc") {
                var key = line.charAt(index);
                if (el2.accidental) {
                  key = accMap[el2.accidental] + key;
                }
                if (tune.formatting && tune.formatting.midi && tune.formatting.midi.drummap)
                  el2.midipitch = tune.formatting.midi.drummap[key];
              }
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else
              return null;
            break;
          case ",":
            if (state === "octave") {
              el2.pitch -= 7;
              el2.name += ",";
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else
              return null;
            break;
          case "'":
            if (state === "octave") {
              el2.pitch += 7;
              el2.name += "'";
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else
              return null;
            break;
          case "x":
          case "X":
          case "y":
          case "z":
          case "Z":
            if (state === "startSlur") {
              el2.rest = { type: rests[line.charAt(index)] };
              delete el2.accidental;
              delete el2.startSlur;
              delete el2.startTie;
              delete el2.endSlur;
              delete el2.endTie;
              delete el2.end_beam;
              delete el2.grace_notes;
              if (el2.rest.type.indexOf("multimeasure") >= 0) {
                el2.duration = tune.getBarLength();
                el2.rest.text = 1;
                state = "Zduration";
              } else {
                if (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {
                  el2.duration = multilineVars.default_length * multilineVars.next_note_duration;
                  multilineVars.next_note_duration = 0;
                  durationSetByPreviousNote = true;
                } else
                  el2.duration = multilineVars.default_length;
                state = "duration";
              }
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else
              return null;
            break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
          case "0":
          case "/":
            if (state === "octave" || state === "duration") {
              var fraction = tokenizer.getFraction(line, index);
              el2.duration = el2.duration * fraction.value;
              el2.endChar = fraction.index;
              while (fraction.index < line.length && (tokenizer.isWhiteSpace(line.charAt(fraction.index)) || line.charAt(fraction.index) === "-")) {
                if (line.charAt(fraction.index) === "-")
                  el2.startTie = {};
                else
                  el2 = addEndBeam(el2);
                fraction.index++;
              }
              index = fraction.index - 1;
              state = "broken_rhythm";
            } else if (state === "sharp2") {
              el2.accidental = "quartersharp";
              state = "pitch";
            } else if (state === "flat2") {
              el2.accidental = "quarterflat";
              state = "pitch";
            } else if (state === "Zduration") {
              var num = tokenizer.getNumber(line, index);
              el2.duration = num.num * tune.getBarLength();
              el2.rest.text = num.num;
              el2.endChar = num.index;
              return el2;
            } else
              return null;
            break;
          case "-":
            if (state === "startSlur") {
              tuneBuilder.addTieToLastNote(dottedTie);
              el2.endTie = true;
            } else if (state === "octave" || state === "duration" || state === "end_slur") {
              el2.startTie = {};
              if (!durationSetByPreviousNote && canHaveBrokenRhythm)
                state = "broken_rhythm";
              else {
                if (tokenizer.isWhiteSpace(line.charAt(index + 1)))
                  addEndBeam(el2);
                el2.endChar = index + 1;
                return el2;
              }
            } else if (state === "broken_rhythm") {
              el2.endChar = index;
              return el2;
            } else
              return null;
            break;
          case " ":
          case "	":
            if (isComplete(state)) {
              el2.end_beam = true;
              dottedTie = false;
              do {
                if (line.charAt(index) === "." && line.charAt(index + 1) === "-") {
                  dottedTie = true;
                  index++;
                }
                if (line.charAt(index) === "-") {
                  el2.startTie = {};
                  if (dottedTie)
                    el2.startTie.style = "dotted";
                }
                index++;
              } while (index < line.length && (tokenizer.isWhiteSpace(line.charAt(index)) || line.charAt(index) === "-") || line.charAt(index) === "." && line.charAt(index + 1) === "-");
              el2.endChar = index;
              if (!durationSetByPreviousNote && canHaveBrokenRhythm && (line.charAt(index) === "<" || line.charAt(index) === ">")) {
                index--;
                state = "broken_rhythm";
              } else
                return el2;
            } else
              return null;
            break;
          case ">":
          case "<":
            if (isComplete(state)) {
              if (canHaveBrokenRhythm) {
                var br2 = getBrokenRhythm(line, index);
                index += br2[0] - 1;
                multilineVars.next_note_duration = br2[2];
                el2.duration = br2[1] * el2.duration;
                state = "end_slur";
              } else {
                el2.endChar = index;
                return el2;
              }
            } else
              return null;
            break;
          default:
            if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            }
            return null;
        }
        index++;
        if (index === line.length) {
          if (isComplete(state)) {
            el2.endChar = index;
            return el2;
          } else
            return null;
        }
      }
      return null;
    };
    var getBrokenRhythm = function(line, index) {
      switch (line.charAt(index)) {
        case ">":
          if (index < line.length - 2 && line.charAt(index + 1) === ">" && line.charAt(index + 2) === ">")
            return [3, 1.875, 0.125];
          else if (index < line.length - 1 && line.charAt(index + 1) === ">")
            return [2, 1.75, 0.25];
          else
            return [1, 1.5, 0.5];
        case "<":
          if (index < line.length - 2 && line.charAt(index + 1) === "<" && line.charAt(index + 2) === "<")
            return [3, 0.125, 1.875];
          else if (index < line.length - 1 && line.charAt(index + 1) === "<")
            return [2, 0.25, 1.75];
          else
            return [1, 0.5, 1.5];
      }
      return null;
    };
    module.exports = MusicParser;
  }
});

// node_modules/abcjs/src/parse/abc_tokenizer.js
var require_abc_tokenizer = __commonJS({
  "node_modules/abcjs/src/parse/abc_tokenizer.js"(exports, module) {
    var parseCommon = require_abc_common();
    var Tokenizer = function(lines, multilineVars) {
      this.lineIndex = 0;
      this.lines = lines;
      this.multilineVars = multilineVars;
      this.skipWhiteSpace = function(str) {
        for (var i = 0; i < str.length; i++) {
          if (!this.isWhiteSpace(str.charAt(i)))
            return i;
        }
        return str.length;
      };
      var finished = function(str, i) {
        return i >= str.length;
      };
      this.eatWhiteSpace = function(line, index) {
        for (var i = index; i < line.length; i++) {
          if (!this.isWhiteSpace(line.charAt(i)))
            return i - index;
        }
        return i - index;
      };
      this.getKeyPitch = function(str) {
        var i = this.skipWhiteSpace(str);
        if (finished(str, i))
          return { len: 0 };
        switch (str.charAt(i)) {
          case "A":
            return { len: i + 1, token: "A" };
          case "B":
            return { len: i + 1, token: "B" };
          case "C":
            return { len: i + 1, token: "C" };
          case "D":
            return { len: i + 1, token: "D" };
          case "E":
            return { len: i + 1, token: "E" };
          case "F":
            return { len: i + 1, token: "F" };
          case "G":
            return { len: i + 1, token: "G" };
        }
        return { len: 0 };
      };
      this.getSharpFlat = function(str) {
        if (str === "bass")
          return { len: 0 };
        switch (str.charAt(0)) {
          case "#":
            return { len: 1, token: "#" };
          case "b":
            return { len: 1, token: "b" };
        }
        return { len: 0 };
      };
      this.getMode = function(str) {
        var skipAlpha = function(str2, start) {
          while (start < str2.length && (str2.charAt(start) >= "a" && str2.charAt(start) <= "z" || str2.charAt(start) >= "A" && str2.charAt(start) <= "Z"))
            start++;
          return start;
        };
        var i = this.skipWhiteSpace(str);
        if (finished(str, i))
          return { len: 0 };
        var firstThree = str.substring(i, i + 3).toLowerCase();
        if (firstThree.length > 1 && firstThree.charAt(1) === " " || firstThree.charAt(1) === "^" || firstThree.charAt(1) === "_" || firstThree.charAt(1) === "=")
          firstThree = firstThree.charAt(0);
        switch (firstThree) {
          case "mix":
            return { len: skipAlpha(str, i), token: "Mix" };
          case "dor":
            return { len: skipAlpha(str, i), token: "Dor" };
          case "phr":
            return { len: skipAlpha(str, i), token: "Phr" };
          case "lyd":
            return { len: skipAlpha(str, i), token: "Lyd" };
          case "loc":
            return { len: skipAlpha(str, i), token: "Loc" };
          case "aeo":
            return { len: skipAlpha(str, i), token: "m" };
          case "maj":
            return { len: skipAlpha(str, i), token: "" };
          case "ion":
            return { len: skipAlpha(str, i), token: "" };
          case "min":
            return { len: skipAlpha(str, i), token: "m" };
          case "m":
            return { len: skipAlpha(str, i), token: "m" };
        }
        return { len: 0 };
      };
      this.getClef = function(str, bExplicitOnly) {
        var strOrig = str;
        var i = this.skipWhiteSpace(str);
        if (finished(str, i))
          return { len: 0 };
        var needsClef = false;
        var strClef = str.substring(i);
        if (parseCommon.startsWith(strClef, "clef=")) {
          needsClef = true;
          strClef = strClef.substring(5);
          i += 5;
        }
        if (strClef.length === 0 && needsClef)
          return { len: i + 5, warn: "No clef specified: " + strOrig };
        var j = this.skipWhiteSpace(strClef);
        if (finished(strClef, j))
          return { len: 0 };
        if (j > 0) {
          i += j;
          strClef = strClef.substring(j);
        }
        var name = null;
        if (parseCommon.startsWith(strClef, "treble"))
          name = "treble";
        else if (parseCommon.startsWith(strClef, "bass3"))
          name = "bass3";
        else if (parseCommon.startsWith(strClef, "bass"))
          name = "bass";
        else if (parseCommon.startsWith(strClef, "tenor"))
          name = "tenor";
        else if (parseCommon.startsWith(strClef, "alto2"))
          name = "alto2";
        else if (parseCommon.startsWith(strClef, "alto1"))
          name = "alto1";
        else if (parseCommon.startsWith(strClef, "alto"))
          name = "alto";
        else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, "none")))
          name = "none";
        else if (parseCommon.startsWith(strClef, "perc"))
          name = "perc";
        else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, "C")))
          name = "tenor";
        else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, "F")))
          name = "bass";
        else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, "G")))
          name = "treble";
        else
          return { len: i + 5, warn: "Unknown clef specified: " + strOrig };
        strClef = strClef.substring(name.length);
        j = this.isMatch(strClef, "+8");
        if (j > 0)
          name += "+8";
        else {
          j = this.isMatch(strClef, "-8");
          if (j > 0)
            name += "-8";
        }
        return { len: i + name.length, token: name, explicit: needsClef };
      };
      this.getBarLine = function(line, i) {
        switch (line.charAt(i)) {
          case "]":
            ++i;
            switch (line.charAt(i)) {
              case "|":
                return { len: 2, token: "bar_thick_thin" };
              case "[":
                ++i;
                if (line.charAt(i) >= "1" && line.charAt(i) <= "9" || line.charAt(i) === '"')
                  return { len: 2, token: "bar_invisible" };
                return { len: 1, warn: "Unknown bar symbol" };
              default:
                return { len: 1, token: "bar_invisible" };
            }
            break;
          case ":":
            ++i;
            switch (line.charAt(i)) {
              case ":":
                return { len: 2, token: "bar_dbl_repeat" };
              case "|":
                ++i;
                switch (line.charAt(i)) {
                  case "]":
                    ++i;
                    switch (line.charAt(i)) {
                      case "|":
                        ++i;
                        if (line.charAt(i) === ":")
                          return { len: 5, token: "bar_dbl_repeat" };
                        return { len: 3, token: "bar_right_repeat" };
                      default:
                        return { len: 3, token: "bar_right_repeat" };
                    }
                    break;
                  case "|":
                    ++i;
                    if (line.charAt(i) === ":")
                      return { len: 4, token: "bar_dbl_repeat" };
                    return { len: 3, token: "bar_right_repeat" };
                  default:
                    return { len: 2, token: "bar_right_repeat" };
                }
                break;
              default:
                return { len: 1, warn: "Unknown bar symbol" };
            }
            break;
          case "[":
            ++i;
            if (line.charAt(i) === "|") {
              ++i;
              switch (line.charAt(i)) {
                case ":":
                  return { len: 3, token: "bar_left_repeat" };
                case "]":
                  return { len: 3, token: "bar_invisible" };
                default:
                  return { len: 2, token: "bar_thick_thin" };
              }
            } else {
              if (line.charAt(i) >= "1" && line.charAt(i) <= "9" || line.charAt(i) === '"')
                return { len: 1, token: "bar_invisible" };
              return { len: 0 };
            }
            break;
          case "|":
            ++i;
            switch (line.charAt(i)) {
              case "]":
                return { len: 2, token: "bar_thin_thick" };
              case "|":
                ++i;
                if (line.charAt(i) === ":")
                  return { len: 3, token: "bar_left_repeat" };
                return { len: 2, token: "bar_thin_thin" };
              case ":":
                var colons = 0;
                while (line.charAt(i + colons) === ":")
                  colons++;
                return { len: 1 + colons, token: "bar_left_repeat" };
              default:
                return { len: 1, token: "bar_thin" };
            }
            break;
        }
        return { len: 0 };
      };
      this.getTokenOf = function(str, legalChars) {
        for (var i = 0; i < str.length; i++) {
          if (legalChars.indexOf(str.charAt(i)) < 0)
            return { len: i, token: str.substring(0, i) };
        }
        return { len: i, token: str };
      };
      this.getToken = function(str, start, end) {
        var i = start;
        while (i < end && !this.isWhiteSpace(str.charAt(i)))
          i++;
        return str.substring(start, i);
      };
      this.isMatch = function(str, match) {
        var i = this.skipWhiteSpace(str);
        if (finished(str, i))
          return 0;
        if (parseCommon.startsWith(str.substring(i), match))
          return i + match.length;
        return 0;
      };
      this.getPitchFromTokens = function(tokens) {
        var ret = {};
        var pitches = { A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11 };
        ret.position = pitches[tokens[0].token];
        if (ret.position === void 0)
          return { warn: "Pitch expected. Found: " + tokens[0].token };
        tokens.shift();
        while (tokens.length) {
          switch (tokens[0].token) {
            case ",":
              ret.position -= 7;
              tokens.shift();
              break;
            case "'":
              ret.position += 7;
              tokens.shift();
              break;
            default:
              return ret;
          }
        }
        return ret;
      };
      this.getKeyAccidentals2 = function(tokens) {
        var accs;
        while (tokens.length > 0) {
          var acc;
          if (tokens[0].token === "^") {
            acc = "sharp";
            tokens.shift();
            if (tokens.length === 0)
              return { accs, warn: "Expected note name after " + acc };
            switch (tokens[0].token) {
              case "^":
                acc = "dblsharp";
                tokens.shift();
                break;
              case "/":
                acc = "quartersharp";
                tokens.shift();
                break;
            }
          } else if (tokens[0].token === "=") {
            acc = "natural";
            tokens.shift();
          } else if (tokens[0].token === "_") {
            acc = "flat";
            tokens.shift();
            if (tokens.length === 0)
              return { accs, warn: "Expected note name after " + acc };
            switch (tokens[0].token) {
              case "_":
                acc = "dblflat";
                tokens.shift();
                break;
              case "/":
                acc = "quarterflat";
                tokens.shift();
                break;
            }
          } else {
            return { accs };
          }
          if (tokens.length === 0)
            return { accs, warn: "Expected note name after " + acc };
          switch (tokens[0].token.charAt(0)) {
            case "a":
            case "b":
            case "c":
            case "d":
            case "e":
            case "f":
            case "g":
            case "A":
            case "B":
            case "C":
            case "D":
            case "E":
            case "F":
            case "G":
              if (accs === void 0)
                accs = [];
              accs.push({ acc, note: tokens[0].token.charAt(0) });
              if (tokens[0].token.length === 1)
                tokens.shift();
              else
                tokens[0].token = tokens[0].token.substring(1);
              break;
            default:
              return { accs, warn: "Expected note name after " + acc + " Found: " + tokens[0].token };
          }
        }
        return { accs };
      };
      this.getKeyAccidental = function(str) {
        var accTranslation = {
          "^": "sharp",
          "^^": "dblsharp",
          "=": "natural",
          "_": "flat",
          "__": "dblflat",
          "_/": "quarterflat",
          "^/": "quartersharp"
        };
        var i = this.skipWhiteSpace(str);
        if (finished(str, i))
          return { len: 0 };
        var acc = null;
        switch (str.charAt(i)) {
          case "^":
          case "_":
          case "=":
            acc = str.charAt(i);
            break;
          default:
            return { len: 0 };
        }
        i++;
        if (finished(str, i))
          return { len: 1, warn: "Expected note name after accidental" };
        switch (str.charAt(i)) {
          case "a":
          case "b":
          case "c":
          case "d":
          case "e":
          case "f":
          case "g":
          case "A":
          case "B":
          case "C":
          case "D":
          case "E":
          case "F":
          case "G":
            return { len: i + 1, token: { acc: accTranslation[acc], note: str.charAt(i) } };
          case "^":
          case "_":
          case "/":
            acc += str.charAt(i);
            i++;
            if (finished(str, i))
              return { len: 2, warn: "Expected note name after accidental" };
            switch (str.charAt(i)) {
              case "a":
              case "b":
              case "c":
              case "d":
              case "e":
              case "f":
              case "g":
              case "A":
              case "B":
              case "C":
              case "D":
              case "E":
              case "F":
              case "G":
                return { len: i + 1, token: { acc: accTranslation[acc], note: str.charAt(i) } };
              default:
                return { len: 2, warn: "Expected note name after accidental" };
            }
            break;
          default:
            return { len: 1, warn: "Expected note name after accidental" };
        }
      };
      this.isWhiteSpace = function(ch) {
        return ch === " " || ch === "	" || ch === "";
      };
      this.getMeat = function(line, start, end) {
        var comment = line.indexOf("%", start);
        if (comment >= 0 && comment < end)
          end = comment;
        while (start < end && (line.charAt(start) === " " || line.charAt(start) === "	" || line.charAt(start) === ""))
          start++;
        while (start < end && (line.charAt(end - 1) === " " || line.charAt(end - 1) === "	" || line.charAt(end - 1) === ""))
          end--;
        return { start, end };
      };
      var isLetter = function(ch) {
        return ch >= "A" && ch <= "Z" || ch >= "a" && ch <= "z";
      };
      var isNumber = function(ch) {
        return ch >= "0" && ch <= "9";
      };
      this.tokenize = function(line, start, end, alphaUntilWhiteSpace) {
        var ret = this.getMeat(line, start, end);
        start = ret.start;
        end = ret.end;
        var tokens = [];
        var i;
        while (start < end) {
          if (line.charAt(start) === '"') {
            i = start + 1;
            while (i < end && line.charAt(i) !== '"')
              i++;
            tokens.push({ type: "quote", token: line.substring(start + 1, i), start: start + 1, end: i });
            i++;
          } else if (isLetter(line.charAt(start))) {
            i = start + 1;
            if (alphaUntilWhiteSpace)
              while (i < end && !this.isWhiteSpace(line.charAt(i)))
                i++;
            else
              while (i < end && isLetter(line.charAt(i)))
                i++;
            tokens.push({ type: "alpha", token: line.substring(start, i), continueId: isNumber(line.charAt(i)), start, end: i });
            start = i + 1;
          } else if (line.charAt(start) === "." && isNumber(line.charAt(i + 1))) {
            i = start + 1;
            var int2 = null;
            var float2 = null;
            while (i < end && isNumber(line.charAt(i)))
              i++;
            float2 = parseFloat(line.substring(start, i));
            tokens.push({ type: "number", token: line.substring(start, i), intt: int2, floatt: float2, continueId: isLetter(line.charAt(i)), start, end: i });
            start = i + 1;
          } else if (isNumber(line.charAt(start)) || line.charAt(start) === "-" && isNumber(line.charAt(i + 1))) {
            i = start + 1;
            var intt = null;
            var floatt = null;
            while (i < end && isNumber(line.charAt(i)))
              i++;
            if (line.charAt(i) === "." && isNumber(line.charAt(i + 1))) {
              i++;
              while (i < end && isNumber(line.charAt(i)))
                i++;
            } else
              intt = parseInt(line.substring(start, i));
            floatt = parseFloat(line.substring(start, i));
            tokens.push({ type: "number", token: line.substring(start, i), intt, floatt, continueId: isLetter(line.charAt(i)), start, end: i });
            start = i + 1;
          } else if (line.charAt(start) === " " || line.charAt(start) === "	") {
            i = start + 1;
          } else {
            tokens.push({ type: "punct", token: line.charAt(start), start, end: start + 1 });
            i = start + 1;
          }
          start = i;
        }
        return tokens;
      };
      this.getVoiceToken = function(line, start, end) {
        var i = start;
        while (i < end && this.isWhiteSpace(line.charAt(i)) || line.charAt(i) === "=")
          i++;
        if (line.charAt(i) === '"') {
          var close = line.indexOf('"', i + 1);
          if (close === -1 || close >= end)
            return { len: 1, err: "Missing close quote" };
          return { len: close - start + 1, token: this.translateString(line.substring(i + 1, close)) };
        } else {
          var ii = i;
          while (ii < end && !this.isWhiteSpace(line.charAt(ii)) && line.charAt(ii) !== "=")
            ii++;
          return { len: ii - start + 1, token: line.substring(i, ii) };
        }
      };
      var charMap = {
        "`a": "\xE0",
        "'a": "\xE1",
        "^a": "\xE2",
        "~a": "\xE3",
        '"a': "\xE4",
        "oa": "\xE5",
        "aa": "\xE5",
        "=a": "\u0101",
        "ua": "\u0103",
        ";a": "\u0105",
        "`e": "\xE8",
        "'e": "\xE9",
        "^e": "\xEA",
        '"e': "\xEB",
        "=e": "\u0113",
        "ue": "\u0115",
        ";e": "\u0119",
        ".e": "\u0117",
        "`i": "\xEC",
        "'i": "\xED",
        "^i": "\xEE",
        '"i': "\xEF",
        "=i": "\u012B",
        "ui": "\u012D",
        ";i": "\u012F",
        "`o": "\xF2",
        "'o": "\xF3",
        "^o": "\xF4",
        "~o": "\xF5",
        '"o': "\xF6",
        "=o": "\u014D",
        "uo": "\u014F",
        "/o": "\xF8",
        "`u": "\xF9",
        "'u": "\xFA",
        "^u": "\xFB",
        "~u": "\u0169",
        '"u': "\xFC",
        "ou": "\u016F",
        "=u": "\u016B",
        "uu": "\u016D",
        ";u": "\u0173",
        "`A": "\xC0",
        "'A": "\xC1",
        "^A": "\xC2",
        "~A": "\xC3",
        '"A': "\xC4",
        "oA": "\xC5",
        "AA": "\xC5",
        "=A": "\u0100",
        "uA": "\u0102",
        ";A": "\u0104",
        "`E": "\xC8",
        "'E": "\xC9",
        "^E": "\xCA",
        '"E': "\xCB",
        "=E": "\u0112",
        "uE": "\u0114",
        ";E": "\u0118",
        ".E": "\u0116",
        "`I": "\xCC",
        "'I": "\xCD",
        "^I": "\xCE",
        "~I": "\u0128",
        '"I': "\xCF",
        "=I": "\u012A",
        "uI": "\u012C",
        ";I": "\u012E",
        ".I": "\u0130",
        "`O": "\xD2",
        "'O": "\xD3",
        "^O": "\xD4",
        "~O": "\xD5",
        '"O': "\xD6",
        "=O": "\u014C",
        "uO": "\u014E",
        "/O": "\xD8",
        "`U": "\xD9",
        "'U": "\xDA",
        "^U": "\xDB",
        "~U": "\u0168",
        '"U': "\xDC",
        "oU": "\u016E",
        "=U": "\u016A",
        "uU": "\u016C",
        ";U": "\u0172",
        "ae": "\xE6",
        "AE": "\xC6",
        "oe": "\u0153",
        "OE": "\u0152",
        "ss": "\xDF",
        "'c": "\u0107",
        "^c": "\u0109",
        "uc": "\u010D",
        "cc": "\xE7",
        ".c": "\u010B",
        "cC": "\xC7",
        "'C": "\u0106",
        "^C": "\u0108",
        "uC": "\u010C",
        ".C": "\u010A",
        "~N": "\xD1",
        "~n": "\xF1",
        "=s": "\u0161",
        "vs": "\u0161",
        "DH": "\xD0",
        "dh": "\xF0",
        "HO": "\u0150",
        "Ho": "\u0151",
        "HU": "\u0170",
        "Hu": "\u0171",
        "'Y": "\xDD",
        "'y": "\xFD",
        "^Y": "\u0176",
        "^y": "\u0177",
        '"Y': "\u0178",
        '"y': "\xFF",
        "vS": "\u0160",
        "vZ": "\u017D",
        "vz": "\u017E"
      };
      var charMap1 = {
        "#": "\u266F",
        "b": "\u266D",
        "=": "\u266E"
      };
      var charMap2 = {
        "201": "\u266F",
        "202": "\u266D",
        "203": "\u266E",
        "241": "\xA1",
        "242": "\xA2",
        "252": "a",
        "262": "2",
        "272": "o",
        "302": "\xC2",
        "312": "\xCA",
        "322": "\xD2",
        "332": "\xDA",
        "342": "\xE2",
        "352": "\xEA",
        "362": "\xF2",
        "372": "\xFA",
        "243": "\xA3",
        "253": "\xAB",
        "263": "3",
        "273": "\xBB",
        "303": "\xC3",
        "313": "\xCB",
        "323": "\xD3",
        "333": "\xDB",
        "343": "\xE3",
        "353": "\xEB",
        "363": "\xF3",
        "373": "\xFB",
        "244": "\xA4",
        "254": "\xAC",
        "264": "  \u0301",
        "274": "1\u20444",
        "304": "\xC4",
        "314": "\xCC",
        "324": "\xD4",
        "334": "\xDC",
        "344": "\xE4",
        "354": "\xEC",
        "364": "\xF4",
        "374": "\xFC",
        "245": "\xA5",
        "255": "-",
        "265": "\u03BC",
        "275": "1\u20442",
        "305": "\xC5",
        "315": "\xCD",
        "325": "\xD5",
        "335": "\xDD",
        "345": "\xE5",
        "355": "\xED",
        "365": "\xF5",
        "375": "\xFD",
        "246": "\xA6",
        "256": "\xAE",
        "266": "\xB6",
        "276": "3\u20444",
        "306": "\xC6",
        "316": "\xCE",
        "326": "\xD6",
        "336": "\xDE",
        "346": "\xE6",
        "356": "\xEE",
        "366": "\xF6",
        "376": "\xFE",
        "247": "\xA7",
        "257": " \u0304",
        "267": "\xB7",
        "277": "\xBF",
        "307": "\xC7",
        "317": "\xCF",
        "327": "\xD7",
        "337": "\xDF",
        "347": "\xE7",
        "357": "\xEF",
        "367": "\xF7",
        "377": "\xFF",
        "250": " \u0308",
        "260": "\xB0",
        "270": " \u0327",
        "300": "\xC0",
        "310": "\xC8",
        "320": "\xD0",
        "330": "\xD8",
        "340": "\xE0",
        "350": "\xE8",
        "360": "\xF0",
        "370": "\xF8",
        "251": "\xA9",
        "261": "\xB1",
        "271": "1",
        "301": "\xC1",
        "311": "\xC9",
        "321": "\xD1",
        "331": "\xD9",
        "341": "\xE1",
        "351": "\xE9",
        "361": "\xF1",
        "371": "\xF9"
      };
      this.translateString = function(str) {
        var arr = str.split("\\");
        if (arr.length === 1)
          return str;
        var out = null;
        parseCommon.each(arr, function(s) {
          if (out === null)
            out = s;
          else {
            var c = charMap[s.substring(0, 2)];
            if (c !== void 0)
              out += c + s.substring(2);
            else {
              c = charMap2[s.substring(0, 3)];
              if (c !== void 0)
                out += c + s.substring(3);
              else {
                c = charMap1[s.substring(0, 1)];
                if (c !== void 0)
                  out += c + s.substring(1);
                else
                  out += "\\" + s;
              }
            }
          }
        });
        return out;
      };
      this.getNumber = function(line, index) {
        var num = 0;
        while (index < line.length) {
          switch (line.charAt(index)) {
            case "0":
              num = num * 10;
              index++;
              break;
            case "1":
              num = num * 10 + 1;
              index++;
              break;
            case "2":
              num = num * 10 + 2;
              index++;
              break;
            case "3":
              num = num * 10 + 3;
              index++;
              break;
            case "4":
              num = num * 10 + 4;
              index++;
              break;
            case "5":
              num = num * 10 + 5;
              index++;
              break;
            case "6":
              num = num * 10 + 6;
              index++;
              break;
            case "7":
              num = num * 10 + 7;
              index++;
              break;
            case "8":
              num = num * 10 + 8;
              index++;
              break;
            case "9":
              num = num * 10 + 9;
              index++;
              break;
            default:
              return { num, index };
          }
        }
        return { num, index };
      };
      this.getFraction = function(line, index) {
        var num = 1;
        var den = 1;
        if (line.charAt(index) !== "/") {
          var ret = this.getNumber(line, index);
          num = ret.num;
          index = ret.index;
        }
        if (line.charAt(index) === "/") {
          index++;
          if (line.charAt(index) === "/") {
            var div = 0.5;
            while (line.charAt(index++) === "/")
              div = div / 2;
            return { value: num * div, index: index - 1 };
          } else {
            var iSave = index;
            var ret2 = this.getNumber(line, index);
            if (ret2.num === 0 && iSave === index)
              ret2.num = 2;
            if (ret2.num !== 0)
              den = ret2.num;
            index = ret2.index;
          }
        }
        return { value: num / den, index };
      };
      this.theReverser = function(str) {
        if (parseCommon.endsWith(str, ", The"))
          return "The " + str.substring(0, str.length - 5);
        if (parseCommon.endsWith(str, ", A"))
          return "A " + str.substring(0, str.length - 3);
        return str;
      };
      this.stripComment = function(str) {
        var i = str.indexOf("%");
        if (i >= 0)
          return parseCommon.strip(str.substring(0, i));
        return parseCommon.strip(str);
      };
      this.getInt = function(str) {
        var x = parseInt(str);
        if (isNaN(x))
          return { digits: 0 };
        var s = "" + x;
        var i = str.indexOf(s);
        return { value: x, digits: i + s.length };
      };
      this.getFloat = function(str) {
        var x = parseFloat(str);
        if (isNaN(x))
          return { digits: 0 };
        var s = "" + x;
        var i = str.indexOf(s);
        return { value: x, digits: i + s.length };
      };
      this.getMeasurement = function(tokens) {
        if (tokens.length === 0)
          return { used: 0 };
        var used = 1;
        var num = "";
        if (tokens[0].token === "-") {
          tokens.shift();
          num = "-";
          used++;
        } else if (tokens[0].type !== "number")
          return { used: 0 };
        num += tokens.shift().token;
        if (tokens.length === 0)
          return { used: 1, value: parseInt(num) };
        var x = tokens.shift();
        if (x.token === ".") {
          used++;
          if (tokens.length === 0)
            return { used, value: parseInt(num) };
          if (tokens[0].type === "number") {
            x = tokens.shift();
            num = num + "." + x.token;
            used++;
            if (tokens.length === 0)
              return { used, value: parseFloat(num) };
          }
          x = tokens.shift();
        }
        switch (x.token) {
          case "pt":
            return { used: used + 1, value: parseFloat(num) };
          case "cm":
            return { used: used + 1, value: parseFloat(num) / 2.54 * 72 };
          case "in":
            return { used: used + 1, value: parseFloat(num) * 72 };
          default:
            tokens.unshift(x);
            return { used, value: parseFloat(num) };
        }
        return { used: 0 };
      };
      var substInChord = function(str) {
        while (str.indexOf("\\n") !== -1) {
          str = str.replace("\\n", "\n");
        }
        return str;
      };
      this.getBrackettedSubstring = function(line, i, maxErrorChars, _matchChar) {
        var matchChar = _matchChar || line.charAt(i);
        var pos = i + 1;
        while (pos < line.length && line.charAt(pos) !== matchChar)
          ++pos;
        if (line.charAt(pos) === matchChar)
          return [pos - i + 1, substInChord(line.substring(i + 1, pos)), true];
        else {
          pos = i + maxErrorChars;
          if (pos > line.length - 1)
            pos = line.length - 1;
          return [pos - i + 1, substInChord(line.substring(i + 1, pos)), false];
        }
      };
    };
    Tokenizer.prototype.peekLine = function() {
      return this.lines[this.lineIndex];
    };
    Tokenizer.prototype.nextLine = function() {
      if (this.lineIndex > 0) {
        this.multilineVars.iChar += this.lines[this.lineIndex - 1].length + 1;
      }
      if (this.lineIndex < this.lines.length) {
        var result = this.lines[this.lineIndex];
        this.lineIndex++;
        return result;
      }
      return null;
    };
    module.exports = Tokenizer;
  }
});

// node_modules/abcjs/src/parse/wrap_lines.js
var require_wrap_lines = __commonJS({
  "node_modules/abcjs/src/parse/wrap_lines.js"(exports, module) {
    function wrapLines(tune, lineBreaks, barNumbers) {
      if (!lineBreaks || tune.lines.length === 0)
        return;
      var lines = tune.deline({ lineBreaks: false });
      var linesBreakElements = findLineBreaks(lines, lineBreaks);
      tune.lines = addLineBreaks(lines, linesBreakElements, barNumbers);
      tune.lineBreaks = linesBreakElements;
    }
    function addLineBreaks(lines, linesBreakElements, barNumbers) {
      var outputLines = [];
      var lastKeySig = [];
      var lastStem = [];
      var currentBarNumber = 1;
      for (var i = 0; i < linesBreakElements.length; i++) {
        var action = linesBreakElements[i];
        if (lines[action.ogLine].staff) {
          var inputStaff = lines[action.ogLine].staff[action.staff];
          if (!outputLines[action.line]) {
            outputLines[action.line] = { staff: [] };
          }
          if (!outputLines[action.line].staff[action.staff]) {
            outputLines[action.line].staff[action.staff] = { voices: [] };
            if (barNumbers !== void 0 && action.staff === 0 && action.line > 0) {
              outputLines[action.line].staff[action.staff].barNumber = currentBarNumber;
            }
            var keys = Object.keys(inputStaff);
            for (var k = 0; k < keys.length; k++) {
              var skip = keys[k] === "voices";
              if (keys[k] === "meter" && action.line !== 0)
                skip = true;
              if (!skip)
                outputLines[action.line].staff[action.staff][keys[k]] = inputStaff[keys[k]];
            }
            if (lastKeySig[action.staff])
              outputLines[action.line].staff[action.staff].key = lastKeySig[action.staff];
          }
          if (!outputLines[action.line].staff[action.staff].voices[action.voice]) {
            outputLines[action.line].staff[action.staff].voices[action.voice] = [];
          }
          outputLines[action.line].staff[action.staff].voices[action.voice] = lines[action.ogLine].staff[action.staff].voices[action.voice].slice(action.start, action.end + 1);
          if (lastStem[action.staff * 10 + action.voice])
            outputLines[action.line].staff[action.staff].voices[action.voice].unshift({ el_type: "stem", direction: lastStem[action.staff * 10 + action.voice].direction });
          var currVoice = outputLines[action.line].staff[action.staff].voices[action.voice];
          for (var kk = currVoice.length - 1; kk >= 0; kk--) {
            if (currVoice[kk].el_type === "key") {
              lastKeySig[action.staff] = {
                root: currVoice[kk].root,
                acc: currVoice[kk].acc,
                mode: currVoice[kk].mode,
                accidentals: currVoice[kk].accidentals.filter(function(acc) {
                  return acc.acc !== "natural";
                })
              };
              break;
            }
          }
          for (kk = currVoice.length - 1; kk >= 0; kk--) {
            if (currVoice[kk].el_type === "stem") {
              lastStem[action.staff * 10 + action.voice] = {
                direction: currVoice[kk].direction
              };
              break;
            }
          }
          if (barNumbers !== void 0 && action.staff === 0 && action.voice === 0) {
            for (kk = 0; kk < currVoice.length; kk++) {
              if (currVoice[kk].el_type === "bar") {
                currentBarNumber++;
                if (kk === currVoice.length - 1)
                  delete currVoice[kk].barNumber;
                else
                  currVoice[kk].barNumber = currentBarNumber;
              }
            }
          }
        } else {
          outputLines[action.line] = lines[action.ogLine];
        }
      }
      for (var ii = 0; ii < outputLines.length; ii++) {
        if (outputLines[ii].staff) {
          outputLines[ii].staff = outputLines[ii].staff.filter(function(el) {
            return el != null;
          });
        }
      }
      return outputLines;
    }
    function findLineBreaks(lines, lineBreakArray) {
      var lineBreakIndexes = [];
      var lbai = 0;
      var lineCounter = 0;
      var outputLine = 0;
      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line.staff) {
          var lineStart = lineCounter;
          var lineBreaks = lineBreakArray[lbai];
          lbai++;
          for (var j = 0; j < line.staff.length; j++) {
            var staff = line.staff[j];
            for (var k = 0; k < staff.voices.length; k++) {
              outputLine = lineStart;
              var measureNumber = 0;
              var lbi = 0;
              var voice = staff.voices[k];
              var start = 0;
              for (var e = 0; e < voice.length; e++) {
                var el = voice[e];
                if (el.el_type === "bar") {
                  if (lineBreaks[lbi] === measureNumber) {
                    lineBreakIndexes.push({ ogLine: i, line: outputLine, staff: j, voice: k, start, end: e });
                    start = e + 1;
                    outputLine++;
                    lineCounter = Math.max(lineCounter, outputLine);
                    lbi++;
                  }
                  measureNumber++;
                }
              }
              lineBreakIndexes.push({ ogLine: i, line: outputLine, staff: j, voice: k, start, end: voice.length });
              outputLine++;
              lineCounter = Math.max(lineCounter, outputLine);
            }
          }
        } else {
          lineBreakIndexes.push({ ogLine: i, line: outputLine });
          outputLine++;
          lineCounter = Math.max(lineCounter, outputLine);
        }
      }
      return lineBreakIndexes;
    }
    function freeFormLineBreaks(widths, lineBreakPoint) {
      var lineBreaks = [];
      var totals = [];
      var totalThisLine = 0;
      for (var i = 0; i < widths.length; i++) {
        var width = widths[i];
        var attemptedWidth = totalThisLine + width;
        if (attemptedWidth < lineBreakPoint)
          totalThisLine = attemptedWidth;
        else {
          var oldDistance = lineBreakPoint - totalThisLine;
          var newDistance = attemptedWidth - lineBreakPoint;
          if (oldDistance < newDistance && totalThisLine > 0) {
            lineBreaks.push(i - 1);
            totals.push(Math.round(totalThisLine - width));
            totalThisLine = width;
          } else {
            if (i < widths.length - 1) {
              lineBreaks.push(i);
              totals.push(Math.round(totalThisLine));
              totalThisLine = 0;
            }
          }
        }
      }
      totals.push(Math.round(totalThisLine));
      return { lineBreaks, totals };
    }
    function clone(arr) {
      var newArr = [];
      for (var i = 0; i < arr.length; i++)
        newArr.push(arr[i]);
      return newArr;
    }
    function oneTry(measureWidths, idealWidths, accumulator, lineAccumulator, lineWidths, lastVariance, highestVariance, currLine, lineBreaks, startIndex, otherTries) {
      for (var i = startIndex; i < measureWidths.length; i++) {
        var measureWidth = measureWidths[i];
        accumulator += measureWidth;
        lineAccumulator += measureWidth;
        var thisVariance = Math.abs(accumulator - idealWidths[currLine]);
        var varianceIsClose = Math.abs(thisVariance - lastVariance) < idealWidths[0] / 10;
        if (varianceIsClose) {
          if (thisVariance < lastVariance) {
            var newWidths = clone(lineWidths);
            var newBreaks = clone(lineBreaks);
            newBreaks.push(i - 1);
            newWidths.push(lineAccumulator - measureWidth);
            otherTries.push({
              accumulator,
              lineAccumulator: measureWidth,
              lineWidths: newWidths,
              lastVariance: Math.abs(accumulator - idealWidths[currLine + 1]),
              highestVariance: Math.max(highestVariance, lastVariance),
              currLine: currLine + 1,
              lineBreaks: newBreaks,
              startIndex: i + 1
            });
          } else if (thisVariance > lastVariance && i < measureWidths.length - 1) {
            newWidths = clone(lineWidths);
            newBreaks = clone(lineBreaks);
            otherTries.push({
              accumulator,
              lineAccumulator,
              lineWidths: newWidths,
              lastVariance: thisVariance,
              highestVariance: Math.max(highestVariance, thisVariance),
              currLine,
              lineBreaks: newBreaks,
              startIndex: i + 1
            });
          }
        }
        if (thisVariance > lastVariance) {
          lineBreaks.push(i - 1);
          currLine++;
          highestVariance = Math.max(highestVariance, lastVariance);
          lastVariance = Math.abs(accumulator - idealWidths[currLine]);
          lineWidths.push(lineAccumulator - measureWidth);
          lineAccumulator = measureWidth;
        } else {
          lastVariance = thisVariance;
        }
      }
      lineWidths.push(lineAccumulator);
    }
    function optimizeLineWidths(widths, lineBreakPoint, lineBreaks, explanation) {
      var numLines = Math.ceil(widths.total / lineBreakPoint);
      var idealWidth = Math.floor(widths.total / numLines);
      var idealWidths = [];
      for (var i = 0; i < numLines; i++)
        idealWidths.push(idealWidth * (i + 1));
      var otherTries = [];
      otherTries.push({
        accumulator: 0,
        lineAccumulator: 0,
        lineWidths: [],
        lastVariance: 999999,
        highestVariance: 0,
        currLine: 0,
        lineBreaks: [],
        startIndex: 0
      });
      var index = 0;
      while (index < otherTries.length) {
        oneTry(widths.measureWidths, idealWidths, otherTries[index].accumulator, otherTries[index].lineAccumulator, otherTries[index].lineWidths, otherTries[index].lastVariance, otherTries[index].highestVariance, otherTries[index].currLine, otherTries[index].lineBreaks, otherTries[index].startIndex, otherTries);
        index++;
      }
      for (i = 0; i < otherTries.length; i++) {
        var otherTry = otherTries[i];
        otherTry.variances = [];
        otherTry.aveVariance = 0;
        for (var j = 0; j < otherTry.lineWidths.length; j++) {
          var lineWidth = otherTry.lineWidths[j];
          otherTry.variances.push(lineWidth - idealWidths[0]);
          otherTry.aveVariance += Math.abs(lineWidth - idealWidths[0]);
        }
        otherTry.aveVariance = otherTry.aveVariance / otherTry.lineWidths.length;
        explanation.attempts.push({ type: "optimizeLineWidths", lineBreaks: otherTry.lineBreaks, variances: otherTry.variances, aveVariance: otherTry.aveVariance, widths: widths.measureWidths });
      }
      var smallest = 9999999;
      var smallestIndex = -1;
      for (i = 0; i < otherTries.length; i++) {
        otherTry = otherTries[i];
        if (otherTry.aveVariance < smallest) {
          smallest = otherTry.aveVariance;
          smallestIndex = i;
        }
      }
      return { failed: false, lineBreaks: otherTries[smallestIndex].lineBreaks, variance: otherTries[smallestIndex].highestVariance };
    }
    function fixedMeasureLineBreaks(widths, lineBreakPoint, preferredMeasuresPerLine) {
      var lineBreaks = [];
      var totals = [];
      var thisWidth = 0;
      var failed = false;
      for (var i = 0; i < widths.length; i++) {
        thisWidth += widths[i];
        if (thisWidth > lineBreakPoint) {
          failed = true;
        }
        if (i % preferredMeasuresPerLine === preferredMeasuresPerLine - 1) {
          if (i !== widths.length - 1)
            lineBreaks.push(i);
          totals.push(Math.round(thisWidth));
          thisWidth = 0;
        }
      }
      return { failed, totals, lineBreaks };
    }
    function getRevisedTuneParams(lineBreaks, staffWidth, params) {
      var revisedParams = {
        lineBreaks,
        staffwidth: staffWidth
      };
      for (var key in params) {
        if (params.hasOwnProperty(key) && key !== "wrap" && key !== "staffwidth") {
          revisedParams[key] = params[key];
        }
      }
      return { revisedParams };
    }
    function calcLineWraps(tune, widths, params) {
      if (widths.length === 0 || params.staffwidth < widths[0].left) {
        return {
          reParse: false,
          explanation: "Staff width is narrower than the margin",
          revisedParams: params
        };
      }
      var scale = params.scale ? Math.max(params.scale, 0.1) : 1;
      var minSpacing = params.wrap.minSpacing ? Math.max(parseFloat(params.wrap.minSpacing), 1) : 1;
      var minSpacingLimit = params.wrap.minSpacingLimit ? Math.max(parseFloat(params.wrap.minSpacingLimit), 1) : minSpacing - 0.1;
      var maxSpacing = params.wrap.maxSpacing ? Math.max(parseFloat(params.wrap.maxSpacing), 1) : void 0;
      if (params.wrap.lastLineLimit && !maxSpacing)
        maxSpacing = Math.max(parseFloat(params.wrap.lastLineLimit), 1);
      var preferredMeasuresPerLine = params.wrap.preferredMeasuresPerLine ? Math.max(parseInt(params.wrap.preferredMeasuresPerLine, 10), 0) : void 0;
      var accumulatedLineBreaks = [];
      var explanations = [];
      for (var s = 0; s < widths.length; s++) {
        var section = widths[s];
        var usableWidth = params.staffwidth - section.left;
        var lineBreakPoint = usableWidth / minSpacing / scale;
        var minLineSize = usableWidth / maxSpacing / scale;
        var allowableVariance = usableWidth / minSpacingLimit / scale;
        var explanation = {
          widths: section,
          lineBreakPoint,
          minLineSize,
          attempts: [],
          staffWidth: params.staffwidth,
          minWidth: Math.round(allowableVariance)
        };
        var lineBreaks = null;
        if (preferredMeasuresPerLine) {
          var f = fixedMeasureLineBreaks(section.measureWidths, lineBreakPoint, preferredMeasuresPerLine);
          explanation.attempts.push({
            type: "Fixed Measures Per Line",
            preferredMeasuresPerLine,
            lineBreaks: f.lineBreaks,
            failed: f.failed,
            totals: f.totals
          });
          if (!f.failed)
            lineBreaks = f.lineBreaks;
        }
        if (!lineBreaks) {
          var ff = freeFormLineBreaks(section.measureWidths, lineBreakPoint);
          explanation.attempts.push({ type: "Free Form", lineBreaks: ff.lineBreaks, totals: ff.totals });
          lineBreaks = ff.lineBreaks;
          if (lineBreaks.length > 0 && section.measureWidths.length < 25) {
            ff = optimizeLineWidths(section, lineBreakPoint, lineBreaks, explanation);
            explanation.attempts.push({
              type: "Optimize",
              failed: ff.failed,
              reason: ff.reason,
              lineBreaks: ff.lineBreaks,
              totals: ff.totals
            });
            if (!ff.failed)
              lineBreaks = ff.lineBreaks;
          }
        }
        accumulatedLineBreaks.push(lineBreaks);
        explanations.push(explanation);
      }
      var staffWidth = params.staffwidth;
      var ret = getRevisedTuneParams(accumulatedLineBreaks, staffWidth, params);
      ret.explanation = explanations;
      ret.reParse = true;
      return ret;
    }
    module.exports = { wrapLines, calcLineWraps };
  }
});

// node_modules/abcjs/src/write/abc_spacing.js
var require_abc_spacing = __commonJS({
  "node_modules/abcjs/src/write/abc_spacing.js"(exports, module) {
    var spacing = {};
    spacing.FONTEM = 360;
    spacing.FONTSIZE = 30;
    spacing.STEP = spacing.FONTSIZE * 93 / 720;
    spacing.SPACE = 10;
    spacing.TOPNOTE = 15;
    spacing.STAVEHEIGHT = 100;
    spacing.INDENT = 50;
    module.exports = spacing;
  }
});

// node_modules/abcjs/src/synth/abc_midi_sequencer.js
var require_abc_midi_sequencer = __commonJS({
  "node_modules/abcjs/src/synth/abc_midi_sequencer.js"(exports, module) {
    var sequence;
    var parseCommon = require_abc_common();
    (function() {
      "use strict";
      var measureLength;
      var PERCUSSION_PROGRAM = 128;
      sequence = function(abctune, options) {
        options = options || {};
        var qpm;
        var program = options.program || 0;
        var transpose = options.midiTranspose || 0;
        if (abctune.visualTranspose)
          transpose -= abctune.visualTranspose;
        var channel = options.channel || 0;
        var channelExplicitlySet = false;
        var drumPattern = options.drum || "";
        var drumBars = options.drumBars || 1;
        var drumIntro = options.drumIntro || 0;
        var drumOn = drumPattern !== "";
        var style = [];
        var rhythmHeadThisBar = false;
        var crescendoSize = 50;
        program = parseInt(program, 10);
        transpose = parseInt(transpose, 10);
        channel = parseInt(channel, 10);
        if (channel === 10)
          program = PERCUSSION_PROGRAM;
        drumPattern = drumPattern.split(" ");
        drumBars = parseInt(drumBars, 10);
        drumIntro = parseInt(drumIntro, 10);
        var bagpipes = abctune.formatting.bagpipes;
        if (bagpipes)
          program = 71;
        var startingMidi = [];
        if (abctune.formatting.midi) {
          var globals = abctune.formatting.midi;
          if (globals.program && globals.program.length > 0) {
            program = globals.program[0];
            if (globals.program.length > 1) {
              program = globals.program[1];
              channel = globals.program[0];
            }
            channelExplicitlySet = true;
          }
          if (globals.transpose)
            transpose = globals.transpose[0];
          if (globals.channel) {
            channel = globals.channel[0];
            channelExplicitlySet = true;
          }
          if (globals.drum)
            drumPattern = globals.drum;
          if (globals.drumbars)
            drumBars = globals.drumbars[0];
          if (globals.drumon)
            drumOn = true;
          if (channel === 10)
            program = PERCUSSION_PROGRAM;
          if (globals.beat)
            startingMidi.push({ el_type: "beat", beats: globals.beat });
          if (globals.nobeataccents)
            startingMidi.push({ el_type: "beataccents", value: false });
        }
        if (options.qpm)
          qpm = parseInt(options.qpm, 10);
        else if (abctune.metaText.tempo)
          qpm = interpretTempo(abctune.metaText.tempo, abctune.getBeatLength());
        else if (options.defaultQpm)
          qpm = options.defaultQpm;
        else
          qpm = 180;
        var startVoice = [];
        if (bagpipes)
          startVoice.push({ el_type: "bagpipes" });
        startVoice.push({ el_type: "instrument", program });
        if (channel)
          startVoice.push({ el_type: "channel", channel });
        if (transpose)
          startVoice.push({ el_type: "transpose", transpose });
        startVoice.push({ el_type: "tempo", qpm });
        for (var ss = 0; ss < startingMidi.length; ss++)
          startVoice.push(startingMidi[ss]);
        var voices = [];
        var inCrescendo = [];
        var inDiminuendo = [];
        var durationCounter = [0];
        var tempoChanges = {};
        tempoChanges["0"] = { el_type: "tempo", qpm, timing: 0 };
        var currentVolume;
        var startRepeatPlaceholder = [];
        var skipEndingPlaceholder = [];
        var startingDrumSet = false;
        var lines = abctune.lines;
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i];
          if (line.staff) {
            let setDynamics = function(elem2) {
              var volumes = {
                "pppp": [15, 10, 5, 1],
                "ppp": [30, 20, 10, 1],
                "pp": [45, 35, 20, 1],
                "p": [60, 50, 35, 1],
                "mp": [75, 65, 50, 1],
                "mf": [90, 80, 65, 1],
                "f": [105, 95, 80, 1],
                "ff": [120, 110, 95, 1],
                "fff": [127, 125, 110, 1],
                "ffff": [127, 125, 110, 1]
              };
              var dynamicType;
              if (elem2.decoration) {
                if (elem2.decoration.indexOf("pppp") >= 0)
                  dynamicType = "pppp";
                else if (elem2.decoration.indexOf("ppp") >= 0)
                  dynamicType = "ppp";
                else if (elem2.decoration.indexOf("pp") >= 0)
                  dynamicType = "pp";
                else if (elem2.decoration.indexOf("p") >= 0)
                  dynamicType = "p";
                else if (elem2.decoration.indexOf("mp") >= 0)
                  dynamicType = "mp";
                else if (elem2.decoration.indexOf("mf") >= 0)
                  dynamicType = "mf";
                else if (elem2.decoration.indexOf("f") >= 0)
                  dynamicType = "f";
                else if (elem2.decoration.indexOf("ff") >= 0)
                  dynamicType = "ff";
                else if (elem2.decoration.indexOf("fff") >= 0)
                  dynamicType = "fff";
                else if (elem2.decoration.indexOf("ffff") >= 0)
                  dynamicType = "ffff";
                if (dynamicType) {
                  currentVolume = volumes[dynamicType].slice(0);
                  voices[voiceNumber].push({ el_type: "beat", beats: currentVolume.slice(0) });
                  inCrescendo[k] = false;
                  inDiminuendo[k] = false;
                }
                if (elem2.decoration.indexOf("crescendo(") >= 0) {
                  var n = numNotesToDecoration(voice, v, "crescendo)");
                  var top = Math.min(127, currentVolume[0] + crescendoSize);
                  var endDec = endingVolume(voice, v + n + 1, Object.keys(volumes));
                  if (endDec)
                    top = volumes[endDec][0];
                  if (n > 0)
                    inCrescendo[k] = Math.floor((top - currentVolume[0]) / n);
                  else
                    inCrescendo[k] = false;
                  inDiminuendo[k] = false;
                } else if (elem2.decoration.indexOf("crescendo)") >= 0) {
                  inCrescendo[k] = false;
                } else if (elem2.decoration.indexOf("diminuendo(") >= 0) {
                  var n2 = numNotesToDecoration(voice, v, "diminuendo)");
                  var bottom = Math.max(15, currentVolume[0] - crescendoSize);
                  var endDec2 = endingVolume(voice, v + n2 + 1, Object.keys(volumes));
                  if (endDec2)
                    bottom = volumes[endDec2][0];
                  inCrescendo[k] = false;
                  if (n2 > 0)
                    inDiminuendo[k] = Math.floor((bottom - currentVolume[0]) / n2);
                  else
                    inDiminuendo[k] = false;
                } else if (elem2.decoration.indexOf("diminuendo)") >= 0) {
                  inDiminuendo[k] = false;
                }
              }
            };
            var staves = line.staff;
            var voiceNumber = 0;
            for (var j = 0; j < staves.length; j++) {
              var staff = staves[j];
              if (staff.clef && staff.clef.type === "TAB")
                continue;
              for (var k = 0; k < staff.voices.length; k++) {
                var voice = staff.voices[k];
                if (!voices[voiceNumber]) {
                  voices[voiceNumber] = [].concat(JSON.parse(JSON.stringify(startVoice)));
                  var voiceName = getTrackTitle(line.staff, voiceNumber);
                  if (voiceName)
                    voices[voiceNumber].unshift({ el_type: "name", trackName: voiceName });
                }
                if (transpose && staff.clef.type === "perc")
                  voices[voiceNumber].push({ el_type: "transpose", transpose: 0 });
                if (staff.clef && staff.clef.type === "perc" && !channelExplicitlySet) {
                  for (var cl = 0; cl < voices[voiceNumber].length; cl++) {
                    if (voices[voiceNumber][cl].el_type === "instrument")
                      voices[voiceNumber][cl].program = PERCUSSION_PROGRAM;
                  }
                } else if (staff.key) {
                  addKey(voices[voiceNumber], staff.key);
                }
                if (staff.meter) {
                  addMeter(voices[voiceNumber], staff.meter);
                }
                if (!startingDrumSet && drumOn) {
                  voices[voiceNumber].push({ el_type: "drum", params: { pattern: drumPattern, bars: drumBars, on: drumOn, intro: drumIntro } });
                  startingDrumSet = true;
                }
                if (staff.clef && staff.clef.type !== "perc" && staff.clef.transpose) {
                  staff.clef.el_type = "clef";
                  voices[voiceNumber].push({ el_type: "transpose", transpose: staff.clef.transpose });
                }
                if (staff.clef && staff.clef.type) {
                  if (staff.clef.type.indexOf("-8") >= 0)
                    voices[voiceNumber].push({ el_type: "transpose", transpose: -12 });
                  else if (staff.clef.type.indexOf("+8") >= 0)
                    voices[voiceNumber].push({ el_type: "transpose", transpose: 12 });
                }
                if (abctune.formatting.midi && abctune.formatting.midi.drumoff) {
                  voices[voiceNumber].push({ el_type: "bar" });
                  voices[voiceNumber].push({ el_type: "drum", params: { pattern: "", on: false } });
                }
                var noteEventsInBar = 0;
                var tripletMultiplier = 0;
                var tripletDurationTotal = 0;
                var tripletDurationCount = 0;
                currentVolume = [105, 95, 85, 1];
                for (var v = 0; v < voice.length; v++) {
                  var elem = voice[v];
                  switch (elem.el_type) {
                    case "note":
                      if (inCrescendo[k]) {
                        currentVolume[0] += inCrescendo[k];
                        currentVolume[1] += inCrescendo[k];
                        currentVolume[2] += inCrescendo[k];
                        voices[voiceNumber].push({ el_type: "beat", beats: currentVolume.slice(0) });
                      }
                      if (inDiminuendo[k]) {
                        currentVolume[0] += inDiminuendo[k];
                        currentVolume[1] += inDiminuendo[k];
                        currentVolume[2] += inDiminuendo[k];
                        voices[voiceNumber].push({ el_type: "beat", beats: currentVolume.slice(0) });
                      }
                      setDynamics(elem);
                      if (!elem.rest || elem.rest.type !== "spacer") {
                        var noteElem = { elem, el_type: "note", timing: durationCounter[voiceNumber] };
                        if (elem.style)
                          noteElem.style = elem.style;
                        else if (style[voiceNumber])
                          noteElem.style = style[voiceNumber];
                        noteElem.duration = elem.duration === 0 ? 0.25 : elem.duration;
                        if (elem.startTriplet) {
                          tripletMultiplier = elem.tripletMultiplier;
                          tripletDurationTotal = elem.startTriplet * tripletMultiplier * elem.duration;
                          if (elem.startTriplet !== elem.tripletR) {
                            if (v + elem.tripletR <= voice.length) {
                              var durationTotal = 0;
                              for (var w = v; w < v + elem.tripletR; w++) {
                                durationTotal += voice[w].duration;
                              }
                              tripletDurationTotal = tripletMultiplier * durationTotal;
                            }
                          }
                          noteElem.duration = noteElem.duration * tripletMultiplier;
                          noteElem.duration = Math.round(noteElem.duration * 1e6) / 1e6;
                          tripletDurationCount = noteElem.duration;
                        } else if (tripletMultiplier) {
                          if (elem.endTriplet) {
                            tripletMultiplier = 0;
                            noteElem.duration = Math.round((tripletDurationTotal - tripletDurationCount) * 1e6) / 1e6;
                          } else {
                            noteElem.duration = noteElem.duration * tripletMultiplier;
                            noteElem.duration = Math.round(noteElem.duration * 1e6) / 1e6;
                            tripletDurationCount += noteElem.duration;
                          }
                        }
                        if (elem.rest)
                          noteElem.rest = elem.rest;
                        if (elem.decoration)
                          noteElem.decoration = elem.decoration.slice(0);
                        if (elem.pitches)
                          noteElem.pitches = parseCommon.cloneArray(elem.pitches);
                        if (elem.gracenotes)
                          noteElem.gracenotes = parseCommon.cloneArray(elem.gracenotes);
                        if (elem.chord)
                          noteElem.chord = parseCommon.cloneArray(elem.chord);
                        voices[voiceNumber].push(noteElem);
                        if (elem.style === "rhythm") {
                          rhythmHeadThisBar = true;
                          chordVoiceOffThisBar(voices);
                        }
                        noteEventsInBar++;
                        durationCounter[voiceNumber] += noteElem.duration;
                      }
                      break;
                    case "key":
                    case "keySignature":
                      addKey(voices[voiceNumber], elem);
                      break;
                    case "meter":
                      addMeter(voices[voiceNumber], elem);
                      break;
                    case "clef":
                      if (elem.transpose)
                        voices[voiceNumber].push({ el_type: "transpose", transpose: elem.transpose });
                      if (elem.type) {
                        if (elem.type.indexOf("-8") >= 0)
                          voices[voiceNumber].push({ el_type: "transpose", transpose: -12 });
                        else if (elem.type.indexOf("+8") >= 0)
                          voices[voiceNumber].push({ el_type: "transpose", transpose: 12 });
                      }
                      break;
                    case "tempo":
                      qpm = interpretTempo(elem, abctune.getBeatLength());
                      voices[voiceNumber].push({ el_type: "tempo", qpm, timing: durationCounter[voiceNumber] });
                      tempoChanges["" + durationCounter[voiceNumber]] = { el_type: "tempo", qpm, timing: durationCounter[voiceNumber] };
                      break;
                    case "bar":
                      if (noteEventsInBar > 0)
                        voices[voiceNumber].push({ el_type: "bar" });
                      setDynamics(elem);
                      noteEventsInBar = 0;
                      var endRepeat = elem.type === "bar_right_repeat" || elem.type === "bar_dbl_repeat";
                      var startEnding = elem.startEnding === "1";
                      var startRepeat = elem.type === "bar_left_repeat" || elem.type === "bar_dbl_repeat" || elem.type === "bar_right_repeat";
                      if (endRepeat) {
                        var s = startRepeatPlaceholder[voiceNumber];
                        if (!s)
                          s = 0;
                        var e = skipEndingPlaceholder[voiceNumber];
                        if (!e)
                          e = voices[voiceNumber].length;
                        for (var z = s; z < e; z++) {
                          var item = parseCommon.clone(voices[voiceNumber][z]);
                          if (item.pitches)
                            item.pitches = parseCommon.cloneArray(item.pitches);
                          voices[voiceNumber].push(item);
                        }
                        skipEndingPlaceholder[voiceNumber] = void 0;
                        startRepeatPlaceholder[voiceNumber] = void 0;
                      }
                      if (startEnding)
                        skipEndingPlaceholder[voiceNumber] = voices[voiceNumber].length;
                      if (startRepeat)
                        startRepeatPlaceholder[voiceNumber] = voices[voiceNumber].length;
                      rhythmHeadThisBar = false;
                      break;
                    case "style":
                      style[voiceNumber] = elem.head;
                      break;
                    case "timeSignature":
                      voices[voiceNumber].push(interpretMeter(elem));
                      break;
                    case "part":
                      break;
                    case "stem":
                    case "scale":
                    case "break":
                    case "font":
                      break;
                    case "midi":
                      var drumChange = false;
                      switch (elem.cmd) {
                        case "drumon":
                          drumOn = true;
                          drumChange = true;
                          break;
                        case "drumoff":
                          drumOn = false;
                          drumChange = true;
                          break;
                        case "drum":
                          drumPattern = elem.params;
                          drumChange = true;
                          break;
                        case "drumbars":
                          drumBars = elem.params[0];
                          drumChange = true;
                          break;
                        case "drummap":
                          break;
                        case "channel":
                          if (elem.params[0] === 10)
                            voices[voiceNumber].push({ el_type: "instrument", program: PERCUSSION_PROGRAM });
                          break;
                        case "program":
                          addIfDifferent(voices[voiceNumber], { el_type: "instrument", program: elem.params[0] });
                          channelExplicitlySet = true;
                          break;
                        case "transpose":
                          voices[voiceNumber].push({ el_type: "transpose", transpose: elem.params[0] });
                          break;
                        case "gchordoff":
                          voices[voiceNumber].push({ el_type: "gchord", tacet: true });
                          break;
                        case "gchordon":
                          voices[voiceNumber].push({ el_type: "gchord", tacet: false });
                          break;
                        case "beat":
                          voices[voiceNumber].push({ el_type: "beat", beats: elem.params });
                          break;
                        case "nobeataccents":
                          voices[voiceNumber].push({ el_type: "beataccents", value: false });
                          break;
                        case "beataccents":
                          voices[voiceNumber].push({ el_type: "beataccents", value: true });
                          break;
                        case "vol":
                          voices[voiceNumber].push({ el_type: "vol", volume: elem.params[0] });
                          break;
                        case "volinc":
                          voices[voiceNumber].push({ el_type: "volinc", volume: elem.params[0] });
                          break;
                        default:
                          console.log("MIDI seq: midi cmd not handled: ", elem.cmd, elem);
                      }
                      if (drumChange) {
                        voices[0].push({ el_type: "drum", params: { pattern: drumPattern, bars: drumBars, intro: drumIntro, on: drumOn } });
                        startingDrumSet = true;
                      }
                      break;
                    default:
                      console.log("MIDI: element type " + elem.el_type + " not handled.");
                  }
                }
                voiceNumber++;
                if (!durationCounter[voiceNumber])
                  durationCounter[voiceNumber] = 0;
              }
            }
          }
        }
        insertTempoChanges(voices, tempoChanges);
        if (drumIntro) {
          var pickups = abctune.getPickupLength();
          for (var vv = 0; vv < voices.length; vv++) {
            var insertPoint = 0;
            while (voices[vv][insertPoint].el_type !== "note" && voices[vv].length > insertPoint)
              insertPoint++;
            if (voices[vv].length > insertPoint) {
              for (var w = 0; w < drumIntro; w++) {
                if (pickups === 0 || w < drumIntro - 1)
                  voices[vv].splice(insertPoint, 0, { el_type: "note", rest: { type: "rest" }, duration: measureLength }, { el_type: "bar" });
                else {
                  voices[vv].splice(insertPoint, 0, { el_type: "note", rest: { type: "rest" }, duration: measureLength - pickups });
                }
              }
            }
          }
        }
        if (voices.length > 0 && voices[0].length > 0) {
          voices[0][0].pickupLength = abctune.getPickupLength();
        }
        return voices;
      };
      function numNotesToDecoration(voice, start, decoration) {
        var counter = 0;
        for (var i = start + 1; i < voice.length; i++) {
          if (voice[i].el_type === "note")
            counter++;
          if (voice[i].decoration && voice[i].decoration.indexOf(decoration) >= 0)
            return counter;
        }
        return counter;
      }
      function endingVolume(voice, start, volumeDecorations) {
        var end = Math.min(voice.length, start + 3);
        for (var i = start; i < end; i++) {
          if (voice[i].el_type === "note") {
            if (voice[i].decoration) {
              for (var j = 0; j < voice[i].decoration.length; j++) {
                if (volumeDecorations.indexOf(voice[i].decoration[j]) >= 0)
                  return voice[i].decoration[j];
              }
            }
          }
        }
        return null;
      }
      function insertTempoChanges(voices, tempoChanges) {
        if (!tempoChanges || tempoChanges.length === 0)
          return;
        var changePositions = Object.keys(tempoChanges);
        for (var i = 0; i < voices.length; i++) {
          var voice = voices[i];
          var lastTempo = tempoChanges["0"] ? tempoChanges["0"].qpm : 0;
          for (var j = 0; j < voice.length; j++) {
            var el = voice[j];
            if (el.el_type === "tempo")
              lastTempo = el.qpm;
            if (changePositions.indexOf("" + el.timing) >= 0 && lastTempo !== tempoChanges["" + el.timing].qpm) {
              lastTempo = tempoChanges["" + el.timing].qpm;
              if (el.el_type === "tempo") {
                el.qpm = tempoChanges["" + el.timing].qpm;
                j++;
              } else {
                voices[i].splice(j, 0, { el_type: "tempo", qpm: tempoChanges["" + el.timing].qpm, timing: el.timing });
                j += 2;
              }
            }
          }
        }
      }
      function chordVoiceOffThisBar(voices) {
        for (var i = 0; i < voices.length; i++) {
          var voice = voices[i];
          var j = voice.length - 1;
          while (j >= 0 && voice[j].el_type !== "bar") {
            voice[j].noChordVoice = true;
            j--;
          }
        }
      }
      function getTrackTitle(staff, voiceNumber) {
        if (!staff || staff.length <= voiceNumber || !staff[voiceNumber].title)
          return void 0;
        return staff[voiceNumber].title.join(" ");
      }
      function interpretTempo(element, beatLength) {
        var duration = 1 / 4;
        if (element.duration) {
          duration = element.duration[0];
        }
        var bpm = 60;
        if (element.bpm) {
          bpm = element.bpm;
        }
        return duration * bpm / beatLength;
      }
      function interpretMeter(element) {
        var meter;
        switch (element.type) {
          case "common_time":
            meter = { el_type: "meter", num: 4, den: 4 };
            break;
          case "cut_time":
            meter = { el_type: "meter", num: 2, den: 2 };
            break;
          case "specified":
            meter = { el_type: "meter", num: element.value[0].num, den: element.value[0].den };
            break;
          default:
            meter = { el_type: "meter" };
        }
        measureLength = meter.num / meter.den;
        return meter;
      }
      function removeNaturals(accidentals) {
        var acc = [];
        for (var i = 0; i < accidentals.length; i++) {
          if (accidentals[i].acc !== "natural")
            acc.push(accidentals[i]);
        }
        return acc;
      }
      function addKey(arr, key) {
        var newKey;
        if (key.root === "HP")
          newKey = { el_type: "key", accidentals: [{ acc: "natural", note: "g" }, { acc: "sharp", note: "f" }, { acc: "sharp", note: "c" }] };
        else
          newKey = { el_type: "key", accidentals: removeNaturals(key.accidentals) };
        addIfDifferent(arr, newKey);
      }
      function addMeter(arr, meter) {
        var newMeter = interpretMeter(meter);
        addIfDifferent(arr, newMeter);
      }
      function addIfDifferent(arr, item) {
        for (var i = arr.length - 1; i >= 0; i--) {
          if (arr[i].el_type === item.el_type) {
            if (JSON.stringify(arr[i]) !== JSON.stringify(item))
              arr.push(item);
            return;
          }
        }
        arr.push(item);
      }
    })();
    module.exports = sequence;
  }
});

// node_modules/abcjs/src/synth/pitches-to-perc.js
var require_pitches_to_perc = __commonJS({
  "node_modules/abcjs/src/synth/pitches-to-perc.js"(exports, module) {
    var pitchMap = {
      f0: "_C",
      n0: "=C",
      s0: "^C",
      x0: "C",
      f1: "_D",
      n1: "=D",
      s1: "^D",
      x1: "D",
      f2: "_E",
      n2: "=E",
      s2: "^E",
      x2: "E",
      f3: "_F",
      n3: "=F",
      s3: "^F",
      x3: "F",
      f4: "_G",
      n4: "=G",
      s4: "^G",
      x4: "G",
      f5: "_A",
      n5: "=A",
      s5: "^A",
      x5: "A",
      f6: "_B",
      n6: "=B",
      s6: "^B",
      x6: "B",
      f7: "_c",
      n7: "=c",
      s7: "^c",
      x7: "c",
      f8: "_d",
      n8: "=d",
      s8: "^d",
      x8: "d",
      f9: "_e",
      n9: "=e",
      s9: "^e",
      x9: "e",
      f10: "_f",
      n10: "=f",
      s10: "^f",
      x10: "f",
      f11: "_g",
      n11: "=g",
      s11: "^g",
      x11: "g",
      f12: "_a",
      n12: "=a",
      s12: "^a",
      x12: "a",
      f13: "_b",
      n13: "=b",
      s13: "^b",
      x13: "b"
    };
    function pitchesToPerc(pitchObj) {
      var pitch = (pitchObj.accidental ? pitchObj.accidental[0] : "x") + pitchObj.verticalPos;
      return pitchMap[pitch];
    }
    module.exports = pitchesToPerc;
  }
});

// node_modules/abcjs/src/synth/abc_midi_flattener.js
var require_abc_midi_flattener = __commonJS({
  "node_modules/abcjs/src/synth/abc_midi_flattener.js"(exports, module) {
    var flatten;
    var parseCommon = require_abc_common();
    var pitchesToPerc = require_pitches_to_perc();
    (function() {
      "use strict";
      var barAccidentals;
      var accidentals;
      var transpose;
      var bagpipes;
      var tracks;
      var startingTempo;
      var startingMeter;
      var tempoChangeFactor = 1;
      var instrument;
      var currentInstrument;
      var currentTrack;
      var lastNoteDurationPosition;
      var currentTrackName;
      var lastEventTime;
      var meter = { num: 4, den: 4 };
      var chordTrack;
      var chordSourceTrack;
      var chordTrackFinished;
      var chordChannel;
      var chordInstrument = 0;
      var drumInstrument = 128;
      var boomVolume = 64;
      var chickVolume = 48;
      var currentChords;
      var lastChord;
      var chordLastBar;
      var lastBarTime;
      var gChordTacet = false;
      var hasRhythmHead = false;
      var doBeatAccents = true;
      var stressBeat1 = 105;
      var stressBeatDown = 95;
      var stressBeatUp = 85;
      var beatFraction = 0.25;
      var nextVolume;
      var nextVolumeDelta;
      var slurCount = 0;
      var drumTrack;
      var drumTrackFinished;
      var drumDefinition = {};
      var pickupLength = 0;
      var percmap;
      var normalBreakBetweenNotes = 0;
      var slurredBreakBetweenNotes = -1e-3;
      var staccatoBreakBetweenNotes = 0.4;
      flatten = function(voices, options, percmap_) {
        if (!options)
          options = {};
        barAccidentals = [];
        accidentals = [0, 0, 0, 0, 0, 0, 0];
        bagpipes = false;
        tracks = [];
        startingTempo = options.qpm;
        startingMeter = void 0;
        tempoChangeFactor = 1;
        instrument = void 0;
        currentInstrument = void 0;
        currentTrack = void 0;
        currentTrackName = void 0;
        lastEventTime = 0;
        percmap = percmap_;
        meter = { num: 4, den: 4 };
        chordTrack = [];
        chordSourceTrack = false;
        chordChannel = voices.length;
        chordTrackFinished = false;
        currentChords = [];
        boomVolume = 64;
        chickVolume = 48;
        lastChord = void 0;
        chordLastBar = void 0;
        gChordTacet = options.chordsOff ? true : false;
        hasRhythmHead = false;
        doBeatAccents = true;
        stressBeat1 = 105;
        stressBeatDown = 95;
        stressBeatUp = 85;
        beatFraction = 0.25;
        nextVolume = void 0;
        nextVolumeDelta = void 0;
        slurCount = 0;
        drumTrack = [];
        drumTrackFinished = false;
        drumDefinition = {};
        if (voices.length > 0 && voices[0].length > 0)
          pickupLength = voices[0][0].pickupLength;
        preProcess(voices, options);
        for (var i = 0; i < voices.length; i++) {
          transpose = 0;
          lastNoteDurationPosition = -1;
          var voice = voices[i];
          currentTrack = [{ cmd: "program", channel: i, instrument }];
          currentTrackName = void 0;
          lastBarTime = 0;
          var voiceOff = false;
          if (options.voicesOff === true)
            voiceOff = true;
          else if (options.voicesOff && options.voicesOff.length && options.voicesOff.indexOf(i) >= 0)
            voiceOff = true;
          for (var j = 0; j < voice.length; j++) {
            var element = voice[j];
            switch (element.el_type) {
              case "name":
                currentTrackName = { cmd: "text", type: "name", text: element.trackName };
                break;
              case "note":
                var setChordTrack = writeNote(element, voiceOff);
                if (setChordTrack)
                  chordSourceTrack = i;
                break;
              case "key":
                accidentals = setKeySignature(element);
                break;
              case "meter":
                if (!startingMeter)
                  startingMeter = element;
                meter = element;
                beatFraction = getBeatFraction(meter);
                break;
              case "tempo":
                if (!startingTempo)
                  startingTempo = element.qpm;
                else
                  tempoChangeFactor = element.qpm ? startingTempo / element.qpm : 1;
                break;
              case "transpose":
                transpose = element.transpose;
                break;
              case "bar":
                if (chordTrack.length > 0 && (chordSourceTrack === false || i === chordSourceTrack)) {
                  resolveChords(lastBarTime, timeToRealTime(element.time));
                  currentChords = [];
                }
                barAccidentals = [];
                if (i === 0)
                  writeDrum(voices.length + 1);
                hasRhythmHead = false;
                chordLastBar = lastChord;
                lastBarTime = timeToRealTime(element.time);
                break;
              case "bagpipes":
                bagpipes = true;
                break;
              case "instrument":
                if (instrument === void 0)
                  instrument = element.program;
                currentInstrument = element.program;
                if (currentTrack.length > 0 && currentTrack[currentTrack.length - 1].cmd === "program")
                  currentTrack[currentTrack.length - 1].instrument = element.program;
                else {
                  var ii;
                  for (ii = currentTrack.length - 1; ii >= 0 && currentTrack[ii].cmd !== "program"; ii--)
                    ;
                  if (ii < 0 || currentTrack[ii].instrument !== element.program)
                    currentTrack.push({ cmd: "program", channel: 0, instrument: element.program });
                }
                break;
              case "channel":
                setChannel(element.channel);
                break;
              case "drum":
                drumDefinition = normalizeDrumDefinition(element.params);
                break;
              case "gchord":
                if (!options.chordsOff)
                  gChordTacet = element.tacet;
                break;
              case "beat":
                stressBeat1 = element.beats[0];
                stressBeatDown = element.beats[1];
                stressBeatUp = element.beats[2];
                break;
              case "vol":
                nextVolume = element.volume;
                break;
              case "volinc":
                nextVolumeDelta = element.volume;
                break;
              case "beataccents":
                doBeatAccents = element.value;
                break;
              default:
                console.log("MIDI creation. Unknown el_type: " + element.el_type + "\n");
                break;
            }
          }
          if (currentTrack[0].instrument === void 0)
            currentTrack[0].instrument = instrument ? instrument : 0;
          if (currentTrackName)
            currentTrack.unshift(currentTrackName);
          tracks.push(currentTrack);
          if (!chordTrackEmpty())
            chordTrackFinished = true;
          if (drumTrack.length > 0)
            drumTrackFinished = true;
        }
        if (options.detuneOctave)
          findOctaves(tracks, parseInt(options.detuneOctave, 10));
        if (!chordTrackEmpty())
          tracks.push(chordTrack);
        if (drumTrack.length > 0)
          tracks.push(drumTrack);
        return { tempo: startingTempo, instrument, tracks, totalDuration: lastEventTime };
      };
      function setChannel(channel) {
        for (var i = currentTrack.length - 1; i >= 0; i--) {
          if (currentTrack[i].cmd === "program") {
            currentTrack[i].channel = channel;
            return;
          }
        }
      }
      function chordTrackEmpty() {
        var isEmpty = true;
        for (var i = 0; i < chordTrack.length && isEmpty; i++) {
          if (chordTrack[i].cmd === "note")
            isEmpty = false;
        }
        return isEmpty;
      }
      function timeToRealTime(time) {
        return time / 1e6;
      }
      function durationRounded(duration) {
        return Math.round(duration * tempoChangeFactor * 1e6) / 1e6;
      }
      function preProcess(voices, options) {
        for (var i = 0; i < voices.length; i++) {
          var voice = voices[i];
          var ties = {};
          var startingTempo2 = options.qpm;
          var timeCounter = 0;
          var tempoMultiplier = 1;
          for (var j = 0; j < voice.length; j++) {
            var element = voice[j];
            if (element.el_type === "tempo") {
              if (!startingTempo2)
                startingTempo2 = element.qpm;
              else
                tempoMultiplier = element.qpm ? startingTempo2 / element.qpm : 1;
              continue;
            }
            element.time = timeCounter;
            var thisDuration = element.duration ? element.duration : 0;
            timeCounter += Math.round(thisDuration * tempoMultiplier * 1e6);
            if (element.pitches) {
              for (var k = 0; k < element.pitches.length; k++) {
                var pitch = element.pitches[k];
                if (pitch) {
                  pitch.duration = element.duration;
                  if (pitch.startTie) {
                    if (ties[pitch.pitch] === void 0)
                      ties[pitch.pitch] = { el: j, pitch: k };
                    else {
                      voice[ties[pitch.pitch].el].pitches[ties[pitch.pitch].pitch].duration += pitch.duration;
                      element.pitches[k] = null;
                    }
                  } else if (pitch.endTie) {
                    var tie = ties[pitch.pitch];
                    if (tie) {
                      var dur = pitch.duration;
                      delete voice[tie.el].pitches[tie.pitch].startTie;
                      voice[tie.el].pitches[tie.pitch].duration += dur;
                      element.pitches[k] = null;
                      delete ties[pitch.pitch];
                    } else {
                      delete pitch.endTie;
                    }
                  }
                }
              }
              delete element.duration;
            }
          }
          for (var key in ties) {
            if (ties.hasOwnProperty(key)) {
              var item = ties[key];
              delete voice[item.el].pitches[item.pitch].startTie;
            }
          }
        }
      }
      function getBeatFraction(meter2) {
        switch (parseInt(meter2.den, 10)) {
          case 2:
            return 0.5;
          case 4:
            return 0.25;
          case 8:
            if (meter2.num % 3 === 0)
              return 0.375;
            else
              return 0.125;
          case 16:
            return 0.125;
        }
        return 0.25;
      }
      var breakSynonyms = ["break", "(break)", "no chord", "n.c.", "tacet"];
      function findChord(elem) {
        if (gChordTacet)
          return "break";
        if (chordTrackFinished || !elem.chord || elem.chord.length === 0)
          return null;
        for (var i = 0; i < elem.chord.length; i++) {
          var ch = elem.chord[i];
          if (ch.position === "default")
            return ch.name;
          if (breakSynonyms.indexOf(ch.name.toLowerCase()) >= 0)
            return "break";
        }
        return null;
      }
      function calcBeat(measureStart, beatLength, currTime) {
        var distanceFromStart = currTime - measureStart;
        return distanceFromStart / beatLength;
      }
      function processVolume(beat, voiceOff) {
        if (voiceOff)
          return 0;
        var volume;
        if (nextVolume) {
          volume = nextVolume;
          nextVolume = void 0;
        } else if (!doBeatAccents) {
          volume = stressBeatDown;
        } else if (pickupLength > beat) {
          volume = stressBeatUp;
        } else {
          var barLength = meter.num / meter.den;
          var barBeat = calcBeat(lastBarTime, getBeatFraction(meter), beat);
          if (barBeat === 0)
            volume = stressBeat1;
          else if (parseInt(barBeat, 10) === barBeat)
            volume = stressBeatDown;
          else
            volume = stressBeatUp;
        }
        if (nextVolumeDelta) {
          volume += nextVolumeDelta;
          nextVolumeDelta = void 0;
        }
        if (volume < 0)
          volume = 0;
        if (volume > 127)
          volume = 127;
        return voiceOff ? 0 : volume;
      }
      function processChord(elem) {
        var firstChord = false;
        var chord = findChord(elem);
        if (chord) {
          var c = interpretChord(chord);
          if (c) {
            if (chordTrack.length === 0) {
              firstChord = true;
              chordTrack.push({ cmd: "program", channel: chordChannel, instrument: chordInstrument });
            }
            lastChord = c;
            var barBeat = calcBeat(lastBarTime, getBeatFraction(meter), timeToRealTime(elem.time));
            currentChords.push({ chord: lastChord, beat: barBeat, start: timeToRealTime(elem.time) });
          }
        }
        return firstChord;
      }
      function findNoteModifications(elem, velocity) {
        var ret = {};
        if (elem.decoration) {
          for (var d = 0; d < elem.decoration.length; d++) {
            if (elem.decoration[d] === "staccato")
              ret.thisBreakBetweenNotes = "staccato";
            else if (elem.decoration[d] === "tenuto")
              ret.thisBreakBetweenNotes = "tenuto";
            else if (elem.decoration[d] === "accent")
              ret.velocity = Math.min(127, velocity * 1.5);
            else if (elem.decoration[d] === "trill")
              ret.noteModification = "trill";
            else if (elem.decoration[d] === "lowermordent")
              ret.noteModification = "lowermordent";
            else if (elem.decoration[d] === "uppermordent")
              ret.noteModification = "mordent";
            else if (elem.decoration[d] === "mordent")
              ret.noteModification = "mordent";
            else if (elem.decoration[d] === "turn")
              ret.noteModification = "turn";
            else if (elem.decoration[d] === "roll")
              ret.noteModification = "roll";
          }
        }
        return ret;
      }
      function doModifiedNotes(noteModification, p) {
        var noteTime;
        var numNotes;
        var start = p.start;
        var pp;
        var runningDuration = p.duration;
        var shortestNote = durationRounded(1 / 32);
        switch (noteModification) {
          case "trill":
            var note = 1;
            while (runningDuration > 0) {
              currentTrack.push({ cmd: "note", pitch: p.pitch + note, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
              note = note === 1 ? 0 : 1;
              runningDuration -= shortestNote;
              start += shortestNote;
            }
            break;
          case "mordent":
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            runningDuration -= shortestNote;
            start += shortestNote;
            currentTrack.push({ cmd: "note", pitch: p.pitch + 1, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            runningDuration -= shortestNote;
            start += shortestNote;
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start, duration: runningDuration, gap: 0, instrument: currentInstrument });
            break;
          case "lowermordent":
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            runningDuration -= shortestNote;
            start += shortestNote;
            currentTrack.push({ cmd: "note", pitch: p.pitch - 1, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            runningDuration -= shortestNote;
            start += shortestNote;
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start, duration: runningDuration, gap: 0, instrument: currentInstrument });
            break;
          case "turn":
            shortestNote = p.duration / 5;
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            currentTrack.push({ cmd: "note", pitch: p.pitch + 1, volume: p.volume, start: start + shortestNote, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start: start + shortestNote * 2, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            currentTrack.push({ cmd: "note", pitch: p.pitch + 1, volume: p.volume, start: start + shortestNote * 3, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start: start + shortestNote * 4, duration: shortestNote, gap: 0, instrument: currentInstrument });
            break;
          case "roll":
            while (runningDuration > 0) {
              currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
              runningDuration -= shortestNote * 2;
              start += shortestNote * 2;
            }
            break;
        }
      }
      function writeNote(elem, voiceOff) {
        var trackStartingIndex = currentTrack.length;
        var velocity = processVolume(timeToRealTime(elem.time), voiceOff);
        var setChordTrack = processChord(elem);
        var graces;
        if (elem.gracenotes && elem.pitches && elem.pitches.length > 0 && elem.pitches[0]) {
          graces = processGraceNotes(elem.gracenotes, elem.pitches[0].duration);
          if (elem.elem)
            elem.elem.midiGraceNotePitches = writeGraceNotes(graces, timeToRealTime(elem.time), velocity * 2 / 3, currentInstrument);
        }
        if (elem.elem) {
          var rt = timeToRealTime(elem.time);
          var ms = rt / beatFraction / startingTempo * 60 * 1e3;
          if (elem.elem.currentTrackMilliseconds === void 0) {
            elem.elem.currentTrackMilliseconds = ms;
            elem.elem.currentTrackWholeNotes = rt;
          } else {
            if (elem.elem.currentTrackMilliseconds.length === void 0) {
              if (elem.elem.currentTrackMilliseconds !== ms) {
                elem.elem.currentTrackMilliseconds = [elem.elem.currentTrackMilliseconds, ms];
                elem.elem.currentTrackWholeNotes = [elem.elem.currentTrackWholeNotes, rt];
              }
            } else {
              var found = false;
              for (var j = 0; j < elem.elem.currentTrackMilliseconds.length; j++) {
                if (elem.elem.currentTrackMilliseconds[j] === ms)
                  found = true;
              }
              if (!found) {
                elem.elem.currentTrackMilliseconds.push(ms);
                elem.elem.currentTrackWholeNotes.push(rt);
              }
            }
          }
        }
        if (elem.pitches) {
          var thisBreakBetweenNotes = "";
          var ret = findNoteModifications(elem, velocity);
          if (ret.thisBreakBetweenNotes)
            thisBreakBetweenNotes = ret.thisBreakBetweenNotes;
          if (ret.velocity)
            velocity = ret.velocity;
          var ePitches = elem.pitches;
          if (elem.style === "rhythm") {
            hasRhythmHead = true;
            if (lastChord && lastChord.chick) {
              ePitches = [];
              for (var i2 = 0; i2 < lastChord.chick.length; i2++) {
                var note2 = parseCommon.clone(elem.pitches[0]);
                note2.actualPitch = lastChord.chick[i2];
                ePitches.push(note2);
              }
            }
          }
          if (elem.elem)
            elem.elem.midiPitches = [];
          for (var i = 0; i < ePitches.length; i++) {
            var note = ePitches[i];
            if (!note)
              continue;
            if (note.startSlur)
              slurCount += note.startSlur.length;
            if (note.endSlur)
              slurCount -= note.endSlur.length;
            var actualPitch = note.actualPitch ? note.actualPitch : adjustPitch(note);
            if (currentInstrument === drumInstrument && percmap) {
              var name = pitchesToPerc(note);
              if (name && percmap[name])
                actualPitch = percmap[name].sound;
            }
            var p = { cmd: "note", pitch: actualPitch, volume: velocity, start: timeToRealTime(elem.time), duration: durationRounded(note.duration), instrument: currentInstrument };
            p = adjustForMicroTone(p);
            if (elem.gracenotes) {
              p.duration = p.duration / 2;
              p.start = p.start + p.duration;
            }
            if (elem.elem)
              elem.elem.midiPitches.push(p);
            if (ret.noteModification) {
              doModifiedNotes(ret.noteModification, p);
            } else {
              if (slurCount > 0)
                p.endType = "tenuto";
              else if (thisBreakBetweenNotes)
                p.endType = thisBreakBetweenNotes;
              switch (p.endType) {
                case "tenuto":
                  p.gap = slurredBreakBetweenNotes;
                  break;
                case "staccato":
                  var d = p.duration * staccatoBreakBetweenNotes;
                  p.gap = startingTempo / 60 * d;
                  break;
                default:
                  p.gap = normalBreakBetweenNotes;
                  break;
              }
              currentTrack.push(p);
            }
          }
          lastNoteDurationPosition = currentTrack.length - 1;
        }
        var realDur = getRealDuration(elem);
        lastEventTime = Math.max(lastEventTime, timeToRealTime(elem.time) + durationRounded(realDur));
        return setChordTrack;
      }
      function getRealDuration(elem) {
        if (elem.pitches && elem.pitches.length > 0 && elem.pitches[0])
          return elem.pitches[0].duration;
        if (elem.elem)
          return elem.elem.duration;
        return elem.duration;
      }
      var scale = [0, 2, 4, 5, 7, 9, 11];
      function adjustPitch(note) {
        if (note.midipitch !== void 0)
          return note.midipitch;
        var pitch = note.pitch;
        if (note.accidental) {
          switch (note.accidental) {
            case "sharp":
              barAccidentals[pitch] = 1;
              break;
            case "flat":
              barAccidentals[pitch] = -1;
              break;
            case "natural":
              barAccidentals[pitch] = 0;
              break;
            case "dblsharp":
              barAccidentals[pitch] = 2;
              break;
            case "dblflat":
              barAccidentals[pitch] = -2;
              break;
            case "quartersharp":
              barAccidentals[pitch] = 0.25;
              break;
            case "quarterflat":
              barAccidentals[pitch] = -0.25;
              break;
          }
        }
        var actualPitch = extractOctave(pitch) * 12 + scale[extractNote(pitch)] + 60;
        if (barAccidentals[pitch] !== void 0) {
          actualPitch += barAccidentals[pitch];
        } else {
          actualPitch += accidentals[extractNote(pitch)];
        }
        actualPitch += transpose;
        return actualPitch;
      }
      function setKeySignature(elem) {
        var accidentals2 = [0, 0, 0, 0, 0, 0, 0];
        if (!elem.accidentals)
          return accidentals2;
        for (var i = 0; i < elem.accidentals.length; i++) {
          var acc = elem.accidentals[i];
          var d;
          switch (acc.acc) {
            case "flat":
              d = -1;
              break;
            case "quarterflat":
              d = -0.25;
              break;
            case "sharp":
              d = 1;
              break;
            case "quartersharp":
              d = 0.25;
              break;
            default:
              d = 0;
              break;
          }
          var lowercase = acc.note.toLowerCase();
          var note = extractNote(lowercase.charCodeAt(0) - "c".charCodeAt(0));
          accidentals2[note] += d;
        }
        return accidentals2;
      }
      function processGraceNotes(graces, companionDuration) {
        var graceDuration = 0;
        var ret = [];
        var grace;
        for (var g = 0; g < graces.length; g++) {
          grace = graces[g];
          graceDuration += grace.duration;
        }
        var multiplier = companionDuration / 2 / graceDuration;
        for (g = 0; g < graces.length; g++) {
          grace = graces[g];
          var actualPitch = adjustPitch(grace);
          if (currentInstrument === drumInstrument && percmap) {
            var name = pitchesToPerc(grace);
            if (name && percmap[name])
              actualPitch = percmap[name].sound;
          }
          var pitch = { pitch: actualPitch, duration: grace.duration * multiplier };
          pitch = adjustForMicroTone(pitch);
          ret.push(pitch);
        }
        return ret;
      }
      function writeGraceNotes(graces, start, velocity, currentInstrument2) {
        var midiGrace = [];
        velocity = Math.round(velocity);
        for (var g = 0; g < graces.length; g++) {
          var gp = graces[g];
          currentTrack.push({ cmd: "note", pitch: gp.pitch, volume: velocity, start, duration: gp.duration, gap: 0, instrument: currentInstrument2, style: "grace" });
          midiGrace.push({
            pitch: gp.pitch,
            durationInMeasures: gp.duration,
            volume: velocity,
            instrument: currentInstrument2
          });
          start += gp.duration;
        }
        return midiGrace;
      }
      var quarterToneFactor = 0.02930223664349;
      function adjustForMicroTone(description) {
        var pitch = "" + description.pitch;
        if (pitch.indexOf(".75") >= 0) {
          description.pitch = Math.round(description.pitch);
          description.cents = -50;
        } else if (pitch.indexOf(".25") >= 0) {
          description.pitch = Math.round(description.pitch);
          description.cents = 50;
        }
        return description;
      }
      function extractOctave(pitch) {
        return Math.floor(pitch / 7);
      }
      function extractNote(pitch) {
        pitch = pitch % 7;
        if (pitch < 0)
          pitch += 7;
        return pitch;
      }
      var basses = {
        "A": 33,
        "B": 35,
        "C": 36,
        "D": 38,
        "E": 40,
        "F": 41,
        "G": 43
      };
      function interpretChord(name) {
        if (name.length === 0)
          return void 0;
        if (name === "break")
          return { chick: [] };
        var root = name.substring(0, 1);
        if (root === "(") {
          name = name.substring(1, name.length - 2);
          if (name.length === 0)
            return void 0;
          root = name.substring(0, 1);
        }
        var bass = basses[root];
        if (!bass)
          return void 0;
        var chordTranspose = transpose;
        while (chordTranspose < -8)
          chordTranspose += 12;
        while (chordTranspose > 8)
          chordTranspose -= 12;
        bass += chordTranspose;
        var bass2 = bass - 5;
        var chick;
        if (name.length === 1)
          chick = chordNotes(bass, "");
        var remaining = name.substring(1);
        var acc = remaining.substring(0, 1);
        if (acc === "b" || acc === "\u266D") {
          bass--;
          bass2--;
          remaining = remaining.substring(1);
        } else if (acc === "#" || acc === "\u266F") {
          bass++;
          bass2++;
          remaining = remaining.substring(1);
        }
        var arr = remaining.split("/");
        chick = chordNotes(bass, arr[0]);
        if (chick.length >= 3) {
          var fifth = chick[2] - chick[0];
          bass2 = bass2 + fifth - 7;
        }
        if (arr.length === 2) {
          var explicitBass = basses[arr[1].substring(0, 1)];
          if (explicitBass) {
            var bassAcc = arr[1].substring(1);
            var bassShift = { "#": 1, "\u266F": 1, "b": -1, "\u266D": -1 }[bassAcc] || 0;
            bass = basses[arr[1].substring(0, 1)] + bassShift + chordTranspose;
            bass2 = bass;
          }
        }
        return { boom: bass, boom2: bass2, chick };
      }
      var chordIntervals = {
        "dim": [0, 3, 6],
        "\xB0": [0, 3, 6],
        "\u02DA": [0, 3, 6],
        "dim7": [0, 3, 6, 9],
        "\xB07": [0, 3, 6, 9],
        "\u02DA7": [0, 3, 6, 9],
        "\xF87": [0, 3, 6, 10],
        "m7(b5)": [0, 3, 6, 10],
        "m7b5": [0, 3, 6, 10],
        "m7\u266D5": [0, 3, 6, 10],
        "-7(b5)": [0, 3, 6, 10],
        "-7b5": [0, 3, 6, 10],
        "7b5": [0, 4, 6, 10],
        "7(b5)": [0, 4, 6, 10],
        "7\u266D5": [0, 4, 6, 10],
        "7(b9,b5)": [0, 4, 6, 10, 13],
        "7b9,b5": [0, 4, 6, 10, 13],
        "7(#9,b5)": [0, 4, 6, 10, 15],
        "7#9b5": [0, 4, 6, 10, 15],
        "maj7(b5)": [0, 4, 6, 11],
        "maj7b5": [0, 4, 6, 11],
        "13(b5)": [0, 4, 6, 10, 14, 21],
        "13b5": [0, 4, 6, 10, 14, 21],
        "m": [0, 3, 7],
        "-": [0, 3, 7],
        "m6": [0, 3, 7, 9],
        "-6": [0, 3, 7, 9],
        "m7": [0, 3, 7, 10],
        "-7": [0, 3, 7, 10],
        "-(b6)": [0, 3, 7, 8],
        "-b6": [0, 3, 7, 8],
        "-6/9": [0, 3, 7, 9, 14],
        "-7(b9)": [0, 3, 7, 10, 13],
        "-7b9": [0, 3, 7, 10, 13],
        "-maj7": [0, 3, 7, 11],
        "-9+7": [0, 3, 7, 11, 13],
        "-11": [0, 3, 7, 11, 14, 17],
        "m11": [0, 3, 7, 11, 14, 17],
        "-maj9": [0, 3, 7, 11, 14],
        "-\u22069": [0, 3, 7, 11, 14],
        "mM9": [0, 3, 7, 11, 14],
        "M": [0, 4, 7],
        "6": [0, 4, 7, 9],
        "6/9": [0, 4, 7, 9, 14],
        "6add9": [0, 4, 7, 9, 14],
        "69": [0, 4, 7, 9, 14],
        "7": [0, 4, 7, 10],
        "9": [0, 4, 7, 10, 14],
        "11": [0, 7, 10, 14, 17],
        "13": [0, 4, 7, 10, 14, 21],
        "7b9": [0, 4, 7, 10, 13],
        "7\u266D9": [0, 4, 7, 10, 13],
        "7(b9)": [0, 4, 7, 10, 13],
        "7(#9)": [0, 4, 7, 10, 15],
        "7#9": [0, 4, 7, 10, 15],
        "(13)": [0, 4, 7, 10, 14, 21],
        "7(9,13)": [0, 4, 7, 10, 14, 21],
        "7(#9,b13)": [0, 4, 7, 10, 15, 20],
        "7(#11)": [0, 4, 7, 10, 14, 18],
        "7#11": [0, 4, 7, 10, 14, 18],
        "7(b13)": [0, 4, 7, 10, 20],
        "7b13": [0, 4, 7, 10, 20],
        "9(#11)": [0, 4, 7, 10, 14, 18],
        "9#11": [0, 4, 7, 10, 14, 18],
        "13(#11)": [0, 4, 7, 10, 18, 21],
        "13#11": [0, 4, 7, 10, 18, 21],
        "maj7": [0, 4, 7, 11],
        "\u22067": [0, 4, 7, 11],
        "\u03947": [0, 4, 7, 11],
        "maj9": [0, 4, 7, 11, 14],
        "maj7(9)": [0, 4, 7, 11, 14],
        "maj7(11)": [0, 4, 7, 11, 17],
        "maj7(#11)": [0, 4, 7, 11, 18],
        "maj7(13)": [0, 4, 7, 14, 21],
        "maj7(9,13)": [0, 4, 7, 11, 14, 21],
        "7sus4": [0, 5, 7, 10],
        "m7sus4": [0, 3, 7, 10, 17],
        "sus4": [0, 5, 7],
        "sus2": [0, 2, 7],
        "7sus2": [0, 2, 7, 10],
        "9sus4": [0, 5, 7, 10, 14],
        "13sus4": [0, 5, 7, 10, 14, 21],
        "aug7": [0, 4, 8, 10],
        "+7": [0, 4, 8, 10],
        "+": [0, 4, 8],
        "7#5": [0, 4, 8, 10],
        "7\u266F5": [0, 4, 8, 10],
        "7+5": [0, 4, 8, 10],
        "9#5": [0, 4, 8, 10, 14],
        "9\u266F5": [0, 4, 8, 10, 14],
        "9+5": [0, 4, 8, 10, 14],
        "-7(#5)": [0, 3, 8, 10],
        "-7#5": [0, 3, 8, 10],
        "7(#5)": [0, 4, 8, 10],
        "7(b9,#5)": [0, 4, 8, 10, 13],
        "7b9#5": [0, 4, 8, 10, 13],
        "maj7(#5)": [0, 4, 8, 11],
        "maj7#5": [0, 4, 8, 11],
        "maj7(#5,#11)": [0, 4, 8, 11, 18],
        "maj7#5#11": [0, 4, 8, 11, 18],
        "9(#5)": [0, 4, 8, 10, 14],
        "13(#5)": [0, 4, 8, 10, 14, 21],
        "13#5": [0, 4, 8, 10, 14, 21]
      };
      function chordNotes(bass, modifier) {
        var intervals = chordIntervals[modifier];
        if (!intervals) {
          if (modifier.slice(0, 2).toLowerCase() === "ma" || modifier.charAt(0) === "M")
            intervals = chordIntervals.M;
          else if (modifier.charAt(0) === "m" || modifier.charAt(0) === "-")
            intervals = chordIntervals.m;
          else
            intervals = chordIntervals.M;
        }
        bass += 12;
        var notes = [];
        for (var i = 0; i < intervals.length; i++) {
          notes.push(bass + intervals[i]);
        }
        return notes;
      }
      function writeBoom(boom, beatLength, volume, beat, noteLength) {
        if (boom !== void 0)
          chordTrack.push({ cmd: "note", pitch: boom, volume, start: lastBarTime + beat * durationRounded(beatLength), duration: durationRounded(noteLength), gap: 0, instrument: chordInstrument });
      }
      function writeChick(chick, beatLength, volume, beat, noteLength) {
        for (var c = 0; c < chick.length; c++)
          chordTrack.push({ cmd: "note", pitch: chick[c], volume, start: lastBarTime + beat * durationRounded(beatLength), duration: durationRounded(noteLength), gap: 0, instrument: chordInstrument });
      }
      var rhythmPatterns = {
        "2/2": ["boom", "chick"],
        "2/4": ["boom", "chick"],
        "3/4": ["boom", "chick", "chick"],
        "4/4": ["boom", "chick", "boom2", "chick"],
        "5/4": ["boom", "chick", "chick", "boom2", "chick"],
        "6/8": ["boom", "", "chick", "boom2", "", "chick"],
        "9/8": ["boom", "", "chick", "boom2", "", "chick", "boom2", "", "chick"],
        "12/8": ["boom", "", "chick", "boom2", "", "chick", "boom", "", "chick", "boom2", "", "chick"]
      };
      function resolveChords(startTime, endTime) {
        var num = meter.num;
        var den = meter.den;
        var beatLength = 1 / den;
        var noteLength = beatLength / 2;
        var pattern = rhythmPatterns[num + "/" + den];
        var thisMeasureLength = parseInt(num, 10) / parseInt(den, 10);
        var portionOfAMeasure = thisMeasureLength - (endTime - startTime) / tempoChangeFactor;
        if (Math.abs(portionOfAMeasure) < 1e-5)
          portionOfAMeasure = false;
        if (!pattern || portionOfAMeasure) {
          pattern = [];
          var beatsPresent = (endTime - startTime) / tempoChangeFactor / beatLength;
          for (var p = 0; p < beatsPresent; p++)
            pattern.push("chick");
        }
        if (currentChords.length === 0) {
          currentChords.push({ beat: 0, chord: lastChord });
        }
        if (currentChords[0].beat !== 0 && lastChord) {
          if (chordLastBar)
            currentChords.unshift({ beat: 0, chord: chordLastBar });
        }
        if (currentChords.length === 1) {
          for (var m = currentChords[0].beat; m < pattern.length; m++) {
            if (!hasRhythmHead) {
              switch (pattern[m]) {
                case "boom":
                  writeBoom(currentChords[0].chord.boom, beatLength, boomVolume, m, noteLength);
                  break;
                case "boom2":
                  writeBoom(currentChords[0].chord.boom2, beatLength, boomVolume, m, noteLength);
                  break;
                case "chick":
                  writeChick(currentChords[0].chord.chick, beatLength, chickVolume, m, noteLength);
                  break;
              }
            }
          }
          return;
        }
        var mult = beatLength === 0.125 ? 3 : 1;
        var beats = {};
        for (var i = 0; i < currentChords.length; i++) {
          var cc = currentChords[i];
          var b = Math.round(cc.beat * mult);
          beats["" + b] = cc;
        }
        for (var m2 = 0; m2 < pattern.length; m2++) {
          var thisChord;
          if (beats["" + m2])
            thisChord = beats["" + m2];
          var lastBoom;
          if (!hasRhythmHead && thisChord) {
            switch (pattern[m2]) {
              case "boom":
                if (beats["" + (m2 + 1)])
                  writeChick(thisChord.chord.chick, beatLength, chickVolume, m2, noteLength);
                else {
                  writeBoom(thisChord.chord.boom, beatLength, boomVolume, m2, noteLength);
                  lastBoom = thisChord.chord.boom;
                }
                break;
              case "boom2":
                if (beats["" + (m2 + 1)])
                  writeChick(thisChord.chord.chick, beatLength, chickVolume, m2, noteLength);
                else {
                  if (lastBoom === thisChord.chord.boom) {
                    writeBoom(thisChord.chord.boom2, beatLength, boomVolume, m2, noteLength);
                    lastBoom = void 0;
                  } else {
                    writeBoom(thisChord.chord.boom, beatLength, boomVolume, m2, noteLength);
                    lastBoom = thisChord.chord.boom;
                  }
                }
                break;
              case "chick":
                writeChick(thisChord.chord.chick, beatLength, chickVolume, m2, noteLength);
                break;
              case "":
                if (beats["" + m2])
                  writeChick(thisChord.chord.chick, beatLength, chickVolume, m2, noteLength);
                break;
            }
          }
        }
      }
      function normalizeDrumDefinition(params) {
        if (params.pattern.length === 0 || params.on === false)
          return { on: false };
        var str = params.pattern[0];
        var events = [];
        var event = "";
        var totalPlay = 0;
        for (var i = 0; i < str.length; i++) {
          if (str[i] === "d")
            totalPlay++;
          if (str[i] === "d" || str[i] === "z") {
            if (event.length !== 0) {
              events.push(event);
              event = str[i];
            } else
              event = event + str[i];
          } else {
            if (event.length === 0) {
              return { on: false };
            }
            event = event + str[i];
          }
        }
        if (event.length !== 0)
          events.push(event);
        if (params.pattern.length !== totalPlay * 2 + 1)
          return { on: false };
        var ret = { on: true, bars: params.bars, pattern: [] };
        var beatLength = getBeatFraction(meter);
        var playCount = 0;
        for (var j = 0; j < events.length; j++) {
          event = events[j];
          var len = 1;
          var div = false;
          var num = 0;
          for (var k = 1; k < event.length; k++) {
            switch (event[k]) {
              case "/":
                if (num !== 0)
                  len *= num;
                num = 0;
                div = true;
                break;
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                num = num * 10 + event[k];
                break;
              default:
                return { on: false };
            }
          }
          if (div) {
            if (num === 0)
              num = 2;
            len /= num;
          } else if (num)
            len *= num;
          if (event[0] === "d") {
            ret.pattern.push({ len: len * beatLength, pitch: params.pattern[1 + playCount], velocity: params.pattern[1 + playCount + totalPlay] });
            playCount++;
          } else
            ret.pattern.push({ len: len * beatLength, pitch: null });
        }
        var totalTime = 0;
        var measuresPerBeat = meter.num / meter.den;
        for (var ii = 0; ii < ret.pattern.length; ii++)
          totalTime += ret.pattern[ii].len;
        var numBars = params.bars ? params.bars : 1;
        var factor = totalTime / numBars / measuresPerBeat;
        for (ii = 0; ii < ret.pattern.length; ii++)
          ret.pattern[ii].len = ret.pattern[ii].len / factor;
        return ret;
      }
      function writeDrum(channel) {
        if (drumTrack.length === 0 && !drumDefinition.on)
          return;
        var measureLen = meter.num / meter.den;
        if (drumTrack.length === 0) {
          if (lastEventTime < measureLen)
            return;
          drumTrack.push({ cmd: "program", channel, instrument: drumInstrument });
        }
        if (!drumDefinition.on) {
          return;
        }
        var start = lastBarTime;
        for (var i = 0; i < drumDefinition.pattern.length; i++) {
          var len = durationRounded(drumDefinition.pattern[i].len);
          if (drumDefinition.pattern[i].pitch) {
            drumTrack.push({
              cmd: "note",
              pitch: drumDefinition.pattern[i].pitch,
              volume: drumDefinition.pattern[i].velocity,
              start,
              duration: len,
              gap: 0,
              instrument: drumInstrument
            });
          }
          start += len;
        }
      }
      function findOctaves(tracks2, detuneCents) {
        var timing = {};
        for (var i = 0; i < tracks2.length; i++) {
          for (var j = 0; j < tracks2[i].length; j++) {
            var note = tracks2[i][j];
            if (note.cmd === "note") {
              if (timing[note.start] === void 0)
                timing[note.start] = [];
              timing[note.start].push({ track: i, event: j, pitch: note.pitch });
            }
          }
        }
        var keys = Object.keys(timing);
        for (i = 0; i < keys.length; i++) {
          var arr = timing[keys[i]];
          if (arr.length > 1) {
            arr = arr.sort(function(a, b) {
              return a.pitch - b.pitch;
            });
            var topEvent = arr[arr.length - 1];
            var topNote = topEvent.pitch % 12;
            var found = false;
            for (j = 0; !found && j < arr.length - 1; j++) {
              if (arr[j].pitch % 12 === topNote)
                found = true;
            }
            if (found) {
              var event = tracks2[topEvent.track][topEvent.event];
              if (!event.cents)
                event.cents = 0;
              event.cents += detuneCents;
            }
          }
        }
      }
    })();
    module.exports = flatten;
  }
});

// node_modules/abcjs/src/data/deline-tune.js
var require_deline_tune = __commonJS({
  "node_modules/abcjs/src/data/deline-tune.js"(exports, module) {
    function delineTune(inputLines, options) {
      if (!options)
        options = {};
      var lineBreaks = !!options.lineBreaks;
      var outputLines = [];
      var inMusicLine = false;
      var currentMeter = [];
      var currentKey = [];
      var currentClef = [];
      var currentVocalFont = [];
      var currentGChordFont = [];
      var currentTripletFont = [];
      var currentAnnotationFont = [];
      for (var i = 0; i < inputLines.length; i++) {
        var inputLine = inputLines[i];
        if (inputLine.staff) {
          if (inMusicLine && !inputLine.vskip) {
            var outputLine = outputLines[outputLines.length - 1];
            for (var s = 0; s < outputLine.staff.length; s++) {
              var inputStaff = inputLine.staff[s];
              var outputStaff = outputLine.staff[s];
              if (inputStaff) {
                if (!objEqual(inputStaff.meter, currentMeter[s])) {
                  addMeterToVoices(inputStaff.meter, inputStaff.voices);
                  currentMeter[s] = inputStaff.meter;
                  delete inputStaff.meter;
                }
                if (!objEqual(inputStaff.key, currentKey[s])) {
                  addKeyToVoices(inputStaff.key, inputStaff.voices);
                  currentKey[s] = inputStaff.key;
                  delete inputStaff.key;
                }
                if (inputStaff.title)
                  outputStaff.abbrevTitle = inputStaff.title;
                if (!objEqual(inputStaff.clef, currentClef[s])) {
                  addClefToVoices(inputStaff.clef, inputStaff.voices);
                  currentClef[s] = inputStaff.clef;
                  delete inputStaff.clef;
                }
                if (!objEqual(inputStaff.vocalfont, currentVocalFont[s])) {
                  addFontToVoices(inputStaff.vocalfont, inputStaff.voices, "vocalfont");
                  currentVocalFont[s] = inputStaff.vocalfont;
                  delete inputStaff.vocalfont;
                }
                if (!objEqual(inputStaff.gchordfont, currentGChordFont[s])) {
                  addFontToVoices(inputStaff.gchordfont, inputStaff.voices, "gchordfont");
                  currentGChordFont[s] = inputStaff.gchordfont;
                  delete inputStaff.gchordfont;
                }
                if (!objEqual(inputStaff.tripletfont, currentTripletFont[s])) {
                  addFontToVoices(inputStaff.tripletfont, inputStaff.voices, "tripletfont");
                  currentTripletFont[s] = inputStaff.tripletfont;
                  delete inputStaff.tripletfont;
                }
                if (!objEqual(inputStaff.annotationfont, currentAnnotationFont[s])) {
                  addFontToVoices(inputStaff.annotationfont, inputStaff.voices, "annotationfont");
                  currentAnnotationFont[s] = inputStaff.annotationfont;
                  delete inputStaff.annotationfont;
                }
              }
              if (inputStaff) {
                for (var v = 0; v < outputStaff.voices.length; v++) {
                  var outputVoice = outputStaff.voices[v];
                  var inputVoice = inputStaff.voices[v];
                  if (lineBreaks)
                    outputVoice.push({ el_type: "break" });
                  if (inputVoice)
                    outputStaff.voices[v] = outputVoice.concat(inputVoice);
                }
              }
            }
          } else {
            for (var ii = 0; ii < inputLine.staff.length; ii++) {
              currentKey[ii] = inputLine.staff[ii].key;
              currentMeter[ii] = inputLine.staff[ii].meter;
              currentClef[ii] = inputLine.staff[ii].clef;
            }
            outputLines.push(cloneLine(inputLine));
          }
          inMusicLine = true;
        } else {
          inMusicLine = false;
          outputLines.push(inputLine);
        }
      }
      return outputLines;
    }
    function replacer(key, value) {
      if (key === "abselem") {
        return "abselem";
      }
      return value;
    }
    function addMeterToVoices(meter, voices) {
      meter.el_type = "meter";
      meter.startChar = -1;
      meter.endChar = -1;
      for (var i = 0; i < voices.length; i++) {
        voices[i].unshift(meter);
      }
    }
    function addKeyToVoices(key, voices) {
      key.el_type = "key";
      key.startChar = -1;
      key.endChar = -1;
      for (var i = 0; i < voices.length; i++) {
        voices[i].unshift(key);
      }
    }
    function addClefToVoices(clef, voices) {
      clef.el_type = "clef";
      clef.startChar = -1;
      clef.endChar = -1;
      for (var i = 0; i < voices.length; i++) {
        voices[i].unshift(clef);
      }
    }
    function addFontToVoices(font, voices, type) {
      font.el_type = "font";
      font.type = type;
      font.startChar = -1;
      font.endChar = -1;
      for (var i = 0; i < voices.length; i++) {
        voices[i].unshift(font);
      }
    }
    function objEqual(input, output) {
      if (!input)
        return true;
      var inputValue = JSON.stringify(input, replacer);
      var outputValue = JSON.stringify(output, replacer);
      return inputValue === outputValue;
    }
    function cloneLine(line) {
      var output = {};
      var keys = Object.keys(line);
      for (var i = 0; i < keys.length; i++) {
        if (keys[i] !== "staff")
          output[keys[i]] = line[keys[i]];
        else {
          output.staff = [];
          for (var j = 0; j < line.staff.length; j++) {
            var staff = {};
            var keys2 = Object.keys(line.staff[j]);
            for (var k = 0; k < keys2.length; k++) {
              if (keys2[k] !== "voices")
                staff[keys2[k]] = line.staff[j][keys2[k]];
              else {
                staff.voices = [];
                for (var v = 0; v < line.staff[j].voices.length; v++) {
                  staff.voices.push([].concat(line.staff[j].voices[v]));
                }
              }
            }
            output.staff.push(staff);
          }
        }
      }
      return output;
    }
    module.exports = delineTune;
  }
});

// node_modules/abcjs/src/data/abc_tune.js
var require_abc_tune = __commonJS({
  "node_modules/abcjs/src/data/abc_tune.js"(exports, module) {
    var parseCommon = require_abc_common();
    var spacing = require_abc_spacing();
    var sequence = require_abc_midi_sequencer();
    var flatten = require_abc_midi_flattener();
    var delineTune = require_deline_tune();
    var Tune = function() {
      this.reset = function() {
        this.version = "1.1.0";
        this.media = "screen";
        this.metaText = {};
        this.metaTextInfo = {};
        this.formatting = {};
        this.lines = [];
        this.staffNum = 0;
        this.voiceNum = 0;
        this.lineNum = 0;
        this.runningFonts = {};
        delete this.visualTranspose;
      };
      this.reset();
      function copy(dest, src, prop, attrs) {
        for (var i = 0; i < attrs.length; i++)
          dest[prop][attrs[i]] = src[prop][attrs[i]];
      }
      this.copyTopInfo = function(src) {
        var attrs = ["tempo", "title", "header", "rhythm", "origin", "composer", "author", "partOrder"];
        copy(this, src, "metaText", attrs);
        copy(this, src, "metaTextInfo", attrs);
      };
      this.copyBottomInfo = function(src) {
        var attrs = [
          "unalignedWords",
          "book",
          "source",
          "discography",
          "notes",
          "transcription",
          "history",
          "abc-copyright",
          "abc-creator",
          "abc-edited-by",
          "footer"
        ];
        copy(this, src, "metaText", attrs);
        copy(this, src, "metaTextInfo", attrs);
      };
      this.getBeatLength = function() {
        var meter = this.getMeterFraction();
        var multiplier = 1;
        if (meter.num === 6 || meter.num === 9 || meter.num === 12)
          multiplier = 3;
        else if (meter.num === 3 && meter.den === 8)
          multiplier = 3;
        return multiplier / meter.den;
      };
      function computePickupLength(lines, barLength) {
        var pickupLength = 0;
        for (var i = 0; i < lines.length; i++) {
          if (lines[i].staff) {
            for (var j = 0; j < lines[i].staff.length; j++) {
              for (var v = 0; v < lines[i].staff[j].voices.length; v++) {
                var voice = lines[i].staff[j].voices[v];
                var tripletMultiplier = 1;
                for (var el = 0; el < voice.length; el++) {
                  var isSpacer = voice[el].rest && voice[el].rest.type === "spacer";
                  if (voice[el].startTriplet)
                    tripletMultiplier = voice[el].tripletMultiplier;
                  if (voice[el].duration && !isSpacer && voice[el].el_type !== "tempo")
                    pickupLength += voice[el].duration * tripletMultiplier;
                  if (voice[el].endTriplet)
                    tripletMultiplier = 1;
                  if (pickupLength >= barLength)
                    pickupLength -= barLength;
                  if (voice[el].el_type === "bar")
                    return pickupLength;
                }
              }
            }
          }
        }
        return pickupLength;
      }
      this.getPickupLength = function() {
        var barLength = this.getBarLength();
        var pickupLength = computePickupLength(this.lines, barLength);
        return pickupLength < 1e-8 || barLength - pickupLength < 1e-8 ? 0 : pickupLength;
      };
      this.getBarLength = function() {
        var meter = this.getMeterFraction();
        return meter.num / meter.den;
      };
      this.getTotalTime = function() {
        return this.totalTime;
      };
      this.getTotalBeats = function() {
        return this.totalBeats;
      };
      this.millisecondsPerMeasure = function(bpmOverride) {
        var bpm;
        if (bpmOverride) {
          bpm = bpmOverride;
        } else {
          var tempo = this.metaText ? this.metaText.tempo : null;
          bpm = this.getBpm(tempo);
        }
        if (bpm <= 0)
          bpm = 1;
        var beatsPerMeasure = this.getBeatsPerMeasure();
        var minutesPerMeasure = beatsPerMeasure / bpm;
        return minutesPerMeasure * 6e4;
      };
      this.getBeatsPerMeasure = function() {
        var beatLen = this.getBeatLength();
        var barLen = this.getBarLength();
        return barLen / beatLen;
      };
      this.getMeter = function() {
        for (var i = 0; i < this.lines.length; i++) {
          var line = this.lines[i];
          if (line.staff) {
            for (var j = 0; j < line.staff.length; j++) {
              var meter = line.staff[j].meter;
              if (meter) {
                return meter;
              }
            }
          }
        }
        return { type: "common_time" };
      };
      this.getMeterFraction = function() {
        var meter = this.getMeter();
        var num = 4;
        var den = 4;
        if (meter) {
          if (meter.type === "specified") {
            num = parseInt(meter.value[0].num, 10);
            den = parseInt(meter.value[0].den, 10);
          } else if (meter.type === "cut_time") {
            num = 2;
            den = 2;
          } else if (meter.type === "common_time") {
            num = 4;
            den = 4;
          }
        }
        this.meter = { num, den };
        return this.meter;
      };
      this.getKeySignature = function() {
        for (var i = 0; i < this.lines.length; i++) {
          var line = this.lines[i];
          if (line.staff) {
            for (var j = 0; j < line.staff.length; j++) {
              if (line.staff[j].key)
                return line.staff[j].key;
            }
          }
        }
        return {};
      };
      this.getElementFromChar = function(char) {
        for (var i = 0; i < this.lines.length; i++) {
          var line = this.lines[i];
          if (line.staff) {
            for (var j = 0; j < line.staff.length; j++) {
              var staff = line.staff[j];
              for (var k = 0; k < staff.voices.length; k++) {
                var voice = staff.voices[k];
                for (var ii = 0; ii < voice.length; ii++) {
                  var elem = voice[ii];
                  if (elem.startChar && elem.endChar && elem.startChar <= char && elem.endChar > char)
                    return elem;
                }
              }
            }
          }
        }
        return null;
      };
      function addVerticalInfo(timingEvents) {
        var lastBarTop;
        var lastBarBottom;
        var lastEventTop;
        var lastEventBottom;
        for (var e = timingEvents.length - 1; e >= 0; e--) {
          var ev = timingEvents[e];
          if (ev.type === "bar") {
            ev.top = lastEventTop;
            ev.nextTop = lastBarTop;
            lastBarTop = lastEventTop;
            ev.bottom = lastEventBottom;
            ev.nextBottom = lastBarBottom;
            lastBarBottom = lastEventBottom;
          } else if (ev.type === "event") {
            lastEventTop = ev.top;
            lastEventBottom = ev.top + ev.height;
          }
        }
      }
      function makeSortedArray(hash) {
        var arr = [];
        for (var k in hash) {
          if (hash.hasOwnProperty(k))
            arr.push(hash[k]);
        }
        arr = arr.sort(function(a, b) {
          var diff = a.milliseconds - b.milliseconds;
          if (diff !== 0) {
            return diff;
          } else {
            return a.type === "bar" ? -1 : 1;
          }
        });
        return arr;
      }
      this.addElementToEvents = function(eventHash, element, voiceTimeMilliseconds, top, height, line, measureNumber, timeDivider, isTiedState, nextIsBar) {
        if (element.hint)
          return { isTiedState: void 0, duration: 0 };
        var realDuration = element.durationClass ? element.durationClass : element.duration;
        if (element.abcelem.rest && element.abcelem.rest.type === "spacer")
          realDuration = 0;
        if (realDuration > 0) {
          var es = [];
          for (var i = 0; i < element.elemset.length; i++) {
            if (element.elemset[i] !== null)
              es.push(element.elemset[i]);
          }
          var isTiedToNext = element.startTie;
          if (isTiedState !== void 0) {
            eventHash["event" + isTiedState].elements.push(es);
            if (nextIsBar) {
              if (!eventHash["event" + voiceTimeMilliseconds]) {
                eventHash["event" + voiceTimeMilliseconds] = {
                  type: "event",
                  milliseconds: voiceTimeMilliseconds,
                  line,
                  measureNumber,
                  top,
                  height,
                  left: null,
                  width: 0,
                  elements: [],
                  startChar: null,
                  endChar: null,
                  startCharArray: [],
                  endCharArray: []
                };
              }
              eventHash["event" + voiceTimeMilliseconds].measureStart = true;
              nextIsBar = false;
            }
            if (!isTiedToNext)
              isTiedState = void 0;
          } else {
            if (!eventHash["event" + voiceTimeMilliseconds]) {
              eventHash["event" + voiceTimeMilliseconds] = {
                type: "event",
                milliseconds: voiceTimeMilliseconds,
                line,
                measureNumber,
                top,
                height,
                left: element.x,
                width: element.w,
                elements: [es],
                startChar: element.abcelem.startChar,
                endChar: element.abcelem.endChar,
                startCharArray: [element.abcelem.startChar],
                endCharArray: [element.abcelem.endChar],
                midiPitches: element.abcelem.midiPitches ? parseCommon.cloneArray(element.abcelem.midiPitches) : []
              };
              if (element.abcelem.midiGraceNotePitches)
                eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches = parseCommon.cloneArray(element.abcelem.midiGraceNotePitches);
            } else {
              if (eventHash["event" + voiceTimeMilliseconds].left)
                eventHash["event" + voiceTimeMilliseconds].left = Math.min(eventHash["event" + voiceTimeMilliseconds].left, element.x);
              else
                eventHash["event" + voiceTimeMilliseconds].left = element.x;
              eventHash["event" + voiceTimeMilliseconds].elements.push(es);
              eventHash["event" + voiceTimeMilliseconds].startCharArray.push(element.abcelem.startChar);
              eventHash["event" + voiceTimeMilliseconds].endCharArray.push(element.abcelem.endChar);
              if (eventHash["event" + voiceTimeMilliseconds].startChar === null)
                eventHash["event" + voiceTimeMilliseconds].startChar = element.abcelem.startChar;
              if (eventHash["event" + voiceTimeMilliseconds].endChar === null)
                eventHash["event" + voiceTimeMilliseconds].endChar = element.abcelem.endChar;
              if (element.abcelem.midiPitches && element.abcelem.midiPitches.length) {
                if (!eventHash["event" + voiceTimeMilliseconds].midiPitches)
                  eventHash["event" + voiceTimeMilliseconds].midiPitches = [];
                for (var i = 0; i < element.abcelem.midiPitches.length; i++)
                  eventHash["event" + voiceTimeMilliseconds].midiPitches.push(element.abcelem.midiPitches[i]);
              }
              if (element.abcelem.midiGraceNotePitches && element.abcelem.midiGraceNotePitches.length) {
                if (!eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches)
                  eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches = [];
                for (var j = 0; j < element.abcelem.midiGraceNotePitches.length; j++)
                  eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches.push(element.abcelem.midiGraceNotePitches[j]);
              }
            }
            if (nextIsBar) {
              eventHash["event" + voiceTimeMilliseconds].measureStart = true;
              nextIsBar = false;
            }
            if (isTiedToNext)
              isTiedState = voiceTimeMilliseconds;
          }
        }
        return { isTiedState, duration: realDuration / timeDivider, nextIsBar: nextIsBar || element.type === "bar" };
      };
      this.makeVoicesArray = function() {
        var voicesArr = [];
        var measureNumber = [];
        var tempos = {};
        for (var line = 0; line < this.engraver.staffgroups.length; line++) {
          var group = this.engraver.staffgroups[line];
          if (group && group.staffs && group.staffs.length > 0) {
            var firstStaff = group.staffs[0];
            var middleC = firstStaff.absoluteY;
            var top = middleC - firstStaff.top * spacing.STEP;
            var lastStaff = group.staffs[group.staffs.length - 1];
            middleC = lastStaff.absoluteY;
            var bottom = middleC - lastStaff.bottom * spacing.STEP;
            var height = bottom - top;
            var voices = group.voices;
            for (var v = 0; v < voices.length; v++) {
              var noteFound = false;
              if (!voicesArr[v])
                voicesArr[v] = [];
              if (measureNumber[v] === void 0)
                measureNumber[v] = 0;
              var elements = voices[v].children;
              for (var elem = 0; elem < elements.length; elem++) {
                if (elements[elem].type === "tempo")
                  tempos[measureNumber[v]] = this.getBpm(elements[elem].abcelem);
                voicesArr[v].push({ top, height, line: group.line, measureNumber: measureNumber[v], elem: elements[elem] });
                if (elements[elem].type === "bar" && noteFound)
                  measureNumber[v]++;
                if (elements[elem].type === "note" || elements[elem].type === "rest")
                  noteFound = true;
              }
            }
          }
        }
        this.tempoLocations = tempos;
        return voicesArr;
      };
      this.setupEvents = function(startingDelay, timeDivider, startingBpm, warp) {
        if (!warp)
          warp = 1;
        var timingEvents = [];
        var eventHash = {};
        var time = startingDelay;
        var isTiedState;
        var nextIsBar = true;
        var voices = this.makeVoicesArray();
        var maxVoiceTimeMilliseconds = 0;
        for (var v = 0; v < voices.length; v++) {
          var voiceTime = time;
          var voiceTimeMilliseconds = Math.round(voiceTime * 1e3);
          var startingRepeatElem = 0;
          var endingRepeatElem = -1;
          var elements = voices[v];
          var bpm = startingBpm;
          timeDivider = this.getBeatLength() * bpm / 60;
          var tempoDone = -1;
          for (var elem = 0; elem < elements.length; elem++) {
            var thisMeasure = elements[elem].measureNumber;
            if (tempoDone !== thisMeasure && this.tempoLocations[thisMeasure]) {
              bpm = this.tempoLocations[thisMeasure];
              timeDivider = warp * this.getBeatLength() * bpm / 60;
              tempoDone = thisMeasure;
            }
            var element = elements[elem].elem;
            var ret = this.addElementToEvents(eventHash, element, voiceTimeMilliseconds, elements[elem].top, elements[elem].height, elements[elem].line, elements[elem].measureNumber, timeDivider, isTiedState, nextIsBar);
            isTiedState = ret.isTiedState;
            nextIsBar = ret.nextIsBar;
            voiceTime += ret.duration;
            var lastHash;
            if (element.duration > 0 && eventHash["event" + voiceTimeMilliseconds])
              lastHash = "event" + voiceTimeMilliseconds;
            voiceTimeMilliseconds = Math.round(voiceTime * 1e3);
            if (element.type === "bar") {
              var barType = element.abcelem.type;
              var endRepeat = barType === "bar_right_repeat" || barType === "bar_dbl_repeat";
              var startEnding = element.abcelem.startEnding === "1";
              var startRepeat = barType === "bar_left_repeat" || barType === "bar_dbl_repeat" || barType === "bar_right_repeat";
              if (endRepeat) {
                if (elem > 0) {
                  eventHash[lastHash].endX = element.x;
                }
                if (endingRepeatElem === -1)
                  endingRepeatElem = elem;
                var lastVoiceTimeMilliseconds = 0;
                tempoDone = -1;
                for (var el2 = startingRepeatElem; el2 < endingRepeatElem; el2++) {
                  thisMeasure = elements[el2].measureNumber;
                  if (tempoDone !== thisMeasure && this.tempoLocations[thisMeasure]) {
                    bpm = this.tempoLocations[thisMeasure];
                    timeDivider = warp * this.getBeatLength() * bpm / 60;
                    tempoDone = thisMeasure;
                  }
                  var element2 = elements[el2].elem;
                  ret = this.addElementToEvents(eventHash, element2, voiceTimeMilliseconds, elements[el2].top, elements[el2].height, elements[el2].line, elements[el2].measureNumber, timeDivider, isTiedState, nextIsBar);
                  isTiedState = ret.isTiedState;
                  nextIsBar = ret.nextIsBar;
                  voiceTime += ret.duration;
                  lastVoiceTimeMilliseconds = voiceTimeMilliseconds;
                  voiceTimeMilliseconds = Math.round(voiceTime * 1e3);
                }
                if (eventHash["event" + lastVoiceTimeMilliseconds])
                  eventHash["event" + lastVoiceTimeMilliseconds].endX = elements[endingRepeatElem].elem.x;
                nextIsBar = true;
                endingRepeatElem = -1;
              }
              if (startEnding)
                endingRepeatElem = elem;
              if (startRepeat)
                startingRepeatElem = elem;
            }
          }
          maxVoiceTimeMilliseconds = Math.max(maxVoiceTimeMilliseconds, voiceTimeMilliseconds);
        }
        timingEvents = makeSortedArray(eventHash);
        addVerticalInfo(timingEvents);
        addEndPoints(this.lines, timingEvents);
        timingEvents.push({ type: "end", milliseconds: maxVoiceTimeMilliseconds });
        this.addUsefulCallbackInfo(timingEvents, bpm * warp);
        return timingEvents;
      };
      this.addUsefulCallbackInfo = function(timingEvents, bpm) {
        var millisecondsPerMeasure = this.millisecondsPerMeasure(bpm);
        for (var i = 0; i < timingEvents.length; i++) {
          var ev = timingEvents[i];
          ev.millisecondsPerMeasure = millisecondsPerMeasure;
        }
      };
      function skipTies(elements, index) {
        while (index < elements.length && elements[index].left === null)
          index++;
        return elements[index];
      }
      function addEndPoints(lines, elements) {
        if (elements.length < 1)
          return;
        for (var i = 0; i < elements.length - 1; i++) {
          var el = elements[i];
          var next = skipTies(elements, i + 1);
          if (el.left !== null) {
            var endX = next && el.top === next.top ? next.left : lines[el.line].staffGroup.w;
            if (el.endX !== void 0) {
              if (endX > el.left)
                el.endX = Math.min(el.endX, endX);
            } else
              el.endX = endX;
          }
        }
        var lastEl = elements[elements.length - 1];
        lastEl.endX = lines[lastEl.line].staffGroup.w;
      }
      this.getBpm = function(tempo) {
        var bpm;
        if (tempo) {
          bpm = tempo.bpm;
          var beatLength = this.getBeatLength();
          var statedBeatLength = tempo.duration && tempo.duration.length > 0 ? tempo.duration[0] : beatLength;
          bpm = bpm * statedBeatLength / beatLength;
        }
        if (!bpm) {
          bpm = 180;
          var meter = this.getMeterFraction();
          if (meter && meter.num !== 3 && meter.num % 3 === 0) {
            bpm = 120;
          }
        }
        return bpm;
      };
      this.setTiming = function(bpm, measuresOfDelay) {
        measuresOfDelay = measuresOfDelay || 0;
        if (!this.engraver || !this.engraver.staffgroups) {
          console.log("setTiming cannot be called before the tune is drawn.");
          this.noteTimings = [];
          return;
        }
        var tempo = this.metaText ? this.metaText.tempo : null;
        var naturalBpm = this.getBpm(tempo);
        var warp = 1;
        if (bpm) {
          if (tempo)
            warp = bpm / naturalBpm;
        } else
          bpm = naturalBpm;
        var beatLength = this.getBeatLength();
        var beatsPerSecond = bpm / 60;
        var measureLength = this.getBarLength();
        var startingDelay = measureLength / beatLength * measuresOfDelay / beatsPerSecond;
        if (startingDelay)
          startingDelay -= this.getPickupLength() / beatLength / beatsPerSecond;
        var timeDivider = beatLength * beatsPerSecond;
        this.noteTimings = this.setupEvents(startingDelay, timeDivider, bpm, warp);
        if (this.noteTimings.length > 0) {
          this.totalTime = this.noteTimings[this.noteTimings.length - 1].milliseconds / 1e3;
          this.totalBeats = this.totalTime * beatsPerSecond;
        } else {
          this.totalTime = void 0;
          this.totalBeats = void 0;
        }
        return this.noteTimings;
      };
      this.setUpAudio = function(options) {
        if (!options)
          options = {};
        var seq = sequence(this, options);
        return flatten(seq, options, this.formatting.percmap);
      };
      this.deline = function(options) {
        return delineTune(this.lines, options);
      };
    };
    module.exports = Tune;
  }
});

// node_modules/abcjs/src/parse/tune-builder.js
var require_tune_builder = __commonJS({
  "node_modules/abcjs/src/parse/tune-builder.js"(exports, module) {
    var parseKeyVoice = require_abc_parse_key_voice();
    var parseCommon = require_abc_common();
    var TuneBuilder = function(tune) {
      var self = this;
      this.setVisualTranspose = function(visualTranspose) {
        if (visualTranspose)
          tune.visualTranspose = visualTranspose;
      };
      this.resolveOverlays = function() {
        var madeChanges = false;
        var durationsPerLines = [];
        for (var i = 0; i < tune.lines.length; i++) {
          var line = tune.lines[i];
          if (line.staff) {
            for (var j = 0; j < line.staff.length; j++) {
              var staff = line.staff[j];
              var overlayVoice = [];
              for (var k = 0; k < staff.voices.length; k++) {
                var voice = staff.voices[k];
                overlayVoice.push({ hasOverlay: false, voice: [], snip: [] });
                durationsPerLines[i] = 0;
                var durationThisBar = 0;
                var inOverlay = false;
                var overlayDuration = 0;
                var snipStart = -1;
                for (var kk = 0; kk < voice.length; kk++) {
                  var event = voice[kk];
                  if (event.el_type === "overlay" && !inOverlay) {
                    madeChanges = true;
                    inOverlay = true;
                    snipStart = kk;
                    overlayVoice[k].hasOverlay = true;
                    if (overlayDuration === 0)
                      overlayDuration = durationsPerLines[i];
                    for (var ii = 0; ii < i; ii++) {
                      if (durationsPerLines[ii] && tune.lines[ii].staff && staff.voices.length >= tune.lines[ii].staff[0].voices.length) {
                        tune.lines[ii].staff[0].voices.push([{
                          el_type: "note",
                          duration: durationsPerLines[ii],
                          rest: { type: "invisible" },
                          startChar: event.startChar,
                          endChar: event.endChar
                        }]);
                      }
                    }
                  } else if (event.el_type === "bar") {
                    if (inOverlay) {
                      inOverlay = false;
                      overlayVoice[k].snip.push({ start: snipStart, len: kk - snipStart });
                      overlayVoice[k].voice.push(event);
                    } else {
                      if (durationThisBar > 0)
                        overlayVoice[k].voice.push({ el_type: "note", duration: durationThisBar, rest: { type: "invisible" }, startChar: event.startChar, endChar: event.endChar });
                      overlayVoice[k].voice.push(event);
                    }
                    durationThisBar = 0;
                  } else if (event.el_type === "note") {
                    if (inOverlay) {
                      overlayVoice[k].voice.push(event);
                    } else {
                      durationThisBar += event.duration;
                      durationsPerLines[i] += event.duration;
                    }
                  } else if (event.el_type === "scale" || event.el_type === "stem" || event.el_type === "overlay" || event.el_type === "style" || event.el_type === "transpose") {
                    overlayVoice[k].voice.push(event);
                  }
                }
                if (overlayVoice[k].hasOverlay && overlayVoice[k].snip.length === 0) {
                  overlayVoice[k].snip.push({ start: snipStart, len: voice.length - snipStart });
                }
              }
              for (k = 0; k < overlayVoice.length; k++) {
                var ov = overlayVoice[k];
                if (ov.hasOverlay) {
                  ov.voice.splice(0, 0, { el_type: "stem", direction: "down" });
                  staff.voices.push(ov.voice);
                  for (var kkk = ov.snip.length - 1; kkk >= 0; kkk--) {
                    var snip = ov.snip[kkk];
                    staff.voices[k].splice(snip.start, snip.len);
                    staff.voices[k].splice(snip.start + 1, 0, { el_type: "stem", direction: "auto" });
                    var indexOfLastBar = findLastBar(staff.voices[k], snip.start);
                    staff.voices[k].splice(indexOfLastBar, 0, { el_type: "stem", direction: "up" });
                  }
                  for (kkk = 0; kkk < staff.voices[staff.voices.length - 1].length; kkk++) {
                    staff.voices[staff.voices.length - 1][kkk] = parseCommon.clone(staff.voices[staff.voices.length - 1][kkk]);
                    var el = staff.voices[staff.voices.length - 1][kkk];
                    if (el.el_type === "bar" && el.startEnding) {
                      delete el.startEnding;
                    }
                    if (el.el_type === "bar" && el.endEnding)
                      delete el.endEnding;
                  }
                }
              }
            }
          }
        }
        return madeChanges;
      };
      function findLastBar(voice, start) {
        for (var i = start - 1; i > 0 && voice[i].el_type !== "bar"; i--) {
        }
        return i;
      }
      function fixTitles(lines) {
        var firstMusicLine = true;
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i];
          if (line.staff) {
            for (var j = 0; j < line.staff.length; j++) {
              var staff = line.staff[j];
              if (staff.title) {
                var hasATitle = false;
                for (var k = 0; k < staff.title.length; k++) {
                  if (staff.title[k]) {
                    staff.title[k] = firstMusicLine ? staff.title[k].name : staff.title[k].subname;
                    if (staff.title[k])
                      hasATitle = true;
                    else
                      staff.title[k] = "";
                  } else
                    staff.title[k] = "";
                }
                if (!hasATitle)
                  delete staff.title;
              }
            }
            firstMusicLine = false;
          }
        }
      }
      this.cleanUp = function(barsperstaff, staffnonote, currSlur) {
        this.closeLine();
        delete tune.runningFonts;
        if (tune.metaText.tempo && tune.metaText.tempo.bpm && !tune.metaText.tempo.duration)
          tune.metaText.tempo.duration = [tune.getBeatLength()];
        var anyDeleted = false;
        var i, s, v;
        for (i = 0; i < tune.lines.length; i++) {
          if (tune.lines[i].staff !== void 0) {
            var hasAny = false;
            for (s = 0; s < tune.lines[i].staff.length; s++) {
              if (tune.lines[i].staff[s] === void 0) {
                anyDeleted = true;
                tune.lines[i].staff[s] = null;
              } else {
                for (v = 0; v < tune.lines[i].staff[s].voices.length; v++) {
                  if (tune.lines[i].staff[s].voices[v] === void 0)
                    tune.lines[i].staff[s].voices[v] = [];
                  else if (this.containsNotes(tune.lines[i].staff[s].voices[v]))
                    hasAny = true;
                }
              }
            }
            if (!hasAny) {
              tune.lines[i] = null;
              anyDeleted = true;
            }
          }
        }
        if (anyDeleted) {
          tune.lines = parseCommon.compact(tune.lines);
          parseCommon.each(tune.lines, function(line) {
            if (line.staff)
              line.staff = parseCommon.compact(line.staff);
          });
        }
        if (barsperstaff) {
          while (wrapMusicLines(tune.lines, barsperstaff)) {
          }
        }
        if (staffnonote) {
          anyDeleted = false;
          for (i = 0; i < tune.lines.length; i++) {
            if (tune.lines[i].staff !== void 0) {
              for (s = 0; s < tune.lines[i].staff.length; s++) {
                var keepThis = false;
                for (v = 0; v < tune.lines[i].staff[s].voices.length; v++) {
                  if (this.containsNotesStrict(tune.lines[i].staff[s].voices[v])) {
                    keepThis = true;
                  }
                }
                if (!keepThis) {
                  anyDeleted = true;
                  tune.lines[i].staff[s] = null;
                }
              }
            }
          }
          if (anyDeleted) {
            parseCommon.each(tune.lines, function(line) {
              if (line.staff)
                line.staff = parseCommon.compact(line.staff);
            });
          }
        }
        fixTitles(tune.lines);
        for (i = 0; i < tune.lines.length; i++) {
          if (tune.lines[i].staff) {
            for (s = 0; s < tune.lines[i].staff.length; s++)
              delete tune.lines[i].staff[s].workingClef;
          }
        }
        while (this.resolveOverlays()) {
        }
        function cleanUpSlursInLine(line, staffNum, voiceNum) {
          if (!currSlur[staffNum])
            currSlur[staffNum] = [];
          if (!currSlur[staffNum][voiceNum])
            currSlur[staffNum][voiceNum] = [];
          var x;
          var addEndSlur = function(obj, num, chordPos) {
            if (currSlur[staffNum][voiceNum][chordPos] === void 0) {
              for (x = 0; x < currSlur[staffNum][voiceNum].length; x++) {
                if (currSlur[staffNum][voiceNum][x] !== void 0) {
                  chordPos = x;
                  break;
                }
              }
              if (currSlur[staffNum][voiceNum][chordPos] === void 0) {
                var offNum = chordPos * 100 + 1;
                parseCommon.each(obj.endSlur, function(x2) {
                  if (offNum === x2)
                    --offNum;
                });
                currSlur[staffNum][voiceNum][chordPos] = [offNum];
              }
            }
            var slurNum2;
            for (var i3 = 0; i3 < num; i3++) {
              slurNum2 = currSlur[staffNum][voiceNum][chordPos].pop();
              obj.endSlur.push(slurNum2);
            }
            if (currSlur[staffNum][voiceNum][chordPos].length === 0)
              delete currSlur[staffNum][voiceNum][chordPos];
            return slurNum2;
          };
          var addStartSlur = function(obj, num, chordPos, usedNums2) {
            obj.startSlur = [];
            if (currSlur[staffNum][voiceNum][chordPos] === void 0) {
              currSlur[staffNum][voiceNum][chordPos] = [];
            }
            var nextNum = chordPos * 100 + 1;
            for (var i3 = 0; i3 < num; i3++) {
              if (usedNums2) {
                parseCommon.each(usedNums2, function(x2) {
                  if (nextNum === x2)
                    ++nextNum;
                });
                parseCommon.each(usedNums2, function(x2) {
                  if (nextNum === x2)
                    ++nextNum;
                });
                parseCommon.each(usedNums2, function(x2) {
                  if (nextNum === x2)
                    ++nextNum;
                });
              }
              parseCommon.each(currSlur[staffNum][voiceNum][chordPos], function(x2) {
                if (nextNum === x2)
                  ++nextNum;
              });
              parseCommon.each(currSlur[staffNum][voiceNum][chordPos], function(x2) {
                if (nextNum === x2)
                  ++nextNum;
              });
              currSlur[staffNum][voiceNum][chordPos].push(nextNum);
              obj.startSlur.push({ label: nextNum });
              if (obj.dottedSlur) {
                obj.startSlur[obj.startSlur.length - 1].style = "dotted";
                delete obj.dottedSlur;
              }
              nextNum++;
            }
          };
          for (var i2 = 0; i2 < line.length; i2++) {
            var el = line[i2];
            if (el.el_type === "note") {
              if (el.gracenotes) {
                for (var g = 0; g < el.gracenotes.length; g++) {
                  if (el.gracenotes[g].endSlur) {
                    var gg = el.gracenotes[g].endSlur;
                    el.gracenotes[g].endSlur = [];
                    for (var ggg = 0; ggg < gg; ggg++)
                      addEndSlur(el.gracenotes[g], 1, 20);
                  }
                  if (el.gracenotes[g].startSlur) {
                    x = el.gracenotes[g].startSlur;
                    addStartSlur(el.gracenotes[g], x, 20);
                  }
                }
              }
              if (el.endSlur) {
                x = el.endSlur;
                el.endSlur = [];
                addEndSlur(el, x, 0);
              }
              if (el.startSlur) {
                x = el.startSlur;
                addStartSlur(el, x, 0);
              }
              if (el.pitches) {
                var usedNums = [];
                for (var p = 0; p < el.pitches.length; p++) {
                  if (el.pitches[p].endSlur) {
                    var k = el.pitches[p].endSlur;
                    el.pitches[p].endSlur = [];
                    for (var j2 = 0; j2 < k; j2++) {
                      var slurNum = addEndSlur(el.pitches[p], 1, p + 1);
                      usedNums.push(slurNum);
                    }
                  }
                }
                for (p = 0; p < el.pitches.length; p++) {
                  if (el.pitches[p].startSlur) {
                    x = el.pitches[p].startSlur;
                    addStartSlur(el.pitches[p], x, p + 1, usedNums);
                  }
                }
                if (el.gracenotes && el.pitches[0].endSlur && el.pitches[0].endSlur[0] === 100 && el.pitches[0].startSlur) {
                  if (el.gracenotes[0].endSlur)
                    el.gracenotes[0].endSlur.push(el.pitches[0].startSlur[0].label);
                  else
                    el.gracenotes[0].endSlur = [el.pitches[0].startSlur[0].label];
                  if (el.pitches[0].endSlur.length === 1)
                    delete el.pitches[0].endSlur;
                  else if (el.pitches[0].endSlur[0] === 100)
                    el.pitches[0].endSlur.shift();
                  else if (el.pitches[0].endSlur[el.pitches[0].endSlur.length - 1] === 100)
                    el.pitches[0].endSlur.pop();
                  if (currSlur[staffNum][voiceNum][1].length === 1)
                    delete currSlur[staffNum][voiceNum][1];
                  else
                    currSlur[staffNum][voiceNum][1].pop();
                }
              }
            }
          }
        }
        function fixClefPlacement(el) {
          parseKeyVoice.fixClef(el);
        }
        function wrapMusicLines(lines, barsperstaff2) {
          for (i = 0; i < lines.length; i++) {
            if (lines[i].staff !== void 0) {
              for (s = 0; s < lines[i].staff.length; s++) {
                var permanentItems = [];
                for (v = 0; v < lines[i].staff[s].voices.length; v++) {
                  var voice2 = lines[i].staff[s].voices[v];
                  var barNumThisLine = 0;
                  for (var n = 0; n < voice2.length; n++) {
                    if (voice2[n].el_type === "bar") {
                      barNumThisLine++;
                      if (barNumThisLine >= barsperstaff2) {
                        if (n < voice2.length - 1) {
                          var nextLine2 = getNextMusicLine(lines, i);
                          if (!nextLine2) {
                            var cp = JSON.parse(JSON.stringify(lines[i]));
                            lines.push(parseCommon.clone(cp));
                            nextLine2 = lines[lines.length - 1];
                            for (var ss = 0; ss < nextLine2.staff.length; ss++) {
                              for (var vv = 0; vv < nextLine2.staff[ss].voices.length; vv++)
                                nextLine2.staff[ss].voices[vv] = [];
                            }
                          }
                          var startElement = n + 1;
                          var section = lines[i].staff[s].voices[v].slice(startElement);
                          lines[i].staff[s].voices[v] = lines[i].staff[s].voices[v].slice(0, startElement);
                          nextLine2.staff[s].voices[v] = permanentItems.concat(section.concat(nextLine2.staff[s].voices[v]));
                          return true;
                        }
                      }
                    } else if (!voice2[n].duration) {
                      permanentItems.push(voice2[n]);
                    }
                  }
                }
              }
            }
          }
          return false;
        }
        function getNextMusicLine(lines, currentLine) {
          currentLine++;
          while (lines.length > currentLine) {
            if (lines[currentLine].staff)
              return lines[currentLine];
            currentLine++;
          }
          return null;
        }
        for (tune.lineNum = 0; tune.lineNum < tune.lines.length; tune.lineNum++) {
          var staff = tune.lines[tune.lineNum].staff;
          if (staff) {
            for (tune.staffNum = 0; tune.staffNum < staff.length; tune.staffNum++) {
              if (staff[tune.staffNum].clef)
                fixClefPlacement(staff[tune.staffNum].clef);
              for (tune.voiceNum = 0; tune.voiceNum < staff[tune.staffNum].voices.length; tune.voiceNum++) {
                var voice = staff[tune.staffNum].voices[tune.voiceNum];
                cleanUpSlursInLine(voice, tune.staffNum, tune.voiceNum);
                for (var j = 0; j < voice.length; j++) {
                  if (voice[j].el_type === "clef")
                    fixClefPlacement(voice[j]);
                }
                if (voice.length > 0 && voice[voice.length - 1].barNumber) {
                  var nextLine = getNextMusicLine(tune.lines, tune.lineNum);
                  if (nextLine)
                    nextLine.staff[0].barNumber = voice[voice.length - 1].barNumber;
                  delete voice[voice.length - 1].barNumber;
                }
              }
            }
          }
        }
        delete tune.staffNum;
        delete tune.voiceNum;
        delete tune.lineNum;
        delete tune.potentialStartBeam;
        delete tune.potentialEndBeam;
        delete tune.vskipPending;
        return currSlur;
      };
      tune.reset();
      this.getLastNote = function() {
        if (tune.lines[tune.lineNum] && tune.lines[tune.lineNum].staff && tune.lines[tune.lineNum].staff[tune.staffNum] && tune.lines[tune.lineNum].staff[tune.staffNum].voices[tune.voiceNum]) {
          for (var i = tune.lines[tune.lineNum].staff[tune.staffNum].voices[tune.voiceNum].length - 1; i >= 0; i--) {
            var el = tune.lines[tune.lineNum].staff[tune.staffNum].voices[tune.voiceNum][i];
            if (el.el_type === "note") {
              return el;
            }
          }
        }
        return null;
      };
      this.addTieToLastNote = function(dottedTie) {
        var el = this.getLastNote();
        if (el && el.pitches && el.pitches.length > 0) {
          el.pitches[0].startTie = {};
          if (dottedTie)
            el.pitches[0].startTie.style = "dotted";
          return true;
        }
        return false;
      };
      this.getDuration = function(el) {
        if (el.duration)
          return el.duration;
        return 0;
      };
      this.closeLine = function() {
        if (tune.potentialStartBeam && tune.potentialEndBeam) {
          tune.potentialStartBeam.startBeam = true;
          tune.potentialEndBeam.endBeam = true;
        }
        delete tune.potentialStartBeam;
        delete tune.potentialEndBeam;
      };
      this.appendElement = function(type, startChar, endChar, hashParams) {
        var This = tune;
        var pushNote = function(hp) {
          var currStaff = This.lines[This.lineNum].staff[This.staffNum];
          if (!currStaff) {
            return;
          }
          if (hp.pitches !== void 0) {
            var mid = currStaff.workingClef.verticalPos;
            parseCommon.each(hp.pitches, function(p) {
              p.verticalPos = p.pitch - mid;
            });
          }
          if (hp.gracenotes !== void 0) {
            var mid2 = currStaff.workingClef.verticalPos;
            parseCommon.each(hp.gracenotes, function(p) {
              p.verticalPos = p.pitch - mid2;
            });
          }
          currStaff.voices[This.voiceNum].push(hp);
        };
        hashParams.el_type = type;
        if (startChar !== null)
          hashParams.startChar = startChar;
        if (endChar !== null)
          hashParams.endChar = endChar;
        var endBeamHere = function() {
          This.potentialStartBeam.startBeam = true;
          hashParams.endBeam = true;
          delete This.potentialStartBeam;
          delete This.potentialEndBeam;
        };
        var endBeamLast = function() {
          if (This.potentialStartBeam !== void 0 && This.potentialEndBeam !== void 0) {
            This.potentialStartBeam.startBeam = true;
            This.potentialEndBeam.endBeam = true;
          }
          delete This.potentialStartBeam;
          delete This.potentialEndBeam;
        };
        if (type === "note") {
          var dur = self.getDuration(hashParams);
          if (dur >= 0.25) {
            endBeamLast();
          } else if (hashParams.force_end_beam_last && This.potentialStartBeam !== void 0) {
            endBeamLast();
          } else if (hashParams.end_beam && This.potentialStartBeam !== void 0) {
            if (hashParams.rest === void 0)
              endBeamHere();
            else
              endBeamLast();
          } else if (hashParams.rest === void 0) {
            if (This.potentialStartBeam === void 0) {
              if (!hashParams.end_beam) {
                This.potentialStartBeam = hashParams;
                delete This.potentialEndBeam;
              }
            } else {
              This.potentialEndBeam = hashParams;
            }
          }
        } else {
          endBeamLast();
        }
        delete hashParams.end_beam;
        delete hashParams.force_end_beam_last;
        pushNote(hashParams);
      };
      this.appendStartingElement = function(type, startChar, endChar, hashParams2) {
        this.closeLine();
        var impliedNaturals;
        if (type === "key") {
          impliedNaturals = hashParams2.impliedNaturals;
          delete hashParams2.impliedNaturals;
          delete hashParams2.explicitAccidentals;
        }
        var hashParams = parseCommon.clone(hashParams2);
        if (tune.lines[tune.lineNum] && tune.lines[tune.lineNum].staff) {
          if (tune.lines[tune.lineNum].staff.length <= tune.staffNum) {
            tune.lines[tune.lineNum].staff[tune.staffNum] = {};
            tune.lines[tune.lineNum].staff[tune.staffNum].clef = parseCommon.clone(tune.lines[tune.lineNum].staff[0].clef);
            tune.lines[tune.lineNum].staff[tune.staffNum].key = parseCommon.clone(tune.lines[tune.lineNum].staff[0].key);
            if (tune.lines[tune.lineNum].staff[0].meter)
              tune.lines[tune.lineNum].staff[tune.staffNum].meter = parseCommon.clone(tune.lines[tune.lineNum].staff[0].meter);
            tune.lines[tune.lineNum].staff[tune.staffNum].workingClef = parseCommon.clone(tune.lines[tune.lineNum].staff[0].workingClef);
            tune.lines[tune.lineNum].staff[tune.staffNum].voices = [[]];
          }
          if (type === "clef") {
            tune.lines[tune.lineNum].staff[tune.staffNum].workingClef = hashParams;
          }
          var voice = tune.lines[tune.lineNum].staff[tune.staffNum].voices[tune.voiceNum];
          for (var i = 0; i < voice.length; i++) {
            if (voice[i].el_type === "note" || voice[i].el_type === "bar") {
              hashParams.el_type = type;
              hashParams.startChar = startChar;
              hashParams.endChar = endChar;
              if (impliedNaturals)
                hashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);
              voice.push(hashParams);
              return;
            }
            if (voice[i].el_type === type) {
              hashParams.el_type = type;
              hashParams.startChar = startChar;
              hashParams.endChar = endChar;
              if (impliedNaturals)
                hashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);
              voice[i] = hashParams;
              return;
            }
          }
          tune.lines[tune.lineNum].staff[tune.staffNum][type] = hashParams2;
        }
      };
      this.pushLine = function(hash) {
        if (tune.vskipPending) {
          hash.vskip = tune.vskipPending;
          delete tune.vskipPending;
        }
        tune.lines.push(hash);
      };
      this.addSubtitle = function(str, info) {
        this.pushLine({ subtitle: { text: str, startChar: info.startChar, endChar: info.endChar } });
      };
      this.addSpacing = function(num) {
        tune.vskipPending = num;
      };
      this.addNewPage = function(num) {
        this.pushLine({ newpage: num });
      };
      this.addSeparator = function(spaceAbove, spaceBelow, lineLength, info) {
        this.pushLine({ separator: { spaceAbove: Math.round(spaceAbove), spaceBelow: Math.round(spaceBelow), lineLength: Math.round(lineLength), startChar: info.startChar, endChar: info.endChar } });
      };
      this.addText = function(str, info) {
        this.pushLine({ text: { text: str, startChar: info.startChar, endChar: info.endChar } });
      };
      this.addCentered = function(str) {
        this.pushLine({ text: [{ text: str, center: true }] });
      };
      this.containsNotes = function(voice) {
        for (var i = 0; i < voice.length; i++) {
          if (voice[i].el_type === "note" || voice[i].el_type === "bar")
            return true;
        }
        return false;
      };
      this.containsNotesStrict = function(voice) {
        for (var i = 0; i < voice.length; i++) {
          if (voice[i].el_type === "note" && (voice[i].rest === void 0 || voice[i].chord !== void 0))
            return true;
        }
        return false;
      };
      this.changeVoiceScale = function(scale) {
        self.appendElement("scale", null, null, { size: scale });
      };
      this.startNewLine = function(params) {
        var This = tune;
        this.closeLine();
        var createVoice = function(params2) {
          var thisStaff = This.lines[This.lineNum].staff[This.staffNum];
          thisStaff.voices[This.voiceNum] = [];
          if (!thisStaff.title)
            thisStaff.title = [];
          thisStaff.title[This.voiceNum] = { name: params2.name, subname: params2.subname };
          if (params2.style)
            self.appendElement("style", null, null, { head: params2.style });
          if (params2.stem)
            self.appendElement("stem", null, null, { direction: params2.stem });
          else if (This.voiceNum > 0) {
            if (thisStaff.voices[0] !== void 0) {
              var found = false;
              for (var i = 0; i < thisStaff.voices[0].length; i++) {
                if (thisStaff.voices[0].el_type === "stem")
                  found = true;
              }
              if (!found) {
                var stem = { el_type: "stem", direction: "up" };
                thisStaff.voices[0].splice(0, 0, stem);
              }
            }
            self.appendElement("stem", null, null, { direction: "down" });
          }
          if (params2.scale)
            self.appendElement("scale", null, null, { size: params2.scale });
        };
        var createStaff = function(params2) {
          if (params2.key && params2.key.impliedNaturals) {
            params2.key.accidentals = params2.key.accidentals.concat(params2.key.impliedNaturals);
            delete params2.key.impliedNaturals;
          }
          This.lines[This.lineNum].staff[This.staffNum] = { voices: [], clef: params2.clef, key: params2.key, workingClef: params2.clef };
          if (params2.stafflines !== void 0) {
            This.lines[This.lineNum].staff[This.staffNum].clef.stafflines = params2.stafflines;
            This.lines[This.lineNum].staff[This.staffNum].workingClef.stafflines = params2.stafflines;
          }
          if (params2.staffscale) {
            This.lines[This.lineNum].staff[This.staffNum].staffscale = params2.staffscale;
          }
          if (params2.annotationfont)
            self.setLineFont("annotationfont", params2.annotationfont);
          if (params2.gchordfont)
            self.setLineFont("gchordfont", params2.gchordfont);
          if (params2.tripletfont)
            self.setLineFont("tripletfont", params2.tripletfont);
          if (params2.vocalfont)
            self.setLineFont("vocalfont", params2.vocalfont);
          if (params2.bracket)
            This.lines[This.lineNum].staff[This.staffNum].bracket = params2.bracket;
          if (params2.brace)
            This.lines[This.lineNum].staff[This.staffNum].brace = params2.brace;
          if (params2.connectBarLines)
            This.lines[This.lineNum].staff[This.staffNum].connectBarLines = params2.connectBarLines;
          if (params2.barNumber)
            This.lines[This.lineNum].staff[This.staffNum].barNumber = params2.barNumber;
          createVoice(params2);
          if (params2.part)
            self.appendElement("part", params2.part.startChar, params2.part.endChar, { title: params2.part.title });
          if (params2.meter !== void 0)
            This.lines[This.lineNum].staff[This.staffNum].meter = params2.meter;
          if (This.vskipPending) {
            This.lines[This.lineNum].vskip = This.vskipPending;
            delete This.vskipPending;
          }
        };
        var createLine = function(params2) {
          This.lines[This.lineNum] = { staff: [] };
          createStaff(params2);
        };
        if (tune.lines[tune.lineNum] === void 0)
          createLine(params);
        else if (tune.lines[tune.lineNum].staff === void 0) {
          tune.lineNum++;
          this.startNewLine(params);
        } else if (tune.lines[tune.lineNum].staff[tune.staffNum] === void 0)
          createStaff(params);
        else if (tune.lines[tune.lineNum].staff[tune.staffNum].voices[tune.voiceNum] === void 0)
          createVoice(params);
        else if (!this.containsNotes(tune.lines[tune.lineNum].staff[tune.staffNum].voices[tune.voiceNum])) {
          if (params.part)
            self.appendElement("part", params.part.startChar, params.part.endChar, { title: params.part.title });
        } else {
          tune.lineNum++;
          this.startNewLine(params);
        }
      };
      this.setRunningFont = function(type, font) {
        tune.runningFonts[type] = font;
      };
      this.setLineFont = function(type, font) {
        if (tune.runningFonts[type]) {
          var isDifferent = false;
          var keys = Object.keys(font);
          for (var i = 0; i < keys.length; i++) {
            if (tune.runningFonts[type][keys[i]] !== font[keys[i]])
              isDifferent = true;
          }
          if (isDifferent) {
            tune.lines[tune.lineNum].staff[tune.staffNum][type] = font;
          }
        }
        tune.runningFonts[type] = font;
      };
      this.setBarNumberImmediate = function(barNumber) {
        var currentVoice = this.getCurrentVoice();
        if (currentVoice && currentVoice.length > 0) {
          var lastElement = currentVoice[currentVoice.length - 1];
          if (lastElement.el_type === "bar") {
            if (lastElement.barNumber !== void 0)
              lastElement.barNumber = barNumber;
          } else
            return barNumber - 1;
        }
        return barNumber;
      };
      this.hasBeginMusic = function() {
        for (var i = 0; i < tune.lines.length; i++) {
          if (tune.lines[i].staff)
            return true;
        }
        return false;
      };
      this.isFirstLine = function(index) {
        for (var i = index - 1; i >= 0; i--) {
          if (tune.lines[i].staff !== void 0)
            return false;
        }
        return true;
      };
      this.getCurrentVoice = function() {
        var currLine = tune.lines[tune.lineNum];
        if (!currLine)
          return null;
        var currStaff = currLine.staff[tune.staffNum];
        if (!currStaff)
          return null;
        if (currStaff.voices[tune.voiceNum] !== void 0)
          return currStaff.voices[tune.voiceNum];
        else
          return null;
      };
      this.setCurrentVoice = function(staffNum, voiceNum) {
        tune.staffNum = staffNum;
        tune.voiceNum = voiceNum;
        for (var i = 0; i < tune.lines.length; i++) {
          if (tune.lines[i].staff) {
            if (tune.lines[i].staff[staffNum] === void 0 || tune.lines[i].staff[staffNum].voices[voiceNum] === void 0 || !this.containsNotes(tune.lines[i].staff[staffNum].voices[voiceNum])) {
              tune.lineNum = i;
              return;
            }
          }
        }
        tune.lineNum = i;
      };
      this.addMetaText = function(key, value, info) {
        if (tune.metaText[key] === void 0) {
          tune.metaText[key] = value;
          tune.metaTextInfo[key] = info;
        } else {
          tune.metaText[key] += "\n" + value;
          tune.metaTextInfo[key].endChar = info.endChar;
        }
      };
      this.addMetaTextArray = function(key, value, info) {
        if (tune.metaText[key] === void 0) {
          tune.metaText[key] = [value];
          tune.metaTextInfo[key] = info;
        } else {
          tune.metaText[key].push(value);
          tune.metaTextInfo[key].endChar = info.endChar;
        }
      };
      this.addMetaTextObj = function(key, value, info) {
        tune.metaText[key] = value;
        tune.metaTextInfo[key] = info;
      };
    };
    module.exports = TuneBuilder;
  }
});

// node_modules/abcjs/src/parse/abc_parse.js
var require_abc_parse = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseDirective = require_abc_parse_directive();
    var ParseHeader = require_abc_parse_header();
    var ParseMusic = require_abc_parse_music();
    var Tokenizer = require_abc_tokenizer();
    var wrap = require_wrap_lines();
    var Tune = require_abc_tune();
    var TuneBuilder = require_tune_builder();
    var Parse = function() {
      "use strict";
      var tune = new Tune();
      var tuneBuilder = new TuneBuilder(tune);
      var tokenizer;
      var wordsContinuation = "";
      var symbolContinuation = "";
      this.getTune = function() {
        var t = {
          formatting: tune.formatting,
          lines: tune.lines,
          media: tune.media,
          metaText: tune.metaText,
          metaTextInfo: tune.metaTextInfo,
          version: tune.version,
          addElementToEvents: tune.addElementToEvents,
          addUsefulCallbackInfo: tune.addUsefulCallbackInfo,
          getTotalTime: tune.getTotalTime,
          getTotalBeats: tune.getTotalBeats,
          getBarLength: tune.getBarLength,
          getBeatLength: tune.getBeatLength,
          getBeatsPerMeasure: tune.getBeatsPerMeasure,
          getBpm: tune.getBpm,
          getMeter: tune.getMeter,
          getMeterFraction: tune.getMeterFraction,
          getPickupLength: tune.getPickupLength,
          getKeySignature: tune.getKeySignature,
          getElementFromChar: tune.getElementFromChar,
          makeVoicesArray: tune.makeVoicesArray,
          millisecondsPerMeasure: tune.millisecondsPerMeasure,
          setupEvents: tune.setupEvents,
          setTiming: tune.setTiming,
          setUpAudio: tune.setUpAudio,
          deline: tune.deline
        };
        if (tune.lineBreaks)
          t.lineBreaks = tune.lineBreaks;
        if (tune.visualTranspose)
          t.visualTranspose = tune.visualTranspose;
        return t;
      };
      function addPositioning(el, type, value) {
        if (!el.positioning)
          el.positioning = {};
        el.positioning[type] = value;
      }
      function addFont(el, type, value) {
        if (!el.fonts)
          el.fonts = {};
        el.fonts[type] = value;
      }
      var multilineVars = {
        reset: function() {
          for (var property in this) {
            if (this.hasOwnProperty(property) && typeof this[property] !== "function") {
              delete this[property];
            }
          }
          this.iChar = 0;
          this.key = { accidentals: [], root: "none", acc: "", mode: "" };
          this.meter = null;
          this.origMeter = null;
          this.hasMainTitle = false;
          this.default_length = 0.125;
          this.clef = { type: "treble", verticalPos: 0 };
          this.next_note_duration = 0;
          this.start_new_line = true;
          this.is_in_header = true;
          this.partForNextLine = {};
          this.tempoForNextLine = [];
          this.havent_set_length = true;
          this.voices = {};
          this.staves = [];
          this.macros = {};
          this.currBarNumber = 1;
          this.barCounter = {};
          this.ignoredDecorations = [];
          this.score_is_present = false;
          this.inEnding = false;
          this.inTie = [];
          this.inTieChord = {};
          this.vocalPosition = "auto";
          this.dynamicPosition = "auto";
          this.chordPosition = "auto";
          this.ornamentPosition = "auto";
          this.volumePosition = "auto";
          this.openSlurs = [];
          this.freegchord = false;
          this.endingHoldOver = {};
        },
        differentFont: function(type, defaultFonts) {
          if (this[type].decoration !== defaultFonts[type].decoration)
            return true;
          if (this[type].face !== defaultFonts[type].face)
            return true;
          if (this[type].size !== defaultFonts[type].size)
            return true;
          if (this[type].style !== defaultFonts[type].style)
            return true;
          if (this[type].weight !== defaultFonts[type].weight)
            return true;
          return false;
        },
        addFormattingOptions: function(el, defaultFonts, elType) {
          if (elType === "note") {
            if (this.vocalPosition !== "auto")
              addPositioning(el, "vocalPosition", this.vocalPosition);
            if (this.dynamicPosition !== "auto")
              addPositioning(el, "dynamicPosition", this.dynamicPosition);
            if (this.chordPosition !== "auto")
              addPositioning(el, "chordPosition", this.chordPosition);
            if (this.ornamentPosition !== "auto")
              addPositioning(el, "ornamentPosition", this.ornamentPosition);
            if (this.volumePosition !== "auto")
              addPositioning(el, "volumePosition", this.volumePosition);
            if (this.differentFont("annotationfont", defaultFonts))
              addFont(el, "annotationfont", this.annotationfont);
            if (this.differentFont("gchordfont", defaultFonts))
              addFont(el, "gchordfont", this.gchordfont);
            if (this.differentFont("vocalfont", defaultFonts))
              addFont(el, "vocalfont", this.vocalfont);
            if (this.differentFont("tripletfont", defaultFonts))
              addFont(el, "tripletfont", this.tripletfont);
          } else if (elType === "bar") {
            if (this.dynamicPosition !== "auto")
              addPositioning(el, "dynamicPosition", this.dynamicPosition);
            if (this.chordPosition !== "auto")
              addPositioning(el, "chordPosition", this.chordPosition);
            if (this.ornamentPosition !== "auto")
              addPositioning(el, "ornamentPosition", this.ornamentPosition);
            if (this.volumePosition !== "auto")
              addPositioning(el, "volumePosition", this.volumePosition);
            if (this.differentFont("measurefont", defaultFonts))
              addFont(el, "measurefont", this.measurefont);
            if (this.differentFont("repeatfont", defaultFonts))
              addFont(el, "repeatfont", this.repeatfont);
          }
        },
        duplicateStartEndingHoldOvers: function() {
          this.endingHoldOver = {
            inTie: [],
            inTieChord: {}
          };
          for (var i = 0; i < this.inTie.length; i++) {
            this.endingHoldOver.inTie.push([]);
            if (this.inTie[i]) {
              for (var j = 0; j < this.inTie[i].length; j++) {
                this.endingHoldOver.inTie[i].push(this.inTie[i][j]);
              }
            }
          }
          for (var key in this.inTieChord) {
            if (this.inTieChord.hasOwnProperty(key))
              this.endingHoldOver.inTieChord[key] = this.inTieChord[key];
          }
        },
        restoreStartEndingHoldOvers: function() {
          if (!this.endingHoldOver.inTie)
            return;
          this.inTie = [];
          this.inTieChord = {};
          for (var i = 0; i < this.endingHoldOver.inTie.length; i++) {
            this.inTie.push([]);
            for (var j = 0; j < this.endingHoldOver.inTie[i].length; j++) {
              this.inTie[i].push(this.endingHoldOver.inTie[i][j]);
            }
          }
          for (var key in this.endingHoldOver.inTieChord) {
            if (this.endingHoldOver.inTieChord.hasOwnProperty(key))
              this.inTieChord[key] = this.endingHoldOver.inTieChord[key];
          }
        }
      };
      var addWarning = function(str) {
        if (!multilineVars.warnings)
          multilineVars.warnings = [];
        multilineVars.warnings.push(str);
      };
      var addWarningObject = function(warningObject) {
        if (!multilineVars.warningObjects)
          multilineVars.warningObjects = [];
        multilineVars.warningObjects.push(warningObject);
      };
      var encode = function(str) {
        var ret = parseCommon.gsub(str, "", " ");
        ret = parseCommon.gsub(ret, "&", "&amp;");
        ret = parseCommon.gsub(ret, "<", "&lt;");
        return parseCommon.gsub(ret, ">", "&gt;");
      };
      var warn = function(str, line, col_num) {
        if (!line)
          line = " ";
        var bad_char = line.charAt(col_num);
        if (bad_char === " ")
          bad_char = "SPACE";
        var clean_line = encode(line.substring(col_num - 64, col_num)) + '<span style="text-decoration:underline;font-size:1.3em;font-weight:bold;">' + bad_char + "</span>" + encode(line.substring(col_num + 1).substring(0, 64));
        addWarning("Music Line:" + tokenizer.lineIndex + ":" + (col_num + 1) + ": " + str + ":  " + clean_line);
        addWarningObject({ message: str, line, startChar: multilineVars.iChar + col_num, column: col_num });
      };
      var header;
      var music;
      this.getWarnings = function() {
        return multilineVars.warnings;
      };
      this.getWarningObjects = function() {
        return multilineVars.warningObjects;
      };
      var addWords = function(line, words) {
        if (words.indexOf("") >= 0) {
          wordsContinuation += words;
          return;
        }
        words = wordsContinuation + words;
        wordsContinuation = "";
        if (!line) {
          warn("Can't add words before the first line of music", line, 0);
          return;
        }
        words = parseCommon.strip(words);
        if (words.charAt(words.length - 1) !== "-")
          words = words + " ";
        var word_list = [];
        var last_divider = 0;
        var replace = false;
        var addWord = function(i2) {
          var word = parseCommon.strip(words.substring(last_divider, i2));
          last_divider = i2 + 1;
          if (word.length > 0) {
            if (replace)
              word = parseCommon.gsub(word, "~", " ");
            var div = words.charAt(i2);
            if (div !== "_" && div !== "-")
              div = " ";
            word_list.push({ syllable: tokenizer.translateString(word), divider: div });
            replace = false;
            return true;
          }
          return false;
        };
        for (var i = 0; i < words.length; i++) {
          switch (words.charAt(i)) {
            case " ":
            case "":
              addWord(i);
              break;
            case "-":
              if (!addWord(i) && word_list.length > 0) {
                parseCommon.last(word_list).divider = "-";
                word_list.push({ skip: true, to: "next" });
              }
              break;
            case "_":
              addWord(i);
              word_list.push({ skip: true, to: "slur" });
              break;
            case "*":
              addWord(i);
              word_list.push({ skip: true, to: "next" });
              break;
            case "|":
              addWord(i);
              word_list.push({ skip: true, to: "bar" });
              break;
            case "~":
              replace = true;
              break;
          }
        }
        var inSlur = false;
        parseCommon.each(line, function(el) {
          if (word_list.length !== 0) {
            if (word_list[0].skip) {
              switch (word_list[0].to) {
                case "next":
                  if (el.el_type === "note" && el.pitches !== null && !inSlur)
                    word_list.shift();
                  break;
                case "slur":
                  if (el.el_type === "note" && el.pitches !== null)
                    word_list.shift();
                  break;
                case "bar":
                  if (el.el_type === "bar")
                    word_list.shift();
                  break;
              }
              if (el.el_type !== "bar") {
                if (el.lyric === void 0)
                  el.lyric = [{ syllable: "", divider: " " }];
                else
                  el.lyric.push({ syllable: "", divider: " " });
              }
            } else {
              if (el.el_type === "note" && el.rest === void 0 && !inSlur) {
                var lyric = word_list.shift();
                if (lyric.syllable)
                  lyric.syllable = lyric.syllable.replace(/ +/g, "\xA0");
                if (el.lyric === void 0)
                  el.lyric = [lyric];
                else
                  el.lyric.push(lyric);
              }
            }
          }
        });
      };
      var addSymbols = function(line, words) {
        if (words.indexOf("") >= 0) {
          symbolContinuation += words;
          return;
        }
        words = symbolContinuation + words;
        symbolContinuation = "";
        if (!line) {
          warn("Can't add symbols before the first line of music", line, 0);
          return;
        }
        words = parseCommon.strip(words);
        if (words.charAt(words.length - 1) !== "-")
          words = words + " ";
        var word_list = [];
        var last_divider = 0;
        var replace = false;
        var addWord = function(i2) {
          var word = parseCommon.strip(words.substring(last_divider, i2));
          last_divider = i2 + 1;
          if (word.length > 0) {
            if (replace)
              word = parseCommon.gsub(word, "~", " ");
            var div = words.charAt(i2);
            if (div !== "_" && div !== "-")
              div = " ";
            word_list.push({ syllable: tokenizer.translateString(word), divider: div });
            replace = false;
            return true;
          }
          return false;
        };
        for (var i = 0; i < words.length; i++) {
          switch (words.charAt(i)) {
            case " ":
            case "":
              addWord(i);
              break;
            case "-":
              if (!addWord(i) && word_list.length > 0) {
                parseCommon.last(word_list).divider = "-";
                word_list.push({ skip: true, to: "next" });
              }
              break;
            case "_":
              addWord(i);
              word_list.push({ skip: true, to: "slur" });
              break;
            case "*":
              addWord(i);
              word_list.push({ skip: true, to: "next" });
              break;
            case "|":
              addWord(i);
              word_list.push({ skip: true, to: "bar" });
              break;
            case "~":
              replace = true;
              break;
          }
        }
        var inSlur = false;
        parseCommon.each(line, function(el) {
          if (word_list.length !== 0) {
            if (word_list[0].skip) {
              switch (word_list[0].to) {
                case "next":
                  if (el.el_type === "note" && el.pitches !== null && !inSlur)
                    word_list.shift();
                  break;
                case "slur":
                  if (el.el_type === "note" && el.pitches !== null)
                    word_list.shift();
                  break;
                case "bar":
                  if (el.el_type === "bar")
                    word_list.shift();
                  break;
              }
            } else {
              if (el.el_type === "note" && el.rest === void 0 && !inSlur) {
                var lyric = word_list.shift();
                if (el.lyric === void 0)
                  el.lyric = [lyric];
                else
                  el.lyric.push(lyric);
              }
            }
          }
        });
      };
      var parseLine = function(line) {
        if (parseCommon.startsWith(line, "%%")) {
          var err = parseDirective.addDirective(line.substring(2));
          if (err)
            warn(err, line, 2);
          return;
        }
        var i = line.indexOf("%");
        if (i >= 0)
          line = line.substring(0, i);
        line = line.replace(/\s+$/, "");
        if (line.length === 0)
          return;
        if (wordsContinuation) {
          addWords(tuneBuilder.getCurrentVoice(), line.substring(2));
          return;
        }
        if (symbolContinuation) {
          addSymbols(tuneBuilder.getCurrentVoice(), line.substring(2));
          return;
        }
        if (line.length < 2 || line.charAt(1) !== ":" || music.lineContinuation) {
          music.parseMusic(line);
          return;
        }
        var ret = header.parseHeader(line);
        if (ret.regular)
          music.parseMusic(line);
        if (ret.newline)
          music.startNewLine();
        if (ret.words)
          addWords(tuneBuilder.getCurrentVoice(), line.substring(2));
        if (ret.symbols)
          addSymbols(tuneBuilder.getCurrentVoice(), line.substring(2));
      };
      function appendLastMeasure(voice, nextVoice) {
        voice.push({
          el_type: "hint"
        });
        for (var i = 0; i < nextVoice.length; i++) {
          var element = nextVoice[i];
          var hint = parseCommon.clone(element);
          voice.push(hint);
          if (element.el_type === "bar")
            return;
        }
      }
      function addHintMeasure(staff, nextStaff) {
        for (var i = 0; i < staff.length; i++) {
          var stave = staff[i];
          var nextStave = nextStaff[i];
          if (nextStave) {
            for (var j = 0; j < nextStave.voices.length; j++) {
              var nextVoice = nextStave.voices[j];
              var voice = stave.voices[j];
              if (voice) {
                appendLastMeasure(voice, nextVoice);
              }
            }
          }
        }
      }
      function addHintMeasures() {
        for (var i = 0; i < tune.lines.length; i++) {
          var line = tune.lines[i].staff;
          if (line) {
            var j = i + 1;
            while (j < tune.lines.length && tune.lines[j].staff === void 0)
              j++;
            if (j < tune.lines.length) {
              var nextLine = tune.lines[j].staff;
              addHintMeasure(line, nextLine);
            }
          }
        }
      }
      this.parse = function(strTune, switches, startPos) {
        if (!switches)
          switches = {};
        if (!startPos)
          startPos = 0;
        tune.reset();
        strTune = strTune.replace(/\r\n?/g, "\n") + "\n";
        var arr = strTune.split("\n\\");
        if (arr.length > 1) {
          for (var i2 = 1; i2 < arr.length; i2++) {
            while (arr[i2].length > 0 && arr[i2][0] !== "\n") {
              arr[i2] = arr[i2].substr(1);
              arr[i2 - 1] += " ";
            }
          }
          strTune = arr.join("  ");
        }
        strTune = strTune.replace(/\\([ \t]*)(%.*)*\n/g, function(all, backslash, comment) {
          var padding = comment ? Array(comment.length + 1).join(" ") : "";
          return backslash + "" + padding + "\n";
        });
        var lines = strTune.split("\n");
        if (parseCommon.last(lines).length === 0)
          lines.pop();
        tokenizer = new Tokenizer(lines, multilineVars);
        header = new ParseHeader(tokenizer, warn, multilineVars, tune, tuneBuilder);
        music = new ParseMusic(tokenizer, warn, multilineVars, tune, tuneBuilder, header);
        if (switches.print)
          tune.media = "print";
        multilineVars.reset();
        multilineVars.iChar = startPos;
        if (switches.visualTranspose) {
          multilineVars.globalTranspose = parseInt(switches.visualTranspose);
          if (multilineVars.globalTranspose === 0)
            multilineVars.globalTranspose = void 0;
          else
            tuneBuilder.setVisualTranspose(switches.visualTranspose);
        } else
          multilineVars.globalTranspose = void 0;
        if (switches.lineBreaks) {
          multilineVars.lineBreaks = switches.lineBreaks;
        }
        header.reset(tokenizer, warn, multilineVars, tune);
        try {
          if (switches.format) {
            parseDirective.globalFormatting(switches.format);
          }
          var line = tokenizer.nextLine();
          while (line) {
            if (switches.header_only && multilineVars.is_in_header === false)
              throw "normal_abort";
            if (switches.stop_on_warning && multilineVars.warnings)
              throw "normal_abort";
            var wasInHeader = multilineVars.is_in_header;
            parseLine(line);
            if (wasInHeader && !multilineVars.is_in_header) {
              tuneBuilder.setRunningFont("annotationfont", multilineVars.annotationfont);
              tuneBuilder.setRunningFont("gchordfont", multilineVars.gchordfont);
              tuneBuilder.setRunningFont("tripletfont", multilineVars.tripletfont);
              tuneBuilder.setRunningFont("vocalfont", multilineVars.vocalfont);
            }
            line = tokenizer.nextLine();
          }
          if (wordsContinuation) {
            addWords(tuneBuilder.getCurrentVoice(), "");
          }
          if (symbolContinuation) {
            addSymbols(tuneBuilder.getCurrentVoice(), "");
          }
          multilineVars.openSlurs = tuneBuilder.cleanUp(multilineVars.barsperstaff, multilineVars.staffnonote, multilineVars.openSlurs);
        } catch (err) {
          if (err !== "normal_abort")
            throw err;
        }
        var ph = 11 * 72;
        var pl = 8.5 * 72;
        switch (multilineVars.papersize) {
          case "legal":
            ph = 14 * 72;
            pl = 8.5 * 72;
            break;
          case "A4":
            ph = 11.7 * 72;
            pl = 8.3 * 72;
            break;
        }
        if (multilineVars.landscape) {
          var x = ph;
          ph = pl;
          pl = x;
        }
        if (!tune.formatting.pagewidth)
          tune.formatting.pagewidth = pl;
        if (!tune.formatting.pageheight)
          tune.formatting.pageheight = ph;
        if (switches.hint_measures) {
          addHintMeasures();
        }
        wrap.wrapLines(tune, multilineVars.lineBreaks, multilineVars.barNumbers);
      };
    };
    module.exports = Parse;
  }
});

// node_modules/abcjs/src/parse/abc_parse_book.js
var require_abc_parse_book = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_book.js"(exports, module) {
    var parseCommon = require_abc_common();
    var bookParser = function(book) {
      "use strict";
      var directives = "";
      book = parseCommon.strip(book);
      var tuneStrings = book.split("\nX:");
      for (var i = 1; i < tuneStrings.length; i++)
        tuneStrings[i] = "X:" + tuneStrings[i];
      var pos = 0;
      var tunes = [];
      parseCommon.each(tuneStrings, function(tune) {
        tunes.push({ abc: tune, startPos: pos });
        pos += tune.length + 1;
      });
      if (tunes.length > 1 && !parseCommon.startsWith(tunes[0].abc, "X:")) {
        var dir = tunes.shift();
        var arrDir = dir.abc.split("\n");
        parseCommon.each(arrDir, function(line) {
          if (parseCommon.startsWith(line, "%%"))
            directives += line + "\n";
        });
      }
      var header = directives;
      parseCommon.each(tunes, function(tune) {
        var end = tune.abc.indexOf("\n\n");
        if (end > 0)
          tune.abc = tune.abc.substring(0, end);
        tune.pure = tune.abc;
        tune.abc = directives + tune.abc;
        tune.title = "";
        var title = tune.pure.split("T:");
        if (title.length > 1) {
          title = title[1].split("\n");
          tune.title = parseCommon.strip(title[0]);
        }
        var id = tune.pure.substring(2, tune.pure.indexOf("\n"));
        tune.id = parseCommon.strip(id);
      });
      return {
        header,
        tunes
      };
    };
    module.exports = bookParser;
  }
});

// node_modules/abcjs/src/tablatures/instruments/string-tablature.js
var require_string_tablature = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/string-tablature.js"(exports, module) {
    function StringTablature(numLines, lineSpace) {
      this.numLines = numLines;
      this.lineSpace = lineSpace;
      this.verticalSize = this.numLines * this.lineSpace;
      var pitch = 3;
      this.bar = {
        pitch,
        pitch2: lineSpace * numLines,
        height: 5
      };
    }
    StringTablature.prototype.bypass = function(line) {
      var voices = line.staffGroup.voices;
      if (voices.length > 0) {
        if (voices[0].isPercussion)
          return true;
      }
      return false;
    };
    StringTablature.prototype.setRelative = function(child, relative, first) {
      switch (child.type) {
        case "bar":
          relative.pitch = this.bar.pitch;
          relative.pitch2 = this.bar.pitch2;
          relative.height = this.height;
          break;
        case "symbol":
          var top = this.bar.pitch2 / 2;
          if (child.name == "dots.dot") {
            if (first) {
              relative.pitch = top;
              return false;
            } else {
              relative.pitch = top + this.lineSpace;
              return true;
            }
          }
          break;
      }
      return first;
    };
    module.exports = StringTablature;
  }
});

// node_modules/abcjs/src/tablatures/tab-common.js
var require_tab_common = __commonJS({
  "node_modules/abcjs/src/tablatures/tab-common.js"(exports, module) {
    function TabCommon(abcTune, tuneNumber, params) {
      this.tune = abcTune;
      this.params = params;
      this.tuneNumber = tuneNumber;
      this.inError = false;
    }
    TabCommon.prototype.setError = function(error) {
      var tune = this.tune;
      if (error) {
        this.error = error;
        this.inError = true;
        if (tune.warnings) {
          tune.warnings.push(error);
        } else {
          tune.warnings = [error];
        }
      }
    };
    module.exports = TabCommon;
  }
});

// node_modules/abcjs/src/write/abc_voice_element.js
var require_abc_voice_element = __commonJS({
  "node_modules/abcjs/src/write/abc_voice_element.js"(exports, module) {
    var VoiceElement = function VoiceElement2(voicenumber, voicetotal) {
      this.children = [];
      this.beams = [];
      this.otherchildren = [];
      this.w = 0;
      this.duplicate = false;
      this.voicenumber = voicenumber;
      this.voicetotal = voicetotal;
      this.bottom = 7;
      this.top = 7;
      this.specialY = {
        tempoHeightAbove: 0,
        partHeightAbove: 0,
        volumeHeightAbove: 0,
        dynamicHeightAbove: 0,
        endingHeightAbove: 0,
        chordHeightAbove: 0,
        lyricHeightAbove: 0,
        lyricHeightBelow: 0,
        chordHeightBelow: 0,
        volumeHeightBelow: 0,
        dynamicHeightBelow: 0
      };
    };
    VoiceElement.prototype.addChild = function(absElem) {
      if (absElem.type === "bar") {
        var firstItem = true;
        for (var i = 0; firstItem && i < this.children.length; i++) {
          if (this.children[i].type.indexOf("staff-extra") < 0 && this.children[i].type !== "tempo")
            firstItem = false;
        }
        if (!firstItem) {
          this.beams.push("bar");
          this.otherchildren.push("bar");
        }
      }
      this.children[this.children.length] = absElem;
      this.setRange(absElem);
    };
    VoiceElement.prototype.setLimit = function(member, child) {
      var specialY = child.specialY;
      if (!specialY)
        specialY = child;
      if (!specialY[member])
        return;
      if (!this.specialY[member])
        this.specialY[member] = specialY[member];
      else
        this.specialY[member] = Math.max(this.specialY[member], specialY[member]);
    };
    VoiceElement.prototype.adjustRange = function(child) {
      if (child.bottom !== void 0)
        this.bottom = Math.min(this.bottom, child.bottom);
      if (child.top !== void 0)
        this.top = Math.max(this.top, child.top);
    };
    VoiceElement.prototype.setRange = function(child) {
      this.adjustRange(child);
      this.setLimit("tempoHeightAbove", child);
      this.setLimit("partHeightAbove", child);
      this.setLimit("volumeHeightAbove", child);
      this.setLimit("dynamicHeightAbove", child);
      this.setLimit("endingHeightAbove", child);
      this.setLimit("chordHeightAbove", child);
      this.setLimit("lyricHeightAbove", child);
      this.setLimit("lyricHeightBelow", child);
      this.setLimit("chordHeightBelow", child);
      this.setLimit("volumeHeightBelow", child);
      this.setLimit("dynamicHeightBelow", child);
    };
    VoiceElement.prototype.addOther = function(child) {
      this.otherchildren.push(child);
      this.setRange(child);
    };
    VoiceElement.prototype.addBeam = function(child) {
      this.beams.push(child);
    };
    VoiceElement.prototype.setWidth = function(width) {
      this.w = width;
    };
    module.exports = VoiceElement;
  }
});

// node_modules/abcjs/src/write/set-class.js
var require_set_class = __commonJS({
  "node_modules/abcjs/src/write/set-class.js"(exports, module) {
    var setClass = function(elemset, addClass, removeClass, color) {
      if (!elemset)
        return;
      for (var i = 0; i < elemset.length; i++) {
        var el = elemset[i];
        var attr = el.getAttribute("highlight");
        if (!attr)
          attr = "fill";
        el.setAttribute(attr, color);
        var kls = el.getAttribute("class");
        if (!kls)
          kls = "";
        kls = kls.replace(removeClass, "");
        kls = kls.replace(addClass, "");
        if (addClass.length > 0) {
          if (kls.length > 0 && kls.charAt(kls.length - 1) !== " ")
            kls += " ";
          kls += addClass;
        }
        el.setAttribute("class", kls);
      }
    };
    module.exports = setClass;
  }
});

// node_modules/abcjs/src/write/highlight.js
var require_highlight = __commonJS({
  "node_modules/abcjs/src/write/highlight.js"(exports, module) {
    var setClass = require_set_class();
    var highlight = function(klass, color) {
      if (klass === void 0)
        klass = "abcjs-note_selected";
      if (color === void 0)
        color = "#ff0000";
      setClass(this.elemset, klass, "", color);
    };
    module.exports = highlight;
  }
});

// node_modules/abcjs/src/write/unhighlight.js
var require_unhighlight = __commonJS({
  "node_modules/abcjs/src/write/unhighlight.js"(exports, module) {
    var setClass = require_set_class();
    var unhighlight = function(klass, color) {
      if (klass === void 0)
        klass = "abcjs-note_selected";
      if (color === void 0)
        color = "#000000";
      setClass(this.elemset, "", klass, color);
    };
    module.exports = unhighlight;
  }
});

// node_modules/abcjs/src/write/abc_absolute_element.js
var require_abc_absolute_element = __commonJS({
  "node_modules/abcjs/src/write/abc_absolute_element.js"(exports, module) {
    var setClass = require_set_class();
    var highlight = require_highlight();
    var unhighlight = require_unhighlight();
    var AbsoluteElement = function AbsoluteElement2(abcelem, duration, minspacing, type, tuneNumber, options) {
      if (!options)
        options = {};
      this.tuneNumber = tuneNumber;
      this.abcelem = abcelem;
      this.duration = duration;
      this.durationClass = options.durationClassOveride ? options.durationClassOveride : this.duration;
      this.minspacing = minspacing || 0;
      this.x = 0;
      this.children = [];
      this.heads = [];
      this.extra = [];
      this.extraw = 0;
      this.w = 0;
      this.right = [];
      this.invisible = false;
      this.bottom = void 0;
      this.top = void 0;
      this.type = type;
      this.fixed = { w: 0, t: void 0, b: void 0 };
      this.specialY = {
        tempoHeightAbove: 0,
        partHeightAbove: 0,
        volumeHeightAbove: 0,
        dynamicHeightAbove: 0,
        endingHeightAbove: 0,
        chordHeightAbove: 0,
        lyricHeightAbove: 0,
        lyricHeightBelow: 0,
        chordHeightBelow: 0,
        volumeHeightBelow: 0,
        dynamicHeightBelow: 0
      };
    };
    AbsoluteElement.prototype.getFixedCoords = function() {
      return { x: this.x, w: this.fixed.w, t: this.fixed.t, b: this.fixed.b };
    };
    AbsoluteElement.prototype.addExtra = function(extra) {
      this.fixed.w = Math.max(this.fixed.w, extra.dx + extra.w);
      if (this.fixed.t === void 0)
        this.fixed.t = extra.top;
      else
        this.fixed.t = Math.max(this.fixed.t, extra.top);
      if (this.fixed.b === void 0)
        this.fixed.b = extra.bottom;
      else
        this.fixed.b = Math.min(this.fixed.b, extra.bottom);
      if (extra.dx < this.extraw)
        this.extraw = extra.dx;
      this.extra[this.extra.length] = extra;
      this._addChild(extra);
    };
    AbsoluteElement.prototype.addHead = function(head) {
      if (head.dx < this.extraw)
        this.extraw = head.dx;
      this.heads[this.heads.length] = head;
      this.addRight(head);
    };
    AbsoluteElement.prototype.addRight = function(right) {
      this.fixed.w = Math.max(this.fixed.w, right.dx + right.w);
      if (right.top !== void 0) {
        if (this.fixed.t === void 0)
          this.fixed.t = right.top;
        else
          this.fixed.t = Math.max(this.fixed.t, right.top);
      }
      if (right.bottom !== void 0) {
        if (this.fixed.b === void 0)
          this.fixed.b = right.bottom;
        else
          this.fixed.b = Math.min(this.fixed.b, right.bottom);
      }
      if (right.dx + right.w > this.w)
        this.w = right.dx + right.w;
      this.right[this.right.length] = right;
      this._addChild(right);
    };
    AbsoluteElement.prototype.addFixed = function(elem) {
      this._addChild(elem);
    };
    AbsoluteElement.prototype.addFixedX = function(elem) {
      this._addChild(elem);
    };
    AbsoluteElement.prototype.addCentered = function(elem) {
      var half = elem.w / 2;
      if (-half < this.extraw)
        this.extraw = -half;
      this.extra[this.extra.length] = elem;
      if (elem.dx + half > this.w)
        this.w = elem.dx + half;
      this.right[this.right.length] = elem;
      this._addChild(elem);
    };
    AbsoluteElement.prototype.setLimit = function(member, child) {
      if (!child[member])
        return;
      if (!this.specialY[member])
        this.specialY[member] = child[member];
      else
        this.specialY[member] = Math.max(this.specialY[member], child[member]);
    };
    AbsoluteElement.prototype._addChild = function(child) {
      child.parent = this;
      this.children[this.children.length] = child;
      this.pushTop(child.top);
      this.pushBottom(child.bottom);
      this.setLimit("tempoHeightAbove", child);
      this.setLimit("partHeightAbove", child);
      this.setLimit("volumeHeightAbove", child);
      this.setLimit("dynamicHeightAbove", child);
      this.setLimit("endingHeightAbove", child);
      this.setLimit("chordHeightAbove", child);
      this.setLimit("lyricHeightAbove", child);
      this.setLimit("lyricHeightBelow", child);
      this.setLimit("chordHeightBelow", child);
      this.setLimit("volumeHeightBelow", child);
      this.setLimit("dynamicHeightBelow", child);
    };
    AbsoluteElement.prototype.pushTop = function(top) {
      if (top !== void 0) {
        if (this.top === void 0)
          this.top = top;
        else
          this.top = Math.max(top, this.top);
      }
    };
    AbsoluteElement.prototype.pushBottom = function(bottom) {
      if (bottom !== void 0) {
        if (this.bottom === void 0)
          this.bottom = bottom;
        else
          this.bottom = Math.min(bottom, this.bottom);
      }
    };
    AbsoluteElement.prototype.setX = function(x) {
      this.x = x;
      for (var i = 0; i < this.children.length; i++)
        this.children[i].setX(x);
    };
    AbsoluteElement.prototype.center = function(before, after) {
      var midpoint = (after.x - before.x) / 2 + before.x;
      this.x = midpoint - this.w / 2;
      for (var k = 0; k < this.children.length; k++)
        this.children[k].setX(this.x);
    };
    AbsoluteElement.prototype.setHint = function() {
      this.hint = true;
    };
    AbsoluteElement.prototype.highlight = function(klass, color) {
      highlight.bind(this)(klass, color);
    };
    AbsoluteElement.prototype.unhighlight = function(klass, color) {
      unhighlight.bind(this)(klass, color);
    };
    module.exports = AbsoluteElement;
  }
});

// node_modules/abcjs/src/write/abc_relative_element.js
var require_abc_relative_element = __commonJS({
  "node_modules/abcjs/src/write/abc_relative_element.js"(exports, module) {
    var RelativeElement = function RelativeElement2(c, dx, w, pitch, opt) {
      opt = opt || {};
      this.x = 0;
      this.c = c;
      this.dx = dx;
      this.w = w;
      this.pitch = pitch;
      this.scalex = opt.scalex || 1;
      this.scaley = opt.scaley || 1;
      this.type = opt.type || "symbol";
      this.pitch2 = opt.pitch2;
      this.linewidth = opt.linewidth;
      this.klass = opt.klass;
      this.top = pitch;
      if (this.pitch2 !== void 0 && this.pitch2 > this.top)
        this.top = this.pitch2;
      this.bottom = pitch;
      if (this.pitch2 !== void 0 && this.pitch2 < this.bottom)
        this.bottom = this.pitch2;
      if (opt.thickness) {
        this.top += opt.thickness / 2;
        this.bottom -= opt.thickness / 2;
      }
      if (opt.stemHeight) {
        if (opt.stemHeight > 0)
          this.top += opt.stemHeight;
        else
          this.bottom += opt.stemHeight;
      }
      if (opt.dim)
        this.dim = opt.dim;
      if (opt.position)
        this.position = opt.position;
      this.height = opt.height ? opt.height : 4;
      if (opt.top)
        this.top = opt.top;
      if (opt.bottom)
        this.bottom = opt.bottom;
      if (opt.name)
        this.name = opt.name;
      else if (this.c)
        this.name = this.c;
      else
        this.name = this.type;
      if (opt.realWidth)
        this.realWidth = opt.realWidth;
      else
        this.realWidth = this.w;
      this.centerVertically = false;
      switch (this.type) {
        case "debug":
          this.chordHeightAbove = this.height;
          break;
        case "lyric":
          if (opt.position && opt.position === "below")
            this.lyricHeightBelow = this.height;
          else
            this.lyricHeightAbove = this.height;
          break;
        case "chord":
          if (opt.position && opt.position === "below")
            this.chordHeightBelow = this.height;
          else
            this.chordHeightAbove = this.height;
          break;
        case "text":
          if (this.pitch === void 0) {
            if (opt.position && opt.position === "below")
              this.chordHeightBelow = this.height;
            else
              this.chordHeightAbove = this.height;
          } else
            this.centerVertically = true;
          break;
        case "part":
          this.partHeightAbove = this.height;
          break;
      }
    };
    RelativeElement.prototype.getChordDim = function() {
      if (this.type === "debug")
        return null;
      if (!this.chordHeightAbove && !this.chordHeightBelow)
        return null;
      var margin = 0;
      var offset = this.type === "chord" ? this.realWidth / 2 : 0;
      var left = this.x - offset - margin;
      var right = left + this.realWidth + margin;
      return { left, right };
    };
    RelativeElement.prototype.invertLane = function(total) {
      if (this.lane === void 0)
        this.lane = 0;
      this.lane = total - this.lane - 1;
    };
    RelativeElement.prototype.putChordInLane = function(i) {
      this.lane = i;
      if (this.chordHeightAbove)
        this.chordHeightAbove = this.height * 1.25 * this.lane;
      else
        this.chordHeightBelow = this.height * 1.25 * this.lane;
    };
    RelativeElement.prototype.getLane = function() {
      if (this.lane === void 0)
        return 0;
      return this.lane;
    };
    RelativeElement.prototype.setX = function(x) {
      this.x = x + this.dx;
    };
    module.exports = RelativeElement;
  }
});

// node_modules/abcjs/src/tablatures/instruments/tab-note.js
var require_tab_note = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/tab-note.js"(exports, module) {
    var notes = ["A", "B", "C", "D", "E", "F", "G"];
    function TabNote(note) {
      var isFlat = false;
      var newNote = note;
      var isSharp = false;
      var isAltered = false;
      var natural = null;
      var quarter = null;
      var isDouble = false;
      var acc = 0;
      if (note.startsWith("_")) {
        isFlat = true;
        acc = -1;
        if (note[1] == "/") {
          isFlat = false;
          quarter = "v";
          acc = 0;
        } else if (note[1] == "_") {
          isDouble = true;
          acc -= 1;
        }
      } else if (note.startsWith("^")) {
        isSharp = true;
        acc = 1;
        if (note[1] == "/") {
          isSharp = false;
          quarter = "^";
          acc = 0;
        } else if (note[1] == "^") {
          isDouble = true;
          acc += 1;
        }
      } else if (note.startsWith("=")) {
        natural = true;
        acc = 0;
      }
      isAltered = isFlat || isSharp || quarter != null;
      if (isAltered || natural) {
        if (quarter != null || isDouble) {
          newNote = note.slice(2);
        } else {
          newNote = note.slice(1);
        }
      }
      var hasComma = (note.match(/,/g) || []).length;
      var hasQuote = (note.match(/'/g) || []).length;
      this.name = newNote;
      this.acc = acc;
      this.isSharp = isSharp;
      this.isKeySharp = false;
      this.isDouble = isDouble;
      this.isAltered = isAltered;
      this.isFlat = isFlat;
      this.isKeyFlat = false;
      this.natural = natural;
      this.quarter = quarter;
      this.isLower = this.name == this.name.toLowerCase();
      this.name = this.name[0].toUpperCase();
      this.hasComma = hasComma;
      this.isQuoted = hasQuote;
    }
    function cloneNote(self) {
      var newNote = self.name;
      var newTabNote = new TabNote(newNote);
      newTabNote.hasComma = self.hasComma;
      newTabNote.isLower = self.isLower;
      newTabNote.isQuoted = self.isQuoted;
      newTabNote.isSharp = self.isSharp;
      newTabNote.isKeySharp = self.isKeySharp;
      newTabNote.isFlat = self.isFlat;
      newTabNote.isKeyFlat = self.isKeyFlat;
      return newTabNote;
    }
    TabNote.prototype.sameNoteAs = function(note) {
      if (this.name == note.name && this.hasComma == note.hasComma && this.isLower == note.isLower && this.isQuoted == note.isQuoted && this.isSharp == note.isSharp && this.isFlat == note.isFlat) {
        return true;
      } else {
        return false;
      }
    };
    TabNote.prototype.isLowerThan = function(note) {
      var noteComparator = ["C", "D", "E", "F", "G", "A", "B"];
      if (this.hasComma > note.hasComma)
        return true;
      if (note.hasComma > this.hasComma)
        return false;
      if (this.isQuoted > note.isQuoted)
        return false;
      if (note.isQuoted > this.isQuoted)
        return true;
      if (this.isLower) {
        if (!note.isLower)
          return false;
      } else {
        if (note.isLower)
          return true;
      }
      var noteName = note.name[0].toUpperCase();
      var thisName = this.name[0].toUpperCase();
      if (noteComparator.indexOf(thisName) < noteComparator.indexOf(noteName))
        return true;
      return false;
    };
    TabNote.prototype.checkKeyAccidentals = function(accidentals) {
      if (accidentals) {
        var curNote = this.name;
        for (var iii = 0; iii < accidentals.length; iii++) {
          var curAccidentals = accidentals[iii];
          if (curNote == curAccidentals.note.toUpperCase()) {
            if (curAccidentals.acc == "flat") {
              this.acc = -1;
              this.isKeyFlat = true;
            }
            if (curAccidentals.acc == "sharp") {
              this.acc = 1;
              this.isKeySharp = true;
            }
          }
        }
      }
    };
    TabNote.prototype.getAccidentalEquiv = function() {
      var cloned = cloneNote(this);
      if (cloned.isSharp || cloned.isKeySharp) {
        cloned = cloned.nextNote();
        cloned.isFlat = true;
        cloned.isSharp = false;
        cloned.isKeySharp = false;
      } else if (cloned.isFlat || cloned.isKeyFlat) {
        cloned = cloned.prevNote();
        cloned.isSharp = true;
        cloned.isFlat = false;
        cloned.isKeyFlat = false;
      }
      return cloned;
    };
    TabNote.prototype.nextNote = function() {
      var newTabNote = cloneNote(this);
      if (!this.isSharp && !this.isKeySharp) {
        if (this.name != "E" && this.name != "B") {
          newTabNote.isSharp = true;
          return newTabNote;
        }
      } else {
        newTabNote.isSharp = false;
        newTabNote.isKeySharp = false;
      }
      var noteIndex = notes.indexOf(this.name);
      if (noteIndex == notes.length - 1) {
        noteIndex = 0;
      } else {
        noteIndex++;
      }
      newTabNote.name = notes[noteIndex];
      if (newTabNote.name == "C") {
        if (newTabNote.hasComma > 0) {
          newTabNote.hasComma--;
        } else {
          if (!newTabNote.isLower) {
            newTabNote.isLower = true;
          } else {
            newTabNote.isQuoted = true;
          }
        }
      }
      return newTabNote;
    };
    TabNote.prototype.prevNote = function() {
      var newTabNote = cloneNote(this);
      if (this.isSharp) {
        newTabNote.isSharp = false;
        return newTabNote;
      }
      var noteIndex = notes.indexOf(this.name);
      if (noteIndex == 0) {
        noteIndex = notes.length - 1;
      } else {
        noteIndex--;
      }
      newTabNote.name = notes[noteIndex];
      if (newTabNote.name == "B") {
        if (newTabNote.isLower) {
          newTabNote.hasComma = 1;
        } else {
          if (newTabNote.hasComma > 0) {
            newTabNote.hasComma++;
          } else {
            if (newTabNote.isQuoted > 0) {
              newTabNote.isQuoted -= 1;
            } else {
              newTabNote.isLower = true;
            }
          }
        }
      }
      if (this.isFlat) {
        newTabNote.isFlat = false;
        return newTabNote;
      } else {
        if (this.name != "E" && this.name != "B") {
          newTabNote.isSharp = true;
        }
      }
      return newTabNote;
    };
    TabNote.prototype.emitNoAccidentals = function() {
      var returned = this.name;
      if (this.isLower) {
        returned = returned.toLowerCase();
      }
      for (var ii = 0; ii < this.isQuoted; ii++) {
        returned += "'";
      }
      for (var jj = 0; jj < this.hasComma; jj++) {
        returned += ",";
      }
      return returned;
    };
    TabNote.prototype.emit = function() {
      var returned = this.name;
      if (this.isSharp || this.isKeySharp) {
        returned = "^" + returned;
        if (this.isDouble) {
          returned = "^" + returned;
        }
      }
      if (this.isFlat || this.isKeyFlat) {
        returned = "_" + returned;
        if (this.isDouble) {
          returned = "_" + returned;
        }
      }
      if (this.quarter) {
        if (this.quarter == "^") {
          returned = "^/" + returned;
        } else {
          returned = "_/" + returned;
        }
      }
      if (this.natural) {
        returned = "=" + returned;
      }
      for (var ii = 1; ii <= this.hasComma; ii++) {
        returned += ",";
      }
      if (this.isLower) {
        returned = returned.toLowerCase();
        for (var jj = 1; jj <= this.isQuoted; jj++) {
          returned += "'";
        }
      }
      return returned;
    };
    module.exports = {
      "TabNote": TabNote,
      "notes": notes
    };
  }
});

// node_modules/abcjs/src/tablatures/transposer.js
var require_transposer = __commonJS({
  "node_modules/abcjs/src/tablatures/transposer.js"(exports, module) {
    var TabNote = require_tab_note();
    function buildAccEquiv(acc, note) {
      var equiv = note.getAccidentalEquiv();
      if (acc.note.toUpperCase() == equiv.name.toUpperCase()) {
        equiv.isSharp = false;
        equiv.isFlat = false;
        return equiv;
      }
      return note;
    }
    function adjustNoteToKey(acc, note) {
      if (acc.acc == "sharp") {
        if (note.isFlat) {
          return buildAccEquiv(acc, note);
        } else if (note.isSharp) {
          if (acc.note.toUpperCase() == note.name.toUpperCase()) {
            note.isSharp = false;
            note.isKeySharp = true;
          } else {
            if (acc.note.toUpperCase() == note.name.toUpperCase()) {
              note.natural = true;
            }
          }
        }
      } else if (acc.acc == "flat") {
        if (note.isSharp) {
          return buildAccEquiv(acc, note);
        } else if (note.isFlat) {
          if (acc.note.toUpperCase() == note.name.toUpperCase()) {
            note.isFlat = false;
            note.isKeyFlat = true;
          }
        } else {
          if (acc.note.toUpperCase() == note.name.toUpperCase()) {
            note.natural = true;
          }
        }
      }
      return note;
    }
    function replaceNote(self, newNote, start, end) {
      if (self.lastEnd) {
        while (start > self.lastEnd) {
          self.updatedSrc.push(self.abcSrc[self.lastEnd]);
          self.lastEnd++;
        }
      }
      var nNote = newNote.split("");
      for (var ii = 0; ii < nNote.length; ii++) {
        self.updatedSrc.push(nNote[ii]);
      }
      var curPos = start + ii;
      while (end >= curPos) {
        self.updatedSrc.push(nNote[curPos]);
        curPos++;
      }
      self.lastEnd = end;
    }
    function checkKeys(self, note) {
      var accs = self.transposedKey;
      for (var ii = 0; ii < accs.length; ii++) {
        note = adjustNoteToKey(accs[ii], note);
      }
      return note;
    }
    Transposer.prototype.transposeNote = function(note) {
      var returned = note;
      var curNote = new TabNote.TabNote(returned.name);
      if (this.transposeBy > 0) {
        for (var ii = 0; ii < this.transposeBy; ii++) {
          curNote = checkKeys(this, curNote.nextNote());
        }
      } else if (this.transposeBy < 0) {
        for (var jj = this.transposeBy; jj < 0; jj++) {
          curNote = checkKeys(this, curNote.prevNote());
        }
      }
      returned.name = curNote.emit();
      return returned;
    };
    Transposer.prototype.upgradeSource = function(note, startChar, endChar) {
      var n = new TabNote.TabNote(note.name);
      var newNote = n.emit();
      replaceNote(this, newNote, startChar, endChar - 1);
    };
    function Transposer(transposedKey, transposeBy) {
      this.transposeBy = transposeBy;
      this.transposedKey = transposedKey;
      this.lastEnd = this.kEnd + 1;
    }
    module.exports = Transposer;
  }
});

// node_modules/abcjs/src/tablatures/tab-absolute-elements.js
var require_tab_absolute_elements = __commonJS({
  "node_modules/abcjs/src/tablatures/tab-absolute-elements.js"(exports, module) {
    var AbsoluteElement = require_abc_absolute_element();
    var RelativeElement = require_abc_relative_element();
    var Transposer = require_transposer();
    function isObject(a) {
      return a != null && a.constructor === Object;
    }
    function cloneObject(dest, src) {
      for (var prop in src) {
        if (src.hasOwnProperty(prop)) {
          if (!(Array.isArray(src[prop]) || isObject(src[prop]))) {
            dest[prop] = src[prop];
          }
        }
      }
    }
    function cloneAbsolute(absSrc) {
      var returned = new AbsoluteElement("", 0, 0, "", 0);
      cloneObject(returned, absSrc);
      returned.top = 0;
      returned.bottom = -1;
      if (absSrc.abcelem) {
        returned.abcelem = {};
        cloneObject(returned.abcelem, absSrc.abcelem);
        if (returned.abcelem.el_type === "note")
          returned.abcelem.el_type = "tabNumber";
      }
      return returned;
    }
    function cloneAbsoluteAndRelatives(absSrc, plugin) {
      var returned = cloneAbsolute(absSrc);
      if (plugin) {
        var children = absSrc.children;
        var first = true;
        for (var ii = 0; ii < children.length; ii++) {
          var child = children[ii];
          var relative = new RelativeElement("", 0, 0, 0, "");
          cloneObject(relative, child);
          first = plugin.tablature.setRelative(child, relative, first);
          returned.children.push(relative);
        }
      }
      return returned;
    }
    function buildTabAbsolute(plugin, absX, relX) {
      var tabIcon = "tab.tiny";
      var tabYPos = 7.5;
      if (plugin.isTabBig) {
        tabIcon = "tab.big";
        tabYPos = 10;
      }
      var element = {
        el_type: "tab",
        icon: tabIcon,
        Ypos: tabYPos
      };
      var tabAbsolute = new AbsoluteElement(element, 0, 0, "symbol", 0);
      tabAbsolute.x = absX;
      var tabRelative = new RelativeElement(tabIcon, 0, 0, 7.5, "tab");
      tabRelative.x = relX;
      tabAbsolute.children.push(tabRelative);
      if (tabAbsolute.abcelem.el_type == "tab") {
        tabRelative.pitch = tabYPos;
      }
      return tabAbsolute;
    }
    function lyricsDim(abs) {
      if (abs.extra) {
        for (var ii = 0; ii < abs.extra.length; ii++) {
          var extra = abs.extra[ii];
          if (extra.type == "lyric") {
            return {
              bottom: extra.bottom,
              height: extra.height
            };
          }
        }
      }
      return null;
    }
    function TabAbsoluteElements() {
      this.accidentals = null;
    }
    function getInitialStaffSize(staffGroup) {
      var returned = 0;
      for (var ii = 0; ii < staffGroup.length; ii++) {
        if (!staffGroup[ii].tabNameInfos)
          returned++;
      }
      return returned;
    }
    function buildRelativeTabNote(plugin, relX, def, curNote, isGrace) {
      var strNote = curNote.num;
      if (curNote.note.quarter != null) {
        strNote = strNote.toString();
        strNote += curNote.note.quarter;
      }
      var pitch = plugin.semantics.stringToPitch(curNote.str);
      def.notes.push({ num: strNote, str: curNote.str, pitch: curNote.note.emit() });
      var opt = {
        type: "tabNumber"
      };
      var tabNoteRelative = new RelativeElement(strNote, 0, 0, pitch + 0.3, opt);
      tabNoteRelative.x = relX;
      tabNoteRelative.isGrace = isGrace;
      tabNoteRelative.isAltered = curNote.note.isAltered;
      return tabNoteRelative;
    }
    function getXGrace(abs, index) {
      var found = 0;
      if (abs.extra) {
        for (var ii = 0; ii < abs.extra.length; ii++) {
          if (abs.extra[ii].c.indexOf("noteheads") >= 0) {
            if (found === index) {
              return abs.extra[ii].x + abs.extra[ii].w / 2;
            } else {
              found++;
            }
          }
        }
      }
      return -1;
    }
    function graceInRest(absElem) {
      if (absElem.abcelem) {
        var elem = absElem.abcelem;
        if (elem.rest) {
          return elem.gracenotes;
        }
      }
      return null;
    }
    function checkTransposition(plugin, transposer, pitches, graceNotes) {
      if (plugin.transpose) {
        for (var jj = 0; jj < pitches.length; jj++) {
          pitches[jj] = transposer.transposeNote(pitches[jj]);
        }
        if (graceNotes) {
          for (var kk = 0; kk < graceNotes.length; kk++) {
            graceNotes[kk] = transposer.transposeNote(graceNotes[kk]);
          }
        }
      }
    }
    function convertToNumber(plugin, pitches, graceNotes) {
      var tabPos = plugin.semantics.notesToNumber(pitches, graceNotes);
      if (tabPos.error) {
        plugin._super.setError(tabPos.error);
        return tabPos;
      }
      if (tabPos.graces && tabPos.notes) {
        var posNote = tabPos.notes.length - 1;
        tabPos.notes[posNote].graces = tabPos.graces;
      }
      return tabPos;
    }
    function buildGraceRelativesForRest(plugin, abs, absChild, graceNotes, tabVoice) {
      for (var mm = 0; mm < graceNotes.length; mm++) {
        var defGrace = { el_type: "note", startChar: absChild.abcelem.startChar, endChar: absChild.abcelem.endChar, notes: [], grace: true };
        var graceX = getXGrace(absChild, mm);
        var curGrace = graceNotes[mm];
        var tabGraceRelative = buildRelativeTabNote(plugin, graceX, defGrace, curGrace, true);
        abs.children.push(tabGraceRelative);
        tabVoice.push(defGrace);
      }
    }
    TabAbsoluteElements.prototype.build = function(plugin, staffAbsolute, tabVoice, voiceIndex, staffIndex, keySig) {
      var staffSize = getInitialStaffSize(staffAbsolute);
      var source = staffAbsolute[staffIndex + voiceIndex];
      var dest = staffAbsolute[staffSize + staffIndex + voiceIndex];
      var transposer = null;
      var tabPos = null;
      var defNote = null;
      if (source.children[0].abcelem.el_type != "clef") {
        if (keySig != "none") {
          source.children.splice(0, 0, keySig);
        }
      }
      for (var ii = 0; ii < source.children.length; ii++) {
        var absChild = source.children[ii];
        var absX = absChild.x;
        var relX = absX;
        if (absChild.isClef) {
          dest.children.push(buildTabAbsolute(plugin, absX, relX));
        }
        switch (absChild.type) {
          case "staff-extra key-signature":
            this.accidentals = absChild.abcelem.accidentals;
            plugin.semantics.strings.accidentals = this.accidentals;
            if (plugin.transpose) {
              transposer = new Transposer(absChild.abcelem.accidentals, plugin.transpose);
            }
            break;
          case "bar":
            var lastBar = false;
            if (ii === source.children.length - 1) {
              lastBar = true;
            }
            var cloned = cloneAbsoluteAndRelatives(absChild, plugin);
            if (cloned.abcelem.barNumber) {
              delete cloned.abcelem.barNumber;
              for (var bn = 0; bn < cloned.children.length; bn++) {
                if (cloned.children[bn].type === "barNumber") {
                  cloned.children.splice(bn, 1);
                  break;
                }
              }
            }
            cloned.abcelem.lastBar = lastBar;
            dest.children.push(cloned);
            tabVoice.push({
              el_type: absChild.abcelem.el_type,
              type: absChild.abcelem.type,
              endChar: absChild.abcelem.endChar,
              startChar: absChild.abcelem.startChar,
              abselem: cloned
            });
            break;
          case "rest":
            var restGraces = graceInRest(absChild);
            if (restGraces) {
              checkTransposition(plugin, transposer, null, restGraces);
              tabPos = convertToNumber(plugin, null, restGraces);
              if (tabPos.error)
                return;
              defGrace = { el_type: "note", startChar: absChild.abcelem.startChar, endChar: absChild.abcelem.endChar, notes: [], grace: true };
              buildGraceRelativesForRest(plugin, abs, absChild, tabPos.graces, tabVoice);
            }
            break;
          case "note":
            var abs = cloneAbsolute(absChild);
            abs.x = absChild.heads[0].x + absChild.heads[0].w / 2;
            abs.lyricDim = lyricsDim(absChild);
            var pitches = absChild.abcelem.pitches;
            var graceNotes = absChild.abcelem.gracenotes;
            abs.type = "tabNumber";
            checkTransposition(plugin, transposer, pitches, graceNotes);
            tabPos = convertToNumber(plugin, pitches, graceNotes);
            if (tabPos.error)
              return;
            if (tabPos.graces) {
              var posNote = tabPos.notes.length - 1;
              tabPos.notes[posNote].graces = tabPos.graces;
            }
            defNote = { el_type: "note", startChar: absChild.abcelem.startChar, endChar: absChild.abcelem.endChar, notes: [] };
            for (var ll = 0; ll < tabPos.notes.length; ll++) {
              var curNote = tabPos.notes[ll];
              if (curNote.graces) {
                for (var mm = 0; mm < curNote.graces.length; mm++) {
                  var defGrace = { el_type: "note", startChar: absChild.abcelem.startChar, endChar: absChild.abcelem.endChar, notes: [], grace: true };
                  var graceX = getXGrace(absChild, mm);
                  var curGrace = curNote.graces[mm];
                  var tabGraceRelative = buildRelativeTabNote(plugin, graceX, defGrace, curGrace, true);
                  abs.children.push(tabGraceRelative);
                  tabVoice.push(defGrace);
                }
              }
              var tabNoteRelative = buildRelativeTabNote(plugin, abs.x + absChild.heads[ll].dx, defNote, curNote, false);
              abs.children.push(tabNoteRelative);
            }
            defNote.abselem = abs;
            tabVoice.push(defNote);
            dest.children.push(abs);
            break;
        }
      }
    };
    module.exports = TabAbsoluteElements;
  }
});

// node_modules/abcjs/src/tablatures/tab-renderer.js
var require_tab_renderer = __commonJS({
  "node_modules/abcjs/src/tablatures/tab-renderer.js"(exports, module) {
    var VoiceElement = require_abc_voice_element();
    var TabAbsoluteElements = require_tab_absolute_elements();
    var spacing = require_abc_spacing();
    function initSpecialY() {
      return {
        tempoHeightAbove: 0,
        partHeightAbove: 0,
        volumeHeightAbove: 0,
        dynamicHeightAbove: 0,
        endingHeightAbove: 0,
        chordHeightAbove: 0,
        lyricHeightAbove: 0,
        lyricHeightBelow: 0,
        chordHeightBelow: 0,
        volumeHeightBelow: 0,
        dynamicHeightBelow: 0
      };
    }
    function getLyricHeight(voice) {
      var maxLyricHeight = 0;
      for (var ii = 0; ii < voice.children.length; ii++) {
        var curAbs = voice.children[ii];
        if (curAbs.specialY) {
          if (curAbs.specialY.lyricHeightBelow > maxLyricHeight) {
            maxLyricHeight = curAbs.specialY.lyricHeightBelow;
          }
        }
      }
      return maxLyricHeight;
    }
    function buildTabName(self, dest) {
      var stringSemantics = self.plugin.semantics.strings;
      var controller = self.renderer.controller;
      var textSize = controller.getTextSize;
      var tabName = stringSemantics.tabInfos(self.plugin);
      var size = textSize.calc(tabName, "tablabelfont", "text instrumentname");
      dest.tabNameInfos = {
        textSize: size,
        name: tabName
      };
      return size.height;
    }
    function TabRenderer(plugin, renderer, line, staffIndex) {
      this.renderer = renderer;
      this.plugin = plugin;
      this.line = line;
      this.absolutes = new TabAbsoluteElements();
      this.staffIndex = staffIndex;
      this.tabStaff = {
        clef: {
          type: "TAB"
        }
      };
      this.tabSize = plugin.linePitch * plugin.nbLines;
    }
    function islastTabInStaff(index, staffGroup) {
      if (staffGroup[index].isTabStaff) {
        if (index === staffGroup.length - 1)
          return true;
        if (staffGroup[index + 1].isTabStaff) {
          return false;
        } else {
          return true;
        }
      }
      return false;
    }
    function getStaffNumbers(staffs) {
      var nbStaffs = 0;
      for (var ii = 0; ii < staffs.length; ii++) {
        if (!staffs[ii].isTabStaff) {
          nbStaffs++;
        }
      }
      return nbStaffs;
    }
    function getParentStaffIndex(staffs, index) {
      for (var ii = index; ii >= 0; ii--) {
        if (!staffs[ii].isTabStaff) {
          return ii;
        }
      }
      return -1;
    }
    function linkStaffAndTabs(staffs) {
      for (var ii = 0; ii < staffs.length; ii++) {
        if (staffs[ii].isTabStaff) {
          var parentIndex = getParentStaffIndex(staffs, ii);
          staffs[ii].hasStaff = staffs[parentIndex];
          if (!staffs[parentIndex].hasTab)
            staffs[parentIndex].hasTab = [];
          staffs[parentIndex].hasTab.push(staffs[ii]);
        }
      }
    }
    function isMultiVoiceSingleStaff(staffs, parent) {
      if (getStaffNumbers(staffs) === 1) {
        if (parent.voices.length > 1)
          return true;
      }
      return false;
    }
    function getNextTabPos(self, staffGroup) {
      var tabIndex = self.staffIndex;
      var startIndex = 0;
      var handledVoices = 0;
      var inProgress = true;
      var nbVoices = 0;
      while (inProgress) {
        if (!staffGroup[startIndex])
          return -1;
        if (!staffGroup[startIndex].isTabStaff) {
          nbVoices = staffGroup[startIndex].voices.length;
        }
        if (staffGroup[startIndex].isTabStaff) {
          handledVoices++;
          if (islastTabInStaff(startIndex, staffGroup)) {
            if (handledVoices < nbVoices)
              return startIndex + 1;
          }
        } else {
          handledVoices = 0;
          if (startIndex >= tabIndex) {
            if (startIndex + 1 == staffGroup.length)
              return startIndex + 1;
            if (!staffGroup[startIndex + 1].isTabStaff)
              return startIndex + 1;
          }
        }
        startIndex++;
        if (startIndex > staffGroup.length)
          return -1;
      }
    }
    function getLastStaff(staffs, lastTab) {
      for (var ii = lastTab; ii >= 0; ii--) {
        if (!staffs[ii].isTabStaff) {
          return staffs[ii];
        }
      }
      return null;
    }
    function checkVoiceKeySig(voices, ii) {
      var curVoice = voices[ii];
      var elem0 = curVoice.children[0].abcelem;
      if (elem0.el_type === "clef")
        return null;
      if (ii == 0) {
        return "none";
      }
      return voices[ii - 1].children[0];
    }
    TabRenderer.prototype.doLayout = function() {
      var staffs = this.line.staff;
      if (staffs) {
        var firstStaff = staffs[0];
        if (firstStaff) {
          if (firstStaff.clef) {
            if (firstStaff.clef.stafflines == 0) {
              this.plugin._super.setError("No tablatures when stafflines=0");
              return;
            }
          }
        }
        staffs.splice(staffs.length, 0, this.tabStaff);
      }
      var staffGroup = this.line.staffGroup;
      var voices = staffGroup.voices;
      var firstVoice = voices[0];
      var lyricsHeight = getLyricHeight(firstVoice);
      var padd = 3;
      var prevIndex = this.staffIndex;
      var previousStaff = staffGroup.staffs[prevIndex];
      var tabTop = previousStaff.top + padd + lyricsHeight;
      if (previousStaff.isTabStaff) {
        tabTop = previousStaff.top;
      }
      var staffGroupInfos = {
        bottom: -1,
        isTabStaff: true,
        specialY: initSpecialY(),
        lines: this.plugin.nbLines,
        linePitch: this.plugin.linePitch,
        dy: 0.15,
        top: tabTop
      };
      var nextTabPos = getNextTabPos(this, staffGroup.staffs);
      if (nextTabPos === -1)
        return;
      staffGroupInfos.parentIndex = nextTabPos - 1;
      staffGroup.staffs.splice(nextTabPos, 0, staffGroupInfos);
      staffGroup.height += this.tabSize + padd;
      var parentStaff = getLastStaff(staffGroup.staffs, nextTabPos);
      var nbVoices = 1;
      if (isMultiVoiceSingleStaff(staffGroup.staffs, parentStaff)) {
        nbVoices = parentStaff.voices.length;
      }
      this.tabStaff.voices = [];
      for (var ii = 0; ii < nbVoices; ii++) {
        var tabVoice = new VoiceElement(0, 0);
        var nameHeight = buildTabName(this, tabVoice) / spacing.STEP;
        staffGroup.staffs[this.staffIndex].top += nameHeight;
        staffGroup.height += nameHeight * spacing.STEP;
        tabVoice.staff = staffGroupInfos;
        voices.splice(voices.length, 0, tabVoice);
        var keySig = checkVoiceKeySig(voices, ii + this.staffIndex);
        this.tabStaff.voices[ii] = [];
        this.absolutes.build(this.plugin, voices, this.tabStaff.voices[ii], ii, this.staffIndex, keySig);
      }
      linkStaffAndTabs(staffGroup.staffs);
    };
    module.exports = TabRenderer;
  }
});

// node_modules/abcjs/src/tablatures/instruments/tab-notes.js
var require_tab_notes = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/tab-notes.js"(exports, module) {
    var TabNote = require_tab_note();
    var notes = TabNote.notes;
    function TabNotes(fromNote, toNote) {
      this.fromN = new TabNote.TabNote(fromNote);
      this.toN = new TabNote.TabNote(toNote);
    }
    TabNotes.prototype.build = function() {
      var fromN = this.fromN;
      var toN = this.toN;
      if (toN.isLowerThan(fromN)) {
        var from = fromN.emit();
        var tn = toN.emit();
        return {
          error: "Invalid string Instrument tuning : " + tn + " string lower than " + from + " string"
        };
      }
      var buildReturned = [];
      var startIndex = notes.indexOf(fromN.name);
      var toIndex = notes.indexOf(toN.name);
      if (startIndex == -1 || toIndex == -1) {
        return buildReturned;
      }
      var finished = false;
      while (!finished) {
        buildReturned.push(fromN.emit());
        fromN = fromN.nextNote();
        if (fromN.sameNoteAs(toN)) {
          finished = true;
        }
      }
      return buildReturned;
    };
    module.exports = TabNotes;
  }
});

// node_modules/abcjs/src/tablatures/instruments/string-patterns.js
var require_string_patterns = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/string-patterns.js"(exports, module) {
    var TabNote = require_tab_note();
    var TabNotes = require_tab_notes();
    function buildCapo(self) {
      var capoTuning = null;
      var tuning = self.tuning;
      if (self.capo > 0) {
        capoTuning = [];
        for (var iii = 0; iii < tuning.length; iii++) {
          var curNote = new TabNote.TabNote(tuning[iii]);
          for (var jjj = 0; jjj < self.capo; jjj++) {
            curNote = curNote.nextNote();
          }
          capoTuning[iii] = curNote.emit();
        }
      }
      return capoTuning;
    }
    function buildPatterns(self) {
      var strings = [];
      var tuning = self.tuning;
      if (self.capo > 0) {
        tuning = self.capoTuning;
      }
      var pos = tuning.length - 1;
      for (var iii = 0; iii < tuning.length; iii++) {
        var nextNote = self.highestNote;
        if (iii != tuning.length - 1) {
          nextNote = tuning[iii + 1];
        }
        var tabNotes = new TabNotes(tuning[iii], nextNote);
        var stringNotes = tabNotes.build();
        if (stringNotes.error) {
          return stringNotes;
        }
        strings[pos--] = stringNotes;
      }
      return strings;
    }
    function buildSecond(first) {
      var seconds = [];
      seconds[0] = [];
      var strings = first.strings;
      for (var iii = 1; iii < strings.length; iii++) {
        seconds[iii] = strings[iii - 1];
      }
      return seconds;
    }
    function sameString(self, chord) {
      for (var jjjj = 0; jjjj < chord.length - 1; jjjj++) {
        var curPos = chord[jjjj];
        var nextPos = chord[jjjj + 1];
        if (curPos.str == nextPos.str) {
          if (curPos.str == self.strings.length - 1) {
            curPos.num = "?";
            nextPos.num = "?";
            return;
          }
          if (nextPos.num < curPos.num) {
            nextPos.str++;
            nextPos = noteToNumber(self, nextPos.note, nextPos.str, self.secondPos, self.strings[nextPos.str].length);
          } else {
            curPos.str++;
            curPos = noteToNumber(self, curPos.note, curPos.str, self.secondPos, self.strings[curPos.str].length);
          }
          chord[jjjj] = curPos;
          chord[jjjj + 1] = nextPos;
        }
      }
      return null;
    }
    function handleChordNotes(self, notes) {
      var retNotes = [];
      for (var iiii = 0; iiii < notes.length; iiii++) {
        var note = new TabNote.TabNote(notes[iiii].name);
        var curPos = toNumber(self, note);
        retNotes.push(curPos);
      }
      sameString(self, retNotes);
      return retNotes;
    }
    function noteToNumber(self, note, stringNumber, secondPosition, firstSize) {
      var strings = self.strings;
      note.checkKeyAccidentals(self.accidentals);
      if (secondPosition) {
        strings = secondPosition;
      }
      var noteName = note.emitNoAccidentals();
      var num = strings[stringNumber].indexOf(noteName);
      var acc = note.acc;
      if (num != -1) {
        if (secondPosition) {
          num += firstSize;
        }
        if ((note.isFlat || note.acc == -1) && num == 0) {
          var noteEquiv = note.getAccidentalEquiv();
          stringNumber++;
          num = strings[stringNumber].indexOf(noteEquiv.emit());
          acc = 0;
        }
        return {
          num: num + acc,
          str: stringNumber,
          note
        };
      }
      return null;
    }
    function toNumber(self, note) {
      var num = null;
      var str = 0;
      var lowestString = self.strings[self.strings.length - 1];
      var lowestNote = new TabNote.TabNote(lowestString[0]);
      if (note.isLowerThan(lowestNote)) {
        return {
          num: "?",
          str: self.strings.length - 1,
          note,
          error: note.emit() + ": unexpected note for instrument"
        };
      }
      while (str < self.strings.length) {
        num = noteToNumber(self, note, str);
        if (num) {
          return num;
        }
        str++;
      }
      return null;
    }
    StringPatterns.prototype.stringToPitch = function(stringNumber) {
      var startingPitch = 5.3;
      var bottom = this.strings.length - 1;
      return startingPitch + (bottom - stringNumber) * this.linePitch;
    };
    function invalidNumber(retNotes, note) {
      var number = {
        num: "?",
        str: 0,
        note
      };
      retNotes.push(number);
      retNotes.error = note.emit() + ": unexpected note for instrument";
    }
    StringPatterns.prototype.notesToNumber = function(notes, graces) {
      var note;
      var number;
      var error = null;
      var retNotes = null;
      if (notes) {
        retNotes = [];
        if (notes.length > 1) {
          retNotes = handleChordNotes(this, notes);
          if (retNotes.error) {
            error = retNotes.error;
          }
        } else {
          note = new TabNote.TabNote(notes[0].name);
          number = toNumber(this, note);
          if (number) {
            retNotes.push(number);
          } else {
            invalidNumber(retNotes, note);
            error = retNotes.error;
          }
        }
      }
      if (error)
        return retNotes;
      var retGraces = null;
      if (graces) {
        retGraces = [];
        for (var iiii = 0; iiii < graces.length; iiii++) {
          note = new TabNote.TabNote(graces[iiii].name);
          number = toNumber(this, note);
          if (number) {
            retGraces.push(number);
          } else {
            invalidNumber(retGraces, note);
            error = retNotes.error;
          }
        }
      }
      return {
        notes: retNotes,
        graces: retGraces,
        error
      };
    };
    StringPatterns.prototype.toString = function() {
      return this.tuning.join("").replaceAll(",", "").toUpperCase();
    };
    StringPatterns.prototype.tabInfos = function(plugin) {
      var _super = plugin._super;
      var name = _super.params.label;
      if (name) {
        var tunePos = name.indexOf("%T");
        var tuning = "";
        if (tunePos != -1) {
          tuning = this.toString();
          if (plugin.capo > 0) {
            tuning += " capo:" + plugin.capo;
          }
          name = name.replace("%T", tuning);
        }
        return name;
      }
      return "";
    };
    function StringPatterns(plugin) {
      var tuning = plugin.tuning;
      var capo = plugin.capo;
      var highestNote = plugin._super.params.highestNote;
      this.linePitch = plugin.linePitch;
      this.highestNote = "a'";
      if (highestNote) {
        this.highestNote = highestNote;
      }
      this.capo = 0;
      if (capo) {
        this.capo = capo;
      }
      this.tuning = tuning;
      if (this.capo > 0) {
        this.capoTuning = buildCapo(this);
      }
      this.strings = buildPatterns(this);
      if (this.strings.error) {
        plugin._super.setError(this.strings.error);
        plugin.inError = true;
        return;
      }
      this.secondPos = buildSecond(this);
    }
    module.exports = StringPatterns;
  }
});

// node_modules/abcjs/src/tablatures/instruments/violin/violin-patterns.js
var require_violin_patterns = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/violin/violin-patterns.js"(exports, module) {
    var StringPatterns = require_string_patterns();
    function ViolinPatterns(plugin) {
      this.tuning = plugin._super.params.tuning;
      if (!this.tuning) {
        this.tuning = ["G,", "D", "A", "e"];
      }
      plugin.tuning = this.tuning;
      this.strings = new StringPatterns(plugin);
    }
    ViolinPatterns.prototype.notesToNumber = function(notes, graces) {
      var converter = this.strings;
      return converter.notesToNumber(notes, graces);
    };
    ViolinPatterns.prototype.stringToPitch = function(stringNumber) {
      var converter = this.strings;
      return converter.stringToPitch(stringNumber);
    };
    module.exports = ViolinPatterns;
  }
});

// node_modules/abcjs/src/tablatures/instruments/violin/violin-fonts.js
var require_violin_fonts = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/violin/violin-fonts.js"(exports, module) {
    function setViolinFonts(tune) {
    }
    module.exports = setViolinFonts;
  }
});

// node_modules/abcjs/src/tablatures/instruments/violin/tab-violin.js
var require_tab_violin = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/violin/tab-violin.js"(exports, module) {
    var StringTablature = require_string_tablature();
    var TabCommon = require_tab_common();
    var TabRenderer = require_tab_renderer();
    var ViolinPatterns = require_violin_patterns();
    var setViolinFonts = require_violin_fonts();
    Plugin.prototype.init = function(abcTune, tuneNumber, params) {
      var _super = new TabCommon(abcTune, tuneNumber, params);
      this.abcTune = abcTune;
      this._super = _super;
      this.linePitch = 3;
      this.nbLines = 4;
      this.isTabBig = false;
      this.capo = params.capo;
      this.transpose = params.visualTranspose;
      this.tablature = new StringTablature(this.nbLines, this.linePitch);
      var semantics = new ViolinPatterns(this);
      this.semantics = semantics;
    };
    Plugin.prototype.render = function(renderer, line, staffIndex) {
      if (this._super.inError)
        return;
      if (this.tablature.bypass(line))
        return;
      setViolinFonts(this.abcTune);
      var rndrer = new TabRenderer(this, renderer, line, staffIndex);
      rndrer.doLayout();
    };
    function Plugin() {
    }
    var AbcViolinTab = function() {
      return { name: "ViolinTab", tablature: Plugin };
    };
    module.exports = AbcViolinTab;
  }
});

// node_modules/abcjs/src/tablatures/instruments/guitar/guitar-patterns.js
var require_guitar_patterns = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/guitar/guitar-patterns.js"(exports, module) {
    var StringPatterns = require_string_patterns();
    function GuitarPatterns(plugin) {
      this.tuning = plugin._super.params.tuning;
      if (!this.tuning) {
        this.tuning = ["E,", "A,", "D", "G", "B", "e"];
      }
      plugin.tuning = this.tuning;
      this.strings = new StringPatterns(plugin);
    }
    GuitarPatterns.prototype.notesToNumber = function(notes, graces) {
      var converter = this.strings;
      return converter.notesToNumber(notes, graces);
    };
    GuitarPatterns.prototype.stringToPitch = function(stringNumber) {
      var converter = this.strings;
      return converter.stringToPitch(stringNumber);
    };
    module.exports = GuitarPatterns;
  }
});

// node_modules/abcjs/src/tablatures/instruments/guitar/guitar-fonts.js
var require_guitar_fonts = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/guitar/guitar-fonts.js"(exports, module) {
    function setGuitarFonts(tune) {
    }
    module.exports = setGuitarFonts;
  }
});

// node_modules/abcjs/src/tablatures/instruments/guitar/tab-guitar.js
var require_tab_guitar = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/guitar/tab-guitar.js"(exports, module) {
    var StringTablature = require_string_tablature();
    var TabCommon = require_tab_common();
    var TabRenderer = require_tab_renderer();
    var GuitarPatterns = require_guitar_patterns();
    var setGuitarFonts = require_guitar_fonts();
    Plugin.prototype.init = function(abcTune, tuneNumber, params) {
      var _super = new TabCommon(abcTune, tuneNumber, params);
      this._super = _super;
      this.abcTune = abcTune;
      this.linePitch = 3;
      this.nbLines = 6;
      this.isTabBig = true;
      this.capo = params.capo;
      this.transpose = params.visualTranspose;
      this.tablature = new StringTablature(this.nbLines, this.linePitch);
      var semantics = new GuitarPatterns(this);
      this.semantics = semantics;
    };
    Plugin.prototype.render = function(renderer, line, staffIndex) {
      if (this._super.inError)
        return;
      if (this.tablature.bypass(line))
        return;
      setGuitarFonts(this.abcTune);
      var rndrer = new TabRenderer(this, renderer, line, staffIndex);
      rndrer.doLayout();
    };
    function Plugin() {
    }
    var AbcGuitarTab = function() {
      return { name: "GuitarTab", tablature: Plugin };
    };
    module.exports = AbcGuitarTab;
  }
});

// node_modules/abcjs/src/api/abc_tablatures.js
var require_abc_tablatures = __commonJS({
  "node_modules/abcjs/src/api/abc_tablatures.js"(exports, module) {
    var ViolinTablature = require_tab_violin();
    var GuitarTablature = require_tab_guitar();
    var pluginTab = {
      "violin": "ViolinTab",
      "guitar": "GuitarTab"
    };
    var abcTablatures = {
      inited: false,
      plugins: {},
      register: function(plugin) {
        var name = plugin.name;
        var tablature = plugin.tablature;
        this.plugins[name] = tablature;
      },
      setError: function(tune, msg) {
        if (tune.warnings) {
          tune.warning.push(msg);
        } else {
          tune.warnings = [msg];
        }
      },
      preparePlugins: function(tune, tuneNumber, params) {
        var returned = null;
        var nbPlugins = 0;
        if (params.tablature) {
          var tabs = params.tablature;
          returned = [];
          for (var ii = 0; ii < tabs.length; ii++) {
            var args = tabs[ii];
            var instrument = args["instrument"];
            if (instrument == null) {
              this.setError(tune, "tablature 'instrument' is missing");
              return returned;
            }
            var tabName = pluginTab[instrument];
            var plugin = null;
            if (tabName) {
              plugin = this.plugins[tabName];
            }
            if (plugin) {
              if (params.visualTranspose != 0) {
                args.visualTranspose = params.visualTranspose;
              }
              args.abcSrc = params.tablature.abcSrc;
              var pluginInstance = {
                classz: plugin,
                tuneNumber,
                params: args,
                instance: null
              };
              returned.push(pluginInstance);
              nbPlugins++;
            } else {
              this.setError(tune, "Undefined tablature plugin: " + instrument);
              return returned;
            }
          }
        }
        return returned;
      },
      layoutTablatures: function(renderer, abcTune) {
        var tabs = abcTune.tablatures;
        for (var ii = 0; ii < abcTune.lines.length; ii++) {
          var line = abcTune.lines[ii];
          var curStaff = line.staff;
          if (curStaff) {
            for (var jj = 0; jj < curStaff.length; jj++) {
              if (tabs[jj]) {
                var tabPlugin = tabs[jj];
                if (tabPlugin.instance == null) {
                  tabPlugin.instance = new tabPlugin.classz();
                  tabPlugin.instance.init(abcTune, tabPlugin.tuneNumber, tabPlugin.params, jj);
                }
                tabPlugin.instance.render(renderer, line, jj);
              }
            }
          }
        }
      },
      init: function() {
        if (!this.inited) {
          this.register(new ViolinTablature());
          this.register(new GuitarTablature());
          this.inited = true;
        }
      }
    };
    module.exports = abcTablatures;
  }
});

// node_modules/abcjs/src/api/abc_tunebook.js
var require_abc_tunebook = __commonJS({
  "node_modules/abcjs/src/api/abc_tunebook.js"(exports, module) {
    var Parse = require_abc_parse();
    var bookParser = require_abc_parse_book();
    var tablatures = require_abc_tablatures();
    var tunebook = {};
    (function() {
      "use strict";
      tunebook.numberOfTunes = function(abc) {
        var tunes = abc.split("\nX:");
        var num = tunes.length;
        if (num === 0)
          num = 1;
        return num;
      };
      var TuneBook = tunebook.TuneBook = function(book) {
        var parsed = bookParser(book);
        this.header = parsed.header;
        this.tunes = parsed.tunes;
      };
      TuneBook.prototype.getTuneById = function(id) {
        for (var i = 0; i < this.tunes.length; i++) {
          if (this.tunes[i].id === "" + id)
            return this.tunes[i];
        }
        return null;
      };
      TuneBook.prototype.getTuneByTitle = function(title) {
        for (var i = 0; i < this.tunes.length; i++) {
          if (this.tunes[i].title === title)
            return this.tunes[i];
        }
        return null;
      };
      tunebook.parseOnly = function(abc, params) {
        var numTunes = tunebook.numberOfTunes(abc);
        var output = [];
        for (var i = 0; i < numTunes; i++) {
          output.push(1);
        }
        function callback() {
        }
        return tunebook.renderEngine(callback, output, abc, params);
      };
      tunebook.renderEngine = function(callback, output, abc, params) {
        var ret = [];
        var isArray = function(testObject) {
          return testObject && !testObject.propertyIsEnumerable("length") && typeof testObject === "object" && typeof testObject.length === "number";
        };
        if (output === void 0 || abc === void 0)
          return;
        if (!isArray(output))
          output = [output];
        if (params === void 0)
          params = {};
        var currentTune = params.startingTune ? parseInt(params.startingTune, 10) : 0;
        var book = new TuneBook(abc);
        var abcParser = new Parse();
        for (var i = 0; i < output.length; i++) {
          var div = output[i];
          if (div === "*") {
          } else if (typeof div === "string")
            div = document.getElementById(div);
          if (div) {
            if (currentTune >= 0 && currentTune < book.tunes.length) {
              abcParser.parse(book.tunes[currentTune].abc, params, book.tunes[currentTune].startPos - book.header.length);
              var tune = abcParser.getTune();
              if (params.tablature) {
                tablatures.init();
                tune.tablatures = tablatures.preparePlugins(tune, currentTune, params);
              }
              var warnings = abcParser.getWarnings();
              if (warnings)
                tune.warnings = warnings;
              var override = callback(div, tune, i, book.tunes[currentTune].abc);
              ret.push(override ? override : tune);
            } else {
              if (div["innerHTML"])
                div.innerHTML = "";
            }
          }
          currentTune++;
        }
        return ret;
      };
      function flattenTune(tuneObj) {
        var staves = [];
        for (var j = 0; j < tuneObj.lines.length; j++) {
          var line = tuneObj.lines[j];
          if (line.staff) {
            for (var k = 0; k < line.staff.length; k++) {
              var staff = line.staff[k];
              if (!staves[k])
                staves[k] = staff;
              else {
                for (var i = 0; i < staff.voices.length; i++) {
                  if (staves[k].voices[i])
                    staves[k].voices[i] = staves[k].voices[i].concat(staff.voices[i]);
                }
              }
            }
          }
        }
        return staves;
      }
      function measuresParser(staff, tune) {
        var voices = [];
        var lastChord = null;
        var measureStartChord = null;
        var fragStart = null;
        var hasNotes = false;
        for (var i = 0; i < staff.voices.length; i++) {
          var voice = staff.voices[i];
          voices.push([]);
          for (var j = 0; j < voice.length; j++) {
            var elem = voice[j];
            if (fragStart === null && elem.startChar >= 0) {
              fragStart = elem.startChar;
              if (elem.chord === void 0)
                measureStartChord = lastChord;
              else
                measureStartChord = null;
            }
            if (elem.chord)
              lastChord = elem;
            if (elem.el_type === "bar") {
              if (hasNotes) {
                var frag = tune.abc.substring(fragStart, elem.endChar);
                var measure = { abc: frag };
                lastChord = measureStartChord && measureStartChord.chord && measureStartChord.chord.length > 0 ? measureStartChord.chord[0].name : null;
                if (lastChord)
                  measure.lastChord = lastChord;
                if (elem.startEnding)
                  measure.startEnding = elem.startEnding;
                if (elem.endEnding)
                  measure.endEnding = elem.endEnding;
                voices[i].push(measure);
                fragStart = null;
                hasNotes = false;
              }
            } else if (elem.el_type === "note") {
              hasNotes = true;
            }
          }
        }
        return voices;
      }
      tunebook.extractMeasures = function(abc) {
        var tunes = [];
        var book = new TuneBook(abc);
        for (var i = 0; i < book.tunes.length; i++) {
          var tune = book.tunes[i];
          var arr = tune.abc.split("K:");
          var arr2 = arr[1].split("\n");
          var header = arr[0] + "K:" + arr2[0] + "\n";
          var lastChord = null;
          var measureStartChord = null;
          var fragStart = null;
          var measures = [];
          var hasNotes = false;
          var tuneObj = tunebook.parseOnly(tune.abc)[0];
          var hasPickup = tuneObj.getPickupLength() > 0;
          for (var j = 0; j < tuneObj.lines.length; j++) {
            var line = tuneObj.lines[j];
            if (line.staff) {
              for (var k = 0; k < 1; k++) {
                var staff = line.staff[k];
                for (var kk = 0; kk < 1; kk++) {
                  var voice = staff.voices[kk];
                  for (var kkk = 0; kkk < voice.length; kkk++) {
                    var elem = voice[kkk];
                    if (fragStart === null && elem.startChar >= 0) {
                      fragStart = elem.startChar;
                      if (elem.chord === void 0)
                        measureStartChord = lastChord;
                      else
                        measureStartChord = null;
                    }
                    if (elem.chord)
                      lastChord = elem;
                    if (elem.el_type === "bar") {
                      if (hasNotes) {
                        var frag = tune.abc.substring(fragStart, elem.endChar);
                        var measure = { abc: frag };
                        lastChord = measureStartChord && measureStartChord.chord && measureStartChord.chord.length > 0 ? measureStartChord.chord[0].name : null;
                        if (lastChord)
                          measure.lastChord = lastChord;
                        if (elem.startEnding)
                          measure.startEnding = elem.startEnding;
                        if (elem.endEnding)
                          measure.endEnding = elem.endEnding;
                        measures.push(measure);
                        fragStart = null;
                        hasNotes = false;
                      }
                    } else if (elem.el_type === "note") {
                      hasNotes = true;
                    }
                  }
                }
              }
            }
          }
          tunes.push({
            header,
            measures,
            hasPickup
          });
        }
        return tunes;
      };
    })();
    module.exports = tunebook;
  }
});

// node_modules/abcjs/src/write/abc_beam_element.js
var require_abc_beam_element = __commonJS({
  "node_modules/abcjs/src/write/abc_beam_element.js"(exports, module) {
    var BeamElem = function BeamElem2(stemHeight, type, flat, firstElement) {
      this.type = "BeamElem";
      this.isflat = !!flat;
      this.isgrace = !!(type && type === "grace");
      this.forceup = !!(this.isgrace || type && type === "up");
      this.forcedown = !!(type && type === "down");
      this.elems = [];
      this.total = 0;
      this.average = 6;
      this.allrests = true;
      this.stemHeight = stemHeight;
      this.beams = [];
      if (firstElement && firstElement.duration) {
        this.duration = firstElement.duration;
        if (firstElement.startTriplet) {
          this.duration *= firstElement.tripletMultiplier;
        }
        this.duration = Math.round(this.duration * 1e3) / 1e3;
      } else
        this.duration = 0;
    };
    BeamElem.prototype.setHint = function() {
      this.hint = true;
    };
    BeamElem.prototype.add = function(abselem) {
      var pitch = abselem.abcelem.averagepitch;
      if (pitch === void 0)
        return;
      if (!abselem.abcelem.rest)
        this.allrests = false;
      abselem.beam = this;
      this.elems.push(abselem);
      this.total = Math.round(this.total + pitch);
      if (this.min === void 0 || abselem.abcelem.minpitch < this.min) {
        this.min = abselem.abcelem.minpitch;
      }
      if (this.max === void 0 || abselem.abcelem.maxpitch > this.max) {
        this.max = abselem.abcelem.maxpitch;
      }
    };
    BeamElem.prototype.addBeam = function(beam) {
      this.beams.push(beam);
    };
    BeamElem.prototype.calcDir = function() {
      this.average = calcAverage(this.total, this.elems.length);
      if (this.forceup) {
        this.stemsUp = true;
      } else if (this.forcedown) {
        this.stemsUp = false;
      } else {
        var middleLine = 6;
        this.stemsUp = this.average < middleLine;
      }
      var dir = this.stemsUp ? "up" : "down";
      for (var i = 0; i < this.elems.length; i++) {
        for (var j = 0; j < this.elems[i].heads.length; j++) {
          this.elems[i].heads[j].stemDir = dir;
        }
      }
    };
    function calcAverage(total, numElements) {
      if (!numElements)
        return 0;
      return total / numElements;
    }
    module.exports = BeamElem;
  }
});

// node_modules/abcjs/src/write/abc_brace_element.js
var require_abc_brace_element = __commonJS({
  "node_modules/abcjs/src/write/abc_brace_element.js"(exports, module) {
    var BraceElem = function BraceElem2(voice, type) {
      this.startVoice = voice;
      this.type = type;
    };
    BraceElem.prototype.setBottomStaff = function(voice) {
      this.endVoice = voice;
      if (this.startVoice.header && !this.endVoice.header) {
        this.header = this.startVoice.header;
        delete this.startVoice.header;
      }
    };
    BraceElem.prototype.continuing = function(voice) {
      this.lastContinuedVoice = voice;
    };
    BraceElem.prototype.getWidth = function() {
      return 10;
    };
    BraceElem.prototype.isStartVoice = function(voice) {
      if (this.startVoice && this.startVoice.staff && this.startVoice.staff.voices.length > 0 && this.startVoice.staff.voices[0] === voice)
        return true;
      return false;
    };
    module.exports = BraceElem;
  }
});

// node_modules/abcjs/src/write/abc_glyphs.js
var require_abc_glyphs = __commonJS({
  "node_modules/abcjs/src/write/abc_glyphs.js"(exports, module) {
    var spacing = require_abc_spacing();
    var glyphs = {
      "0": { d: [["M", 4.83, -14.97], ["c", 0.33, -0.03, 1.11, 0, 1.47, 0.06], ["c", 1.68, 0.36, 2.97, 1.59, 3.78, 3.6], ["c", 1.2, 2.97, 0.81, 6.96, -0.9, 9.27], ["c", -0.78, 1.08, -1.71, 1.71, -2.91, 1.95], ["c", -0.45, 0.09, -1.32, 0.09, -1.77, 0], ["c", -0.81, -0.18, -1.47, -0.51, -2.07, -1.02], ["c", -2.34, -2.07, -3.15, -6.72, -1.74, -10.2], ["c", 0.87, -2.16, 2.28, -3.42, 4.14, -3.66], ["z"], ["m", 1.11, 0.87], ["c", -0.21, -0.06, -0.69, -0.09, -0.87, -0.06], ["c", -0.54, 0.12, -0.87, 0.42, -1.17, 0.99], ["c", -0.36, 0.66, -0.51, 1.56, -0.6, 3], ["c", -0.03, 0.75, -0.03, 4.59, 0, 5.31], ["c", 0.09, 1.5, 0.27, 2.4, 0.6, 3.06], ["c", 0.24, 0.48, 0.57, 0.78, 0.96, 0.9], ["c", 0.27, 0.09, 0.78, 0.09, 1.05, 0], ["c", 0.39, -0.12, 0.72, -0.42, 0.96, -0.9], ["c", 0.33, -0.66, 0.51, -1.56, 0.6, -3.06], ["c", 0.03, -0.72, 0.03, -4.56, 0, -5.31], ["c", -0.09, -1.47, -0.27, -2.37, -0.6, -3.03], ["c", -0.24, -0.48, -0.54, -0.78, -0.93, -0.9], ["z"]], w: 10.78, h: 14.959 },
      "1": { d: [["M", 3.3, -15.06], ["c", 0.06, -0.06, 0.21, -0.03, 0.66, 0.15], ["c", 0.81, 0.39, 1.08, 0.39, 1.83, 0.03], ["c", 0.21, -0.09, 0.39, -0.15, 0.42, -0.15], ["c", 0.12, 0, 0.21, 0.09, 0.27, 0.21], ["c", 0.06, 0.12, 0.06, 0.33, 0.06, 5.94], ["c", 0, 3.93, 0, 5.85, 0.03, 6.03], ["c", 0.06, 0.36, 0.15, 0.69, 0.27, 0.96], ["c", 0.36, 0.75, 0.93, 1.17, 1.68, 1.26], ["c", 0.3, 0.03, 0.39, 0.09, 0.39, 0.3], ["c", 0, 0.15, -0.03, 0.18, -0.09, 0.24], ["c", -0.06, 0.06, -0.09, 0.06, -0.48, 0.06], ["c", -0.42, 0, -0.69, -0.03, -2.1, -0.24], ["c", -0.9, -0.15, -1.77, -0.15, -2.67, 0], ["c", -1.41, 0.21, -1.68, 0.24, -2.1, 0.24], ["c", -0.39, 0, -0.42, 0, -0.48, -0.06], ["c", -0.06, -0.06, -0.06, -0.09, -0.06, -0.24], ["c", 0, -0.21, 0.06, -0.27, 0.36, -0.3], ["c", 0.75, -0.09, 1.32, -0.51, 1.68, -1.26], ["c", 0.12, -0.27, 0.21, -0.6, 0.27, -0.96], ["c", 0.03, -0.18, 0.03, -1.59, 0.03, -4.29], ["c", 0, -3.87, 0, -4.05, -0.06, -4.14], ["c", -0.09, -0.15, -0.18, -0.24, -0.39, -0.24], ["c", -0.12, 0, -0.15, 0.03, -0.21, 0.06], ["c", -0.03, 0.06, -0.45, 0.99, -0.96, 2.13], ["c", -0.48, 1.14, -0.9, 2.1, -0.93, 2.16], ["c", -0.06, 0.15, -0.21, 0.24, -0.33, 0.24], ["c", -0.24, 0, -0.42, -0.18, -0.42, -0.39], ["c", 0, -0.06, 3.27, -7.62, 3.33, -7.74], ["z"]], w: 8.94, h: 15.058 },
      "2": { d: [["M", 4.23, -14.97], ["c", 0.57, -0.06, 1.68, 0, 2.34, 0.18], ["c", 0.69, 0.18, 1.5, 0.54, 2.01, 0.9], ["c", 1.35, 0.96, 1.95, 2.25, 1.77, 3.81], ["c", -0.15, 1.35, -0.66, 2.34, -1.68, 3.15], ["c", -0.6, 0.48, -1.44, 0.93, -3.12, 1.65], ["c", -1.32, 0.57, -1.8, 0.81, -2.37, 1.14], ["c", -0.57, 0.33, -0.57, 0.33, -0.24, 0.27], ["c", 0.39, -0.09, 1.26, -0.09, 1.68, 0], ["c", 0.72, 0.15, 1.41, 0.45, 2.1, 0.9], ["c", 0.99, 0.63, 1.86, 0.87, 2.55, 0.75], ["c", 0.24, -0.06, 0.42, -0.15, 0.57, -0.3], ["c", 0.12, -0.09, 0.3, -0.42, 0.3, -0.51], ["c", 0, -0.09, 0.12, -0.21, 0.24, -0.24], ["c", 0.18, -0.03, 0.39, 0.12, 0.39, 0.3], ["c", 0, 0.12, -0.15, 0.57, -0.3, 0.87], ["c", -0.54, 1.02, -1.56, 1.74, -2.79, 2.01], ["c", -0.42, 0.09, -1.23, 0.09, -1.62, 0.03], ["c", -0.81, -0.18, -1.32, -0.45, -2.01, -1.11], ["c", -0.45, -0.45, -0.63, -0.57, -0.96, -0.69], ["c", -0.84, -0.27, -1.89, 0.12, -2.25, 0.9], ["c", -0.12, 0.21, -0.21, 0.54, -0.21, 0.72], ["c", 0, 0.12, -0.12, 0.21, -0.27, 0.24], ["c", -0.15, 0, -0.27, -0.03, -0.33, -0.15], ["c", -0.09, -0.21, 0.09, -1.08, 0.33, -1.71], ["c", 0.24, -0.66, 0.66, -1.26, 1.29, -1.89], ["c", 0.45, -0.45, 0.9, -0.81, 1.92, -1.56], ["c", 1.29, -0.93, 1.89, -1.44, 2.34, -1.98], ["c", 0.87, -1.05, 1.26, -2.19, 1.2, -3.63], ["c", -0.06, -1.29, -0.39, -2.31, -0.96, -2.91], ["c", -0.36, -0.33, -0.72, -0.51, -1.17, -0.54], ["c", -0.84, -0.03, -1.53, 0.42, -1.59, 1.05], ["c", -0.03, 0.33, 0.12, 0.6, 0.57, 1.14], ["c", 0.45, 0.54, 0.54, 0.87, 0.42, 1.41], ["c", -0.15, 0.63, -0.54, 1.11, -1.08, 1.38], ["c", -0.63, 0.33, -1.2, 0.33, -1.83, 0], ["c", -0.24, -0.12, -0.33, -0.18, -0.54, -0.39], ["c", -0.18, -0.18, -0.27, -0.3, -0.36, -0.51], ["c", -0.24, -0.45, -0.27, -0.84, -0.21, -1.38], ["c", 0.12, -0.75, 0.45, -1.41, 1.02, -1.98], ["c", 0.72, -0.72, 1.74, -1.17, 2.85, -1.32], ["z"]], w: 10.764, h: 14.97 },
      "3": { d: [["M", 3.78, -14.97], ["c", 0.3, -0.03, 1.41, 0, 1.83, 0.06], ["c", 2.22, 0.3, 3.51, 1.32, 3.72, 2.91], ["c", 0.03, 0.33, 0.03, 1.26, -0.03, 1.65], ["c", -0.12, 0.84, -0.48, 1.47, -1.05, 1.77], ["c", -0.27, 0.15, -0.36, 0.24, -0.45, 0.39], ["c", -0.09, 0.21, -0.09, 0.36, 0, 0.57], ["c", 0.09, 0.15, 0.18, 0.24, 0.51, 0.39], ["c", 0.75, 0.42, 1.23, 1.14, 1.41, 2.13], ["c", 0.06, 0.42, 0.06, 1.35, 0, 1.71], ["c", -0.18, 0.81, -0.48, 1.38, -1.02, 1.95], ["c", -0.75, 0.72, -1.8, 1.2, -3.18, 1.38], ["c", -0.42, 0.06, -1.56, 0.06, -1.95, 0], ["c", -1.89, -0.33, -3.18, -1.29, -3.51, -2.64], ["c", -0.03, -0.12, -0.03, -0.33, -0.03, -0.6], ["c", 0, -0.36, 0, -0.42, 0.06, -0.63], ["c", 0.12, -0.3, 0.27, -0.51, 0.51, -0.75], ["c", 0.24, -0.24, 0.45, -0.39, 0.75, -0.51], ["c", 0.21, -0.06, 0.27, -0.06, 0.6, -0.06], ["c", 0.33, 0, 0.39, 0, 0.6, 0.06], ["c", 0.3, 0.12, 0.51, 0.27, 0.75, 0.51], ["c", 0.36, 0.33, 0.57, 0.75, 0.6, 1.2], ["c", 0, 0.21, 0, 0.27, -0.06, 0.42], ["c", -0.09, 0.18, -0.12, 0.24, -0.54, 0.54], ["c", -0.51, 0.36, -0.63, 0.54, -0.6, 0.87], ["c", 0.06, 0.54, 0.54, 0.9, 1.38, 0.99], ["c", 0.36, 0.06, 0.72, 0.03, 0.96, -0.06], ["c", 0.81, -0.27, 1.29, -1.23, 1.44, -2.79], ["c", 0.03, -0.45, 0.03, -1.95, -0.03, -2.37], ["c", -0.09, -0.75, -0.33, -1.23, -0.75, -1.44], ["c", -0.33, -0.18, -0.45, -0.18, -1.98, -0.18], ["c", -1.35, 0, -1.41, 0, -1.5, -0.06], ["c", -0.18, -0.12, -0.24, -0.39, -0.12, -0.6], ["c", 0.12, -0.15, 0.15, -0.15, 1.68, -0.15], ["c", 1.5, 0, 1.62, 0, 1.89, -0.15], ["c", 0.18, -0.09, 0.42, -0.36, 0.54, -0.57], ["c", 0.18, -0.42, 0.27, -0.9, 0.3, -1.95], ["c", 0.03, -1.2, -0.06, -1.8, -0.36, -2.37], ["c", -0.24, -0.48, -0.63, -0.81, -1.14, -0.96], ["c", -0.3, -0.06, -1.08, -0.06, -1.38, 0.03], ["c", -0.6, 0.15, -0.9, 0.42, -0.96, 0.84], ["c", -0.03, 0.3, 0.06, 0.45, 0.63, 0.84], ["c", 0.33, 0.24, 0.42, 0.39, 0.45, 0.63], ["c", 0.03, 0.72, -0.57, 1.5, -1.32, 1.65], ["c", -1.05, 0.27, -2.1, -0.57, -2.1, -1.65], ["c", 0, -0.45, 0.15, -0.96, 0.39, -1.38], ["c", 0.12, -0.21, 0.54, -0.63, 0.81, -0.81], ["c", 0.57, -0.42, 1.38, -0.69, 2.25, -0.81], ["z"]], w: 9.735, h: 14.967 },
      "4": { d: [["M", 8.64, -14.94], ["c", 0.27, -0.09, 0.42, -0.12, 0.54, -0.03], ["c", 0.09, 0.06, 0.15, 0.21, 0.15, 0.3], ["c", -0.03, 0.06, -1.92, 2.31, -4.23, 5.04], ["c", -2.31, 2.73, -4.23, 4.98, -4.26, 5.01], ["c", -0.03, 0.06, 0.12, 0.06, 2.55, 0.06], ["l", 2.61, 0], ["l", 0, -2.37], ["c", 0, -2.19, 0.03, -2.37, 0.06, -2.46], ["c", 0.03, -0.06, 0.21, -0.18, 0.57, -0.42], ["c", 1.08, -0.72, 1.38, -1.08, 1.86, -2.16], ["c", 0.12, -0.3, 0.24, -0.54, 0.27, -0.57], ["c", 0.12, -0.12, 0.39, -0.06, 0.45, 0.12], ["c", 0.06, 0.09, 0.06, 0.57, 0.06, 3.96], ["l", 0, 3.9], ["l", 1.08, 0], ["c", 1.05, 0, 1.11, 0, 1.2, 0.06], ["c", 0.24, 0.15, 0.24, 0.54, 0, 0.69], ["c", -0.09, 0.06, -0.15, 0.06, -1.2, 0.06], ["l", -1.08, 0], ["l", 0, 0.33], ["c", 0, 0.57, 0.09, 1.11, 0.3, 1.53], ["c", 0.36, 0.75, 0.93, 1.17, 1.68, 1.26], ["c", 0.3, 0.03, 0.39, 0.09, 0.39, 0.3], ["c", 0, 0.15, -0.03, 0.18, -0.09, 0.24], ["c", -0.06, 0.06, -0.09, 0.06, -0.48, 0.06], ["c", -0.42, 0, -0.69, -0.03, -2.1, -0.24], ["c", -0.9, -0.15, -1.77, -0.15, -2.67, 0], ["c", -1.41, 0.21, -1.68, 0.24, -2.1, 0.24], ["c", -0.39, 0, -0.42, 0, -0.48, -0.06], ["c", -0.06, -0.06, -0.06, -0.09, -0.06, -0.24], ["c", 0, -0.21, 0.06, -0.27, 0.36, -0.3], ["c", 0.75, -0.09, 1.32, -0.51, 1.68, -1.26], ["c", 0.21, -0.42, 0.3, -0.96, 0.3, -1.53], ["l", 0, -0.33], ["l", -2.7, 0], ["c", -2.91, 0, -2.85, 0, -3.09, -0.15], ["c", -0.18, -0.12, -0.3, -0.39, -0.27, -0.54], ["c", 0.03, -0.06, 0.18, -0.24, 0.33, -0.45], ["c", 0.75, -0.9, 1.59, -2.07, 2.13, -3.03], ["c", 0.33, -0.54, 0.84, -1.62, 1.05, -2.16], ["c", 0.57, -1.41, 0.84, -2.64, 0.9, -4.05], ["c", 0.03, -0.63, 0.06, -0.72, 0.24, -0.81], ["l", 0.12, -0.06], ["l", 0.45, 0.12], ["c", 0.66, 0.18, 1.02, 0.24, 1.47, 0.27], ["c", 0.6, 0.03, 1.23, -0.09, 2.01, -0.33], ["z"]], w: 11.795, h: 14.994 },
      "5": { d: [["M", 1.02, -14.94], ["c", 0.12, -0.09, 0.03, -0.09, 1.08, 0.06], ["c", 2.49, 0.36, 4.35, 0.36, 6.96, -0.06], ["c", 0.57, -0.09, 0.66, -0.06, 0.81, 0.06], ["c", 0.15, 0.18, 0.12, 0.24, -0.15, 0.51], ["c", -1.29, 1.26, -3.24, 2.04, -5.58, 2.31], ["c", -0.6, 0.09, -1.2, 0.12, -1.71, 0.12], ["c", -0.39, 0, -0.45, 0, -0.57, 0.06], ["c", -0.09, 0.06, -0.15, 0.12, -0.21, 0.21], ["l", -0.06, 0.12], ["l", 0, 1.65], ["l", 0, 1.65], ["l", 0.21, -0.21], ["c", 0.66, -0.57, 1.41, -0.96, 2.19, -1.14], ["c", 0.33, -0.06, 1.41, -0.06, 1.95, 0], ["c", 2.61, 0.36, 4.02, 1.74, 4.26, 4.14], ["c", 0.03, 0.45, 0.03, 1.08, -0.03, 1.44], ["c", -0.18, 1.02, -0.78, 2.01, -1.59, 2.7], ["c", -0.72, 0.57, -1.62, 1.02, -2.49, 1.2], ["c", -1.38, 0.27, -3.03, 0.06, -4.2, -0.54], ["c", -1.08, -0.54, -1.71, -1.32, -1.86, -2.28], ["c", -0.09, -0.69, 0.09, -1.29, 0.57, -1.74], ["c", 0.24, -0.24, 0.45, -0.39, 0.75, -0.51], ["c", 0.21, -0.06, 0.27, -0.06, 0.6, -0.06], ["c", 0.33, 0, 0.39, 0, 0.6, 0.06], ["c", 0.3, 0.12, 0.51, 0.27, 0.75, 0.51], ["c", 0.36, 0.33, 0.57, 0.75, 0.6, 1.2], ["c", 0, 0.21, 0, 0.27, -0.06, 0.42], ["c", -0.09, 0.18, -0.12, 0.24, -0.54, 0.54], ["c", -0.18, 0.12, -0.36, 0.3, -0.42, 0.33], ["c", -0.36, 0.42, -0.18, 0.99, 0.36, 1.26], ["c", 0.51, 0.27, 1.47, 0.36, 2.01, 0.27], ["c", 0.93, -0.21, 1.47, -1.17, 1.65, -2.91], ["c", 0.06, -0.45, 0.06, -1.89, 0, -2.31], ["c", -0.15, -1.2, -0.51, -2.1, -1.05, -2.55], ["c", -0.21, -0.18, -0.54, -0.36, -0.81, -0.39], ["c", -0.3, -0.06, -0.84, -0.03, -1.26, 0.06], ["c", -0.93, 0.18, -1.65, 0.6, -2.16, 1.2], ["c", -0.15, 0.21, -0.27, 0.3, -0.39, 0.3], ["c", -0.15, 0, -0.3, -0.09, -0.36, -0.18], ["c", -0.06, -0.09, -0.06, -0.15, -0.06, -3.66], ["c", 0, -3.39, 0, -3.57, 0.06, -3.66], ["c", 0.03, -0.06, 0.09, -0.15, 0.15, -0.18], ["z"]], w: 10.212, h: 14.997 },
      "6": { d: [["M", 4.98, -14.97], ["c", 0.36, -0.03, 1.2, 0, 1.59, 0.06], ["c", 0.9, 0.15, 1.68, 0.51, 2.25, 1.05], ["c", 0.57, 0.51, 0.87, 1.23, 0.84, 1.98], ["c", -0.03, 0.51, -0.21, 0.9, -0.6, 1.26], ["c", -0.24, 0.24, -0.45, 0.39, -0.75, 0.51], ["c", -0.21, 0.06, -0.27, 0.06, -0.6, 0.06], ["c", -0.33, 0, -0.39, 0, -0.6, -0.06], ["c", -0.3, -0.12, -0.51, -0.27, -0.75, -0.51], ["c", -0.39, -0.36, -0.57, -0.78, -0.57, -1.26], ["c", 0, -0.27, 0, -0.3, 0.09, -0.42], ["c", 0.03, -0.09, 0.18, -0.21, 0.3, -0.3], ["c", 0.12, -0.09, 0.3, -0.21, 0.39, -0.27], ["c", 0.09, -0.06, 0.21, -0.18, 0.27, -0.24], ["c", 0.06, -0.12, 0.09, -0.15, 0.09, -0.33], ["c", 0, -0.18, -0.03, -0.24, -0.09, -0.36], ["c", -0.24, -0.39, -0.75, -0.6, -1.38, -0.57], ["c", -0.54, 0.03, -0.9, 0.18, -1.23, 0.48], ["c", -0.81, 0.72, -1.08, 2.16, -0.96, 5.37], ["l", 0, 0.63], ["l", 0.3, -0.12], ["c", 0.78, -0.27, 1.29, -0.33, 2.1, -0.27], ["c", 1.47, 0.12, 2.49, 0.54, 3.27, 1.29], ["c", 0.48, 0.51, 0.81, 1.11, 0.96, 1.89], ["c", 0.06, 0.27, 0.06, 0.42, 0.06, 0.93], ["c", 0, 0.54, 0, 0.69, -0.06, 0.96], ["c", -0.15, 0.78, -0.48, 1.38, -0.96, 1.89], ["c", -0.54, 0.51, -1.17, 0.87, -1.98, 1.08], ["c", -1.14, 0.3, -2.4, 0.33, -3.24, 0.03], ["c", -1.5, -0.48, -2.64, -1.89, -3.27, -4.02], ["c", -0.36, -1.23, -0.51, -2.82, -0.42, -4.08], ["c", 0.3, -3.66, 2.28, -6.3, 4.95, -6.66], ["z"], ["m", 0.66, 7.41], ["c", -0.27, -0.09, -0.81, -0.12, -1.08, -0.06], ["c", -0.72, 0.18, -1.08, 0.69, -1.23, 1.71], ["c", -0.06, 0.54, -0.06, 3, 0, 3.54], ["c", 0.18, 1.26, 0.72, 1.77, 1.8, 1.74], ["c", 0.39, -0.03, 0.63, -0.09, 0.9, -0.27], ["c", 0.66, -0.42, 0.9, -1.32, 0.9, -3.24], ["c", 0, -2.22, -0.36, -3.12, -1.29, -3.42], ["z"]], w: 9.956, h: 14.982 },
      "7": { d: [["M", 0.21, -14.97], ["c", 0.21, -0.06, 0.45, 0, 0.54, 0.15], ["c", 0.06, 0.09, 0.06, 0.15, 0.06, 0.39], ["c", 0, 0.24, 0, 0.33, 0.06, 0.42], ["c", 0.06, 0.12, 0.21, 0.24, 0.27, 0.24], ["c", 0.03, 0, 0.12, -0.12, 0.24, -0.21], ["c", 0.96, -1.2, 2.58, -1.35, 3.99, -0.42], ["c", 0.15, 0.12, 0.42, 0.3, 0.54, 0.45], ["c", 0.48, 0.39, 0.81, 0.57, 1.29, 0.6], ["c", 0.69, 0.03, 1.5, -0.3, 2.13, -0.87], ["c", 0.09, -0.09, 0.27, -0.3, 0.39, -0.45], ["c", 0.12, -0.15, 0.24, -0.27, 0.3, -0.3], ["c", 0.18, -0.06, 0.39, 0.03, 0.51, 0.21], ["c", 0.06, 0.18, 0.06, 0.24, -0.27, 0.72], ["c", -0.18, 0.24, -0.54, 0.78, -0.78, 1.17], ["c", -2.37, 3.54, -3.54, 6.27, -3.87, 9], ["c", -0.03, 0.33, -0.03, 0.66, -0.03, 1.26], ["c", 0, 0.9, 0, 1.08, 0.15, 1.89], ["c", 0.06, 0.45, 0.06, 0.48, 0.03, 0.6], ["c", -0.06, 0.09, -0.21, 0.21, -0.3, 0.21], ["c", -0.03, 0, -0.27, -0.06, -0.54, -0.15], ["c", -0.84, -0.27, -1.11, -0.3, -1.65, -0.3], ["c", -0.57, 0, -0.84, 0.03, -1.56, 0.27], ["c", -0.6, 0.18, -0.69, 0.21, -0.81, 0.15], ["c", -0.12, -0.06, -0.21, -0.18, -0.21, -0.3], ["c", 0, -0.15, 0.6, -1.44, 1.2, -2.61], ["c", 1.14, -2.22, 2.73, -4.68, 5.1, -8.01], ["c", 0.21, -0.27, 0.36, -0.48, 0.33, -0.48], ["c", 0, 0, -0.12, 0.06, -0.27, 0.12], ["c", -0.54, 0.3, -0.99, 0.39, -1.56, 0.39], ["c", -0.75, 0.03, -1.2, -0.18, -1.83, -0.75], ["c", -0.99, -0.9, -1.83, -1.17, -2.31, -0.72], ["c", -0.18, 0.15, -0.36, 0.51, -0.45, 0.84], ["c", -0.06, 0.24, -0.06, 0.33, -0.09, 1.98], ["c", 0, 1.62, -0.03, 1.74, -0.06, 1.8], ["c", -0.15, 0.24, -0.54, 0.24, -0.69, 0], ["c", -0.06, -0.09, -0.06, -0.15, -0.06, -3.57], ["c", 0, -3.42, 0, -3.48, 0.06, -3.57], ["c", 0.03, -0.06, 0.09, -0.12, 0.15, -0.15], ["z"]], w: 10.561, h: 15.093 },
      "8": { d: [["M", 4.98, -14.97], ["c", 0.33, -0.03, 1.02, -0.03, 1.32, 0], ["c", 1.32, 0.12, 2.49, 0.6, 3.21, 1.32], ["c", 0.39, 0.39, 0.66, 0.81, 0.78, 1.29], ["c", 0.09, 0.36, 0.09, 1.08, 0, 1.44], ["c", -0.21, 0.84, -0.66, 1.59, -1.59, 2.55], ["l", -0.3, 0.3], ["l", 0.27, 0.18], ["c", 1.47, 0.93, 2.31, 2.31, 2.25, 3.75], ["c", -0.03, 0.75, -0.24, 1.35, -0.63, 1.95], ["c", -0.45, 0.66, -1.02, 1.14, -1.83, 1.53], ["c", -1.8, 0.87, -4.2, 0.87, -6, 0.03], ["c", -1.62, -0.78, -2.52, -2.16, -2.46, -3.66], ["c", 0.06, -0.99, 0.54, -1.77, 1.8, -2.97], ["c", 0.54, -0.51, 0.54, -0.54, 0.48, -0.57], ["c", -0.39, -0.27, -0.96, -0.78, -1.2, -1.14], ["c", -0.75, -1.11, -0.87, -2.4, -0.3, -3.6], ["c", 0.69, -1.35, 2.25, -2.25, 4.2, -2.4], ["z"], ["m", 1.53, 0.69], ["c", -0.42, -0.09, -1.11, -0.12, -1.38, -0.06], ["c", -0.3, 0.06, -0.6, 0.18, -0.81, 0.3], ["c", -0.21, 0.12, -0.6, 0.51, -0.72, 0.72], ["c", -0.51, 0.87, -0.42, 1.89, 0.21, 2.52], ["c", 0.21, 0.21, 0.36, 0.3, 1.95, 1.23], ["c", 0.96, 0.54, 1.74, 0.99, 1.77, 1.02], ["c", 0.09, 0, 0.63, -0.6, 0.99, -1.11], ["c", 0.21, -0.36, 0.48, -0.87, 0.57, -1.23], ["c", 0.06, -0.24, 0.06, -0.36, 0.06, -0.72], ["c", 0, -0.45, -0.03, -0.66, -0.15, -0.99], ["c", -0.39, -0.81, -1.29, -1.44, -2.49, -1.68], ["z"], ["m", -1.44, 8.07], ["l", -1.89, -1.08], ["c", -0.03, 0, -0.18, 0.15, -0.39, 0.33], ["c", -1.2, 1.08, -1.65, 1.95, -1.59, 3], ["c", 0.09, 1.59, 1.35, 2.85, 3.21, 3.24], ["c", 0.33, 0.06, 0.45, 0.06, 0.93, 0.06], ["c", 0.63, 0, 0.81, -0.03, 1.29, -0.27], ["c", 0.9, -0.42, 1.47, -1.41, 1.41, -2.4], ["c", -0.06, -0.66, -0.39, -1.29, -0.9, -1.65], ["c", -0.12, -0.09, -1.05, -0.63, -2.07, -1.23], ["z"]], w: 10.926, h: 14.989 },
      "9": { d: [["M", 4.23, -14.97], ["c", 0.42, -0.03, 1.29, 0, 1.62, 0.06], ["c", 0.51, 0.12, 0.93, 0.3, 1.38, 0.57], ["c", 1.53, 1.02, 2.52, 3.24, 2.73, 5.94], ["c", 0.18, 2.55, -0.48, 4.98, -1.83, 6.57], ["c", -1.05, 1.26, -2.4, 1.89, -3.93, 1.83], ["c", -1.23, -0.06, -2.31, -0.45, -3.03, -1.14], ["c", -0.57, -0.51, -0.87, -1.23, -0.84, -1.98], ["c", 0.03, -0.51, 0.21, -0.9, 0.6, -1.26], ["c", 0.24, -0.24, 0.45, -0.39, 0.75, -0.51], ["c", 0.21, -0.06, 0.27, -0.06, 0.6, -0.06], ["c", 0.33, 0, 0.39, 0, 0.6, 0.06], ["c", 0.3, 0.12, 0.51, 0.27, 0.75, 0.51], ["c", 0.39, 0.36, 0.57, 0.78, 0.57, 1.26], ["c", 0, 0.27, 0, 0.3, -0.09, 0.42], ["c", -0.03, 0.09, -0.18, 0.21, -0.3, 0.3], ["c", -0.12, 0.09, -0.3, 0.21, -0.39, 0.27], ["c", -0.09, 0.06, -0.21, 0.18, -0.27, 0.24], ["c", -0.06, 0.12, -0.06, 0.15, -0.06, 0.33], ["c", 0, 0.18, 0, 0.24, 0.06, 0.36], ["c", 0.24, 0.39, 0.75, 0.6, 1.38, 0.57], ["c", 0.54, -0.03, 0.9, -0.18, 1.23, -0.48], ["c", 0.81, -0.72, 1.08, -2.16, 0.96, -5.37], ["l", 0, -0.63], ["l", -0.3, 0.12], ["c", -0.78, 0.27, -1.29, 0.33, -2.1, 0.27], ["c", -1.47, -0.12, -2.49, -0.54, -3.27, -1.29], ["c", -0.48, -0.51, -0.81, -1.11, -0.96, -1.89], ["c", -0.06, -0.27, -0.06, -0.42, -0.06, -0.96], ["c", 0, -0.51, 0, -0.66, 0.06, -0.93], ["c", 0.15, -0.78, 0.48, -1.38, 0.96, -1.89], ["c", 0.15, -0.12, 0.33, -0.27, 0.42, -0.36], ["c", 0.69, -0.51, 1.62, -0.81, 2.76, -0.93], ["z"], ["m", 1.17, 0.66], ["c", -0.21, -0.06, -0.57, -0.06, -0.81, -0.03], ["c", -0.78, 0.12, -1.26, 0.69, -1.41, 1.74], ["c", -0.12, 0.63, -0.15, 1.95, -0.09, 2.79], ["c", 0.12, 1.71, 0.63, 2.4, 1.77, 2.46], ["c", 1.08, 0.03, 1.62, -0.48, 1.8, -1.74], ["c", 0.06, -0.54, 0.06, -3, 0, -3.54], ["c", -0.15, -1.05, -0.51, -1.53, -1.26, -1.68], ["z"]], w: 9.959, h: 14.986 },
      "rests.multimeasure": { d: [["M", 0, -4], ["l", 0, 16], ["l", 1, 0], ["l", 0, -5], ["l", 40, 0], ["l", 0, 5], ["l", 1, 0], ["l", 0, -16], ["l", -1, 0], ["l", 0, 5], ["l", -40, 0], ["l", 0, -5], ["z"]], w: 42, h: 18 },
      "rests.whole": { d: [["M", 0.06, 0.03], ["l", 0.09, -0.06], ["l", 5.46, 0], ["l", 5.49, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 2.19], ["l", 0, 2.19], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -5.49, 0], ["l", -5.46, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -2.19], ["l", 0, -2.19], ["z"]], w: 11.25, h: 4.68 },
      "rests.half": { d: [["M", 0.06, -4.62], ["l", 0.09, -0.06], ["l", 5.46, 0], ["l", 5.49, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 2.19], ["l", 0, 2.19], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -5.49, 0], ["l", -5.46, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -2.19], ["l", 0, -2.19], ["z"]], w: 11.25, h: 4.68 },
      "rests.quarter": { d: [["M", 1.89, -11.82], ["c", 0.12, -0.06, 0.24, -0.06, 0.36, -0.03], ["c", 0.09, 0.06, 4.74, 5.58, 4.86, 5.82], ["c", 0.21, 0.39, 0.15, 0.78, -0.15, 1.26], ["c", -0.24, 0.33, -0.72, 0.81, -1.62, 1.56], ["c", -0.45, 0.36, -0.87, 0.75, -0.96, 0.84], ["c", -0.93, 0.99, -1.14, 2.49, -0.6, 3.63], ["c", 0.18, 0.39, 0.27, 0.48, 1.32, 1.68], ["c", 1.92, 2.25, 1.83, 2.16, 1.83, 2.34], ["c", 0, 0.18, -0.18, 0.36, -0.36, 0.39], ["c", -0.15, 0, -0.27, -0.06, -0.48, -0.27], ["c", -0.75, -0.75, -2.46, -1.29, -3.39, -1.08], ["c", -0.45, 0.09, -0.69, 0.27, -0.9, 0.69], ["c", -0.12, 0.3, -0.21, 0.66, -0.24, 1.14], ["c", -0.03, 0.66, 0.09, 1.35, 0.3, 2.01], ["c", 0.15, 0.42, 0.24, 0.66, 0.45, 0.96], ["c", 0.18, 0.24, 0.18, 0.33, 0.03, 0.42], ["c", -0.12, 0.06, -0.18, 0.03, -0.45, -0.3], ["c", -1.08, -1.38, -2.07, -3.36, -2.4, -4.83], ["c", -0.27, -1.05, -0.15, -1.77, 0.27, -2.07], ["c", 0.21, -0.12, 0.42, -0.15, 0.87, -0.15], ["c", 0.87, 0.06, 2.1, 0.39, 3.3, 0.9], ["l", 0.39, 0.18], ["l", -1.65, -1.95], ["c", -2.52, -2.97, -2.61, -3.09, -2.7, -3.27], ["c", -0.09, -0.24, -0.12, -0.48, -0.03, -0.75], ["c", 0.15, -0.48, 0.57, -0.96, 1.83, -2.01], ["c", 0.45, -0.36, 0.84, -0.72, 0.93, -0.78], ["c", 0.69, -0.75, 1.02, -1.8, 0.9, -2.79], ["c", -0.06, -0.33, -0.21, -0.84, -0.39, -1.11], ["c", -0.09, -0.15, -0.45, -0.6, -0.81, -1.05], ["c", -0.36, -0.42, -0.69, -0.81, -0.72, -0.87], ["c", -0.09, -0.18, 0, -0.42, 0.21, -0.51], ["z"]], w: 7.888, h: 21.435 },
      "rests.8th": { d: [["M", 1.68, -6.12], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.12, 0, 0.18, 0, 0.33, -0.09], ["c", 0.39, -0.18, 1.32, -1.29, 1.68, -1.98], ["c", 0.09, -0.21, 0.24, -0.3, 0.39, -0.3], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.27, 1.11, -1.86, 6.42], ["c", -1.02, 3.48, -1.89, 6.39, -1.92, 6.42], ["c", 0, 0.03, -0.12, 0.12, -0.24, 0.15], ["c", -0.18, 0.09, -0.21, 0.09, -0.45, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.15, -0.57, 1.68, -4.92], ["c", 0.96, -2.67, 1.74, -4.89, 1.71, -4.89], ["l", -0.51, 0.15], ["c", -1.08, 0.36, -1.74, 0.48, -2.55, 0.48], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 7.534, h: 13.883 },
      "rests.16th": { d: [["M", 3.33, -6.12], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.15, 0.39, 0.57, 0.57, 0.87, 0.42], ["c", 0.39, -0.18, 1.2, -1.23, 1.62, -2.07], ["c", 0.06, -0.15, 0.24, -0.24, 0.36, -0.24], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.45, 1.86, -2.67, 10.17], ["c", -1.5, 5.55, -2.73, 10.14, -2.76, 10.17], ["c", -0.03, 0.03, -0.12, 0.12, -0.24, 0.15], ["c", -0.18, 0.09, -0.21, 0.09, -0.45, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.12, -0.57, 1.44, -4.92], ["c", 0.81, -2.67, 1.47, -4.86, 1.47, -4.89], ["c", -0.03, 0, -0.27, 0.06, -0.54, 0.15], ["c", -1.08, 0.36, -1.77, 0.48, -2.58, 0.48], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.09, 0.09, 0.27, 0.18, 0.45, 0.21], ["c", 0.12, 0, 0.18, 0, 0.33, -0.09], ["c", 0.33, -0.15, 1.02, -0.93, 1.41, -1.59], ["c", 0.12, -0.21, 0.18, -0.39, 0.39, -1.08], ["c", 0.66, -2.1, 1.17, -3.84, 1.17, -3.87], ["c", 0, 0, -0.21, 0.06, -0.42, 0.15], ["c", -0.51, 0.15, -1.2, 0.33, -1.68, 0.42], ["c", -0.33, 0.06, -0.51, 0.06, -0.96, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 9.724, h: 21.383 },
      "rests.32nd": { d: [["M", 4.23, -13.62], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.12, 0, 0.18, 0, 0.27, -0.06], ["c", 0.33, -0.21, 0.99, -1.11, 1.44, -1.98], ["c", 0.09, -0.24, 0.21, -0.33, 0.39, -0.33], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.57, 2.67, -3.21, 13.89], ["c", -1.8, 7.62, -3.3, 13.89, -3.3, 13.92], ["c", -0.03, 0.06, -0.12, 0.12, -0.24, 0.18], ["c", -0.21, 0.09, -0.24, 0.09, -0.48, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.09, -0.57, 1.23, -4.92], ["c", 0.69, -2.67, 1.26, -4.86, 1.29, -4.89], ["c", 0, -0.03, -0.12, -0.03, -0.48, 0.12], ["c", -1.17, 0.39, -2.22, 0.57, -3, 0.54], ["c", -0.42, -0.03, -0.75, -0.12, -1.11, -0.3], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.12, 0.09, 0.3, 0.18, 0.48, 0.21], ["c", 0.12, 0, 0.18, 0, 0.3, -0.09], ["c", 0.42, -0.21, 1.29, -1.29, 1.56, -1.89], ["c", 0.03, -0.12, 1.23, -4.59, 1.23, -4.65], ["c", 0, -0.03, -0.18, 0.03, -0.39, 0.12], ["c", -0.63, 0.18, -1.2, 0.36, -1.74, 0.45], ["c", -0.39, 0.06, -0.54, 0.06, -1.02, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.18, 0.18, 0.51, 0.27, 0.72, 0.15], ["c", 0.3, -0.12, 0.69, -0.57, 1.08, -1.17], ["c", 0.42, -0.6, 0.39, -0.51, 1.05, -3.03], ["c", 0.33, -1.26, 0.6, -2.31, 0.6, -2.34], ["c", 0, 0, -0.21, 0.03, -0.45, 0.12], ["c", -0.57, 0.18, -1.14, 0.33, -1.62, 0.42], ["c", -0.33, 0.06, -0.51, 0.06, -0.96, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 11.373, h: 28.883 },
      "rests.64th": { d: [["M", 5.13, -13.62], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.15, 0.63, 0.21, 0.81, 0.33, 0.96], ["c", 0.18, 0.21, 0.54, 0.3, 0.75, 0.18], ["c", 0.24, -0.12, 0.63, -0.66, 1.08, -1.56], ["c", 0.33, -0.66, 0.39, -0.72, 0.6, -0.72], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.69, 3.66, -3.54, 17.64], ["c", -1.95, 9.66, -3.57, 17.61, -3.57, 17.64], ["c", -0.03, 0.06, -0.12, 0.12, -0.24, 0.18], ["c", -0.21, 0.09, -0.24, 0.09, -0.48, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.06, -0.57, 1.05, -4.95], ["c", 0.6, -2.7, 1.08, -4.89, 1.08, -4.92], ["c", 0, 0, -0.24, 0.06, -0.51, 0.15], ["c", -0.66, 0.24, -1.2, 0.36, -1.77, 0.48], ["c", -0.42, 0.06, -0.57, 0.06, -1.05, 0.06], ["c", -0.69, 0, -0.87, -0.03, -1.35, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.09, 0.09, 0.27, 0.18, 0.45, 0.21], ["c", 0.21, 0.03, 0.39, -0.09, 0.72, -0.42], ["c", 0.45, -0.45, 1.02, -1.26, 1.17, -1.65], ["c", 0.03, -0.09, 0.27, -1.14, 0.54, -2.34], ["c", 0.27, -1.2, 0.48, -2.19, 0.51, -2.22], ["c", 0, -0.03, -0.09, -0.03, -0.48, 0.12], ["c", -1.17, 0.39, -2.22, 0.57, -3, 0.54], ["c", -0.42, -0.03, -0.75, -0.12, -1.11, -0.3], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.15, 0.39, 0.57, 0.57, 0.9, 0.42], ["c", 0.36, -0.18, 1.2, -1.26, 1.47, -1.89], ["c", 0.03, -0.09, 0.3, -1.2, 0.57, -2.43], ["l", 0.51, -2.28], ["l", -0.54, 0.18], ["c", -1.11, 0.36, -1.8, 0.48, -2.61, 0.48], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.15, 0.63, 0.21, 0.81, 0.33, 0.96], ["c", 0.21, 0.21, 0.54, 0.3, 0.75, 0.18], ["c", 0.36, -0.18, 0.93, -0.93, 1.29, -1.68], ["c", 0.12, -0.24, 0.18, -0.48, 0.63, -2.55], ["l", 0.51, -2.31], ["c", 0, -0.03, -0.18, 0.03, -0.39, 0.12], ["c", -1.14, 0.36, -2.1, 0.54, -2.82, 0.51], ["c", -0.42, -0.03, -0.75, -0.12, -1.11, -0.3], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 12.453, h: 36.383 },
      "rests.128th": { d: [["M", 6.03, -21.12], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.21, 0, 0.33, -0.06, 0.54, -0.36], ["c", 0.15, -0.21, 0.54, -0.93, 0.78, -1.47], ["c", 0.15, -0.33, 0.18, -0.39, 0.3, -0.48], ["c", 0.18, -0.09, 0.45, 0, 0.51, 0.15], ["c", 0.03, 0.09, -7.11, 42.75, -7.17, 42.84], ["c", -0.03, 0.03, -0.15, 0.09, -0.24, 0.15], ["c", -0.18, 0.06, -0.24, 0.06, -0.45, 0.06], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.03, -0.57, 0.84, -4.98], ["c", 0.51, -2.7, 0.93, -4.92, 0.9, -4.92], ["c", 0, 0, -0.15, 0.06, -0.36, 0.12], ["c", -0.78, 0.27, -1.62, 0.48, -2.31, 0.57], ["c", -0.15, 0.03, -0.54, 0.03, -0.81, 0.03], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.63, 0.48], ["c", 0.12, 0, 0.18, 0, 0.3, -0.09], ["c", 0.42, -0.21, 1.14, -1.11, 1.5, -1.83], ["c", 0.12, -0.27, 0.12, -0.27, 0.54, -2.52], ["c", 0.24, -1.23, 0.42, -2.25, 0.39, -2.25], ["c", 0, 0, -0.24, 0.06, -0.51, 0.18], ["c", -1.26, 0.39, -2.25, 0.57, -3.06, 0.54], ["c", -0.42, -0.03, -0.75, -0.12, -1.11, -0.3], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.15, 0.63, 0.21, 0.81, 0.33, 0.96], ["c", 0.18, 0.21, 0.51, 0.3, 0.75, 0.18], ["c", 0.36, -0.15, 1.05, -0.99, 1.41, -1.77], ["l", 0.15, -0.3], ["l", 0.42, -2.25], ["c", 0.21, -1.26, 0.42, -2.28, 0.39, -2.28], ["l", -0.51, 0.15], ["c", -1.11, 0.39, -1.89, 0.51, -2.7, 0.51], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.15, 0.63, 0.21, 0.81, 0.33, 0.96], ["c", 0.18, 0.18, 0.48, 0.27, 0.72, 0.21], ["c", 0.33, -0.12, 1.14, -1.26, 1.41, -1.95], ["c", 0, -0.09, 0.21, -1.11, 0.45, -2.34], ["c", 0.21, -1.2, 0.39, -2.22, 0.39, -2.28], ["c", 0.03, -0.03, 0, -0.03, -0.45, 0.12], ["c", -0.57, 0.18, -1.2, 0.33, -1.71, 0.42], ["c", -0.3, 0.06, -0.51, 0.06, -0.93, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.18, 0, 0.36, -0.09, 0.57, -0.33], ["c", 0.33, -0.36, 0.78, -1.14, 0.93, -1.56], ["c", 0.03, -0.12, 0.24, -1.2, 0.45, -2.4], ["c", 0.24, -1.2, 0.42, -2.22, 0.42, -2.28], ["c", 0.03, -0.03, 0, -0.03, -0.39, 0.09], ["c", -1.05, 0.36, -1.8, 0.48, -2.58, 0.48], ["c", -0.63, 0, -0.84, -0.03, -1.29, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 12.992, h: 43.883 },
      "accidentals.sharp": { d: [["M", 5.73, -11.19], ["c", 0.21, -0.12, 0.54, -0.03, 0.66, 0.24], ["c", 0.06, 0.12, 0.06, 0.21, 0.06, 2.31], ["c", 0, 1.23, 0, 2.22, 0.03, 2.22], ["c", 0, 0, 0.27, -0.12, 0.6, -0.24], ["c", 0.69, -0.27, 0.78, -0.3, 0.96, -0.15], ["c", 0.21, 0.15, 0.21, 0.18, 0.21, 1.38], ["c", 0, 1.02, 0, 1.11, -0.06, 1.2], ["c", -0.03, 0.06, -0.09, 0.12, -0.12, 0.15], ["c", -0.06, 0.03, -0.42, 0.21, -0.84, 0.36], ["l", -0.75, 0.33], ["l", -0.03, 2.43], ["c", 0, 1.32, 0, 2.43, 0.03, 2.43], ["c", 0, 0, 0.27, -0.12, 0.6, -0.24], ["c", 0.69, -0.27, 0.78, -0.3, 0.96, -0.15], ["c", 0.21, 0.15, 0.21, 0.18, 0.21, 1.38], ["c", 0, 1.02, 0, 1.11, -0.06, 1.2], ["c", -0.03, 0.06, -0.09, 0.12, -0.12, 0.15], ["c", -0.06, 0.03, -0.42, 0.21, -0.84, 0.36], ["l", -0.75, 0.33], ["l", -0.03, 2.52], ["c", 0, 2.28, -0.03, 2.55, -0.06, 2.64], ["c", -0.21, 0.36, -0.72, 0.36, -0.93, 0], ["c", -0.03, -0.09, -0.06, -0.33, -0.06, -2.43], ["l", 0, -2.31], ["l", -1.29, 0.51], ["l", -1.26, 0.51], ["l", 0, 2.43], ["c", 0, 2.58, 0, 2.52, -0.15, 2.67], ["c", -0.06, 0.09, -0.27, 0.18, -0.36, 0.18], ["c", -0.12, 0, -0.33, -0.09, -0.39, -0.18], ["c", -0.15, -0.15, -0.15, -0.09, -0.15, -2.43], ["c", 0, -1.23, 0, -2.22, -0.03, -2.22], ["c", 0, 0, -0.27, 0.12, -0.6, 0.24], ["c", -0.69, 0.27, -0.78, 0.3, -0.96, 0.15], ["c", -0.21, -0.15, -0.21, -0.18, -0.21, -1.38], ["c", 0, -1.02, 0, -1.11, 0.06, -1.2], ["c", 0.03, -0.06, 0.09, -0.12, 0.12, -0.15], ["c", 0.06, -0.03, 0.42, -0.21, 0.84, -0.36], ["l", 0.78, -0.33], ["l", 0, -2.43], ["c", 0, -1.32, 0, -2.43, -0.03, -2.43], ["c", 0, 0, -0.27, 0.12, -0.6, 0.24], ["c", -0.69, 0.27, -0.78, 0.3, -0.96, 0.15], ["c", -0.21, -0.15, -0.21, -0.18, -0.21, -1.38], ["c", 0, -1.02, 0, -1.11, 0.06, -1.2], ["c", 0.03, -0.06, 0.09, -0.12, 0.12, -0.15], ["c", 0.06, -0.03, 0.42, -0.21, 0.84, -0.36], ["l", 0.78, -0.33], ["l", 0, -2.52], ["c", 0, -2.28, 0.03, -2.55, 0.06, -2.64], ["c", 0.21, -0.36, 0.72, -0.36, 0.93, 0], ["c", 0.03, 0.09, 0.06, 0.33, 0.06, 2.43], ["l", 0.03, 2.31], ["l", 1.26, -0.51], ["l", 1.26, -0.51], ["l", 0, -2.43], ["c", 0, -2.28, 0, -2.43, 0.06, -2.55], ["c", 0.06, -0.12, 0.12, -0.18, 0.27, -0.24], ["z"], ["m", -0.33, 10.65], ["l", 0, -2.43], ["l", -1.29, 0.51], ["l", -1.26, 0.51], ["l", 0, 2.46], ["l", 0, 2.43], ["l", 0.09, -0.03], ["c", 0.06, -0.03, 0.63, -0.27, 1.29, -0.51], ["l", 1.17, -0.48], ["l", 0, -2.46], ["z"]], w: 8.25, h: 22.462 },
      "accidentals.halfsharp": { d: [["M", 2.43, -10.05], ["c", 0.21, -0.12, 0.54, -0.03, 0.66, 0.24], ["c", 0.06, 0.12, 0.06, 0.21, 0.06, 2.01], ["c", 0, 1.05, 0, 1.89, 0.03, 1.89], ["l", 0.72, -0.48], ["c", 0.69, -0.48, 0.69, -0.51, 0.87, -0.51], ["c", 0.15, 0, 0.18, 0.03, 0.27, 0.09], ["c", 0.21, 0.15, 0.21, 0.18, 0.21, 1.41], ["c", 0, 1.11, -0.03, 1.14, -0.09, 1.23], ["c", -0.03, 0.03, -0.48, 0.39, -1.02, 0.75], ["l", -0.99, 0.66], ["l", 0, 2.37], ["c", 0, 1.32, 0, 2.37, 0.03, 2.37], ["l", 0.72, -0.48], ["c", 0.69, -0.48, 0.69, -0.51, 0.87, -0.51], ["c", 0.15, 0, 0.18, 0.03, 0.27, 0.09], ["c", 0.21, 0.15, 0.21, 0.18, 0.21, 1.41], ["c", 0, 1.11, -0.03, 1.14, -0.09, 1.23], ["c", -0.03, 0.03, -0.48, 0.39, -1.02, 0.75], ["l", -0.99, 0.66], ["l", 0, 2.25], ["c", 0, 1.95, 0, 2.28, -0.06, 2.37], ["c", -0.06, 0.12, -0.12, 0.21, -0.24, 0.27], ["c", -0.27, 0.12, -0.54, 0.03, -0.69, -0.24], ["c", -0.06, -0.12, -0.06, -0.21, -0.06, -2.01], ["c", 0, -1.05, 0, -1.89, -0.03, -1.89], ["l", -0.72, 0.48], ["c", -0.69, 0.48, -0.69, 0.48, -0.87, 0.48], ["c", -0.15, 0, -0.18, 0, -0.27, -0.06], ["c", -0.21, -0.15, -0.21, -0.18, -0.21, -1.41], ["c", 0, -1.11, 0.03, -1.14, 0.09, -1.23], ["c", 0.03, -0.03, 0.48, -0.39, 1.02, -0.75], ["l", 0.99, -0.66], ["l", 0, -2.37], ["c", 0, -1.32, 0, -2.37, -0.03, -2.37], ["l", -0.72, 0.48], ["c", -0.69, 0.48, -0.69, 0.48, -0.87, 0.48], ["c", -0.15, 0, -0.18, 0, -0.27, -0.06], ["c", -0.21, -0.15, -0.21, -0.18, -0.21, -1.41], ["c", 0, -1.11, 0.03, -1.14, 0.09, -1.23], ["c", 0.03, -0.03, 0.48, -0.39, 1.02, -0.75], ["l", 0.99, -0.66], ["l", 0, -2.25], ["c", 0, -2.13, 0, -2.28, 0.06, -2.4], ["c", 0.06, -0.12, 0.12, -0.18, 0.27, -0.24], ["z"]], w: 5.25, h: 20.174 },
      "accidentals.nat": { d: [["M", 0.21, -11.4], ["c", 0.24, -0.06, 0.78, 0, 0.99, 0.15], ["c", 0.03, 0.03, 0.03, 0.48, 0, 2.61], ["c", -0.03, 1.44, -0.03, 2.61, -0.03, 2.61], ["c", 0, 0.03, 0.75, -0.09, 1.68, -0.24], ["c", 0.96, -0.18, 1.71, -0.27, 1.74, -0.27], ["c", 0.15, 0.03, 0.27, 0.15, 0.36, 0.3], ["l", 0.06, 0.12], ["l", 0.09, 8.67], ["c", 0.09, 6.96, 0.12, 8.67, 0.09, 8.67], ["c", -0.03, 0.03, -0.12, 0.06, -0.21, 0.09], ["c", -0.24, 0.09, -0.72, 0.09, -0.96, 0], ["c", -0.09, -0.03, -0.18, -0.06, -0.21, -0.09], ["c", -0.03, -0.03, -0.03, -0.48, 0, -2.61], ["c", 0.03, -1.44, 0.03, -2.61, 0.03, -2.61], ["c", 0, -0.03, -0.75, 0.09, -1.68, 0.24], ["c", -0.96, 0.18, -1.71, 0.27, -1.74, 0.27], ["c", -0.15, -0.03, -0.27, -0.15, -0.36, -0.3], ["l", -0.06, -0.15], ["l", -0.09, -7.53], ["c", -0.06, -4.14, -0.09, -8.04, -0.12, -8.67], ["l", 0, -1.11], ["l", 0.15, -0.06], ["c", 0.09, -0.03, 0.21, -0.06, 0.27, -0.09], ["z"], ["m", 3.75, 8.4], ["c", 0, -0.33, 0, -0.42, -0.03, -0.42], ["c", -0.12, 0, -2.79, 0.45, -2.79, 0.48], ["c", -0.03, 0, -0.09, 6.3, -0.09, 6.33], ["c", 0.03, 0, 2.79, -0.45, 2.82, -0.48], ["c", 0, 0, 0.09, -4.53, 0.09, -5.91], ["z"]], w: 5.4, h: 22.8 },
      "accidentals.flat": { d: [["M", -0.36, -14.07], ["c", 0.33, -0.06, 0.87, 0, 1.08, 0.15], ["c", 0.06, 0.03, 0.06, 0.36, -0.03, 5.25], ["c", -0.06, 2.85, -0.09, 5.19, -0.09, 5.19], ["c", 0, 0.03, 0.12, -0.03, 0.24, -0.12], ["c", 0.63, -0.42, 1.41, -0.66, 2.19, -0.72], ["c", 0.81, -0.03, 1.47, 0.21, 2.04, 0.78], ["c", 0.57, 0.54, 0.87, 1.26, 0.93, 2.04], ["c", 0.03, 0.57, -0.09, 1.08, -0.36, 1.62], ["c", -0.42, 0.81, -1.02, 1.38, -2.82, 2.61], ["c", -1.14, 0.78, -1.44, 1.02, -1.8, 1.44], ["c", -0.18, 0.18, -0.39, 0.39, -0.45, 0.42], ["c", -0.27, 0.18, -0.57, 0.15, -0.81, -0.06], ["c", -0.06, -0.09, -0.12, -0.18, -0.15, -0.27], ["c", -0.03, -0.06, -0.09, -3.27, -0.18, -8.34], ["c", -0.09, -4.53, -0.15, -8.58, -0.18, -9.03], ["l", 0, -0.78], ["l", 0.12, -0.06], ["c", 0.06, -0.03, 0.18, -0.09, 0.27, -0.12], ["z"], ["m", 3.18, 11.01], ["c", -0.21, -0.12, -0.54, -0.15, -0.81, -0.06], ["c", -0.54, 0.15, -0.99, 0.63, -1.17, 1.26], ["c", -0.06, 0.3, -0.12, 2.88, -0.06, 3.87], ["c", 0.03, 0.42, 0.03, 0.81, 0.06, 0.9], ["l", 0.03, 0.12], ["l", 0.45, -0.39], ["c", 0.63, -0.54, 1.26, -1.17, 1.56, -1.59], ["c", 0.3, -0.42, 0.6, -0.99, 0.72, -1.41], ["c", 0.18, -0.69, 0.09, -1.47, -0.18, -2.07], ["c", -0.15, -0.3, -0.33, -0.51, -0.6, -0.63], ["z"]], w: 6.75, h: 18.801 },
      "accidentals.halfflat": { d: [["M", 4.83, -14.07], ["c", 0.33, -0.06, 0.87, 0, 1.08, 0.15], ["c", 0.06, 0.03, 0.06, 0.6, -0.12, 9.06], ["c", -0.09, 5.55, -0.15, 9.06, -0.18, 9.12], ["c", -0.03, 0.09, -0.09, 0.18, -0.15, 0.27], ["c", -0.24, 0.21, -0.54, 0.24, -0.81, 0.06], ["c", -0.06, -0.03, -0.27, -0.24, -0.45, -0.42], ["c", -0.36, -0.42, -0.66, -0.66, -1.8, -1.44], ["c", -1.23, -0.84, -1.83, -1.32, -2.25, -1.77], ["c", -0.66, -0.78, -0.96, -1.56, -0.93, -2.46], ["c", 0.09, -1.41, 1.11, -2.58, 2.4, -2.79], ["c", 0.3, -0.06, 0.84, -0.03, 1.23, 0.06], ["c", 0.54, 0.12, 1.08, 0.33, 1.53, 0.63], ["c", 0.12, 0.09, 0.24, 0.15, 0.24, 0.12], ["c", 0, 0, -0.12, -8.37, -0.18, -9.75], ["l", 0, -0.66], ["l", 0.12, -0.06], ["c", 0.06, -0.03, 0.18, -0.09, 0.27, -0.12], ["z"], ["m", -1.65, 10.95], ["c", -0.6, -0.18, -1.08, 0.09, -1.38, 0.69], ["c", -0.27, 0.6, -0.36, 1.38, -0.18, 2.07], ["c", 0.12, 0.42, 0.42, 0.99, 0.72, 1.41], ["c", 0.3, 0.42, 0.93, 1.05, 1.56, 1.59], ["l", 0.48, 0.39], ["l", 0, -0.12], ["c", 0.03, -0.09, 0.03, -0.48, 0.06, -0.9], ["c", 0.03, -0.57, 0.03, -1.08, 0, -2.22], ["c", -0.03, -1.62, -0.03, -1.62, -0.24, -2.07], ["c", -0.21, -0.42, -0.6, -0.75, -1.02, -0.84], ["z"]], w: 6.728, h: 18.801 },
      "accidentals.dblflat": { d: [["M", -0.36, -14.07], ["c", 0.33, -0.06, 0.87, 0, 1.08, 0.15], ["c", 0.06, 0.03, 0.06, 0.36, -0.03, 5.25], ["c", -0.06, 2.85, -0.09, 5.19, -0.09, 5.19], ["c", 0, 0.03, 0.12, -0.03, 0.24, -0.12], ["c", 0.63, -0.42, 1.41, -0.66, 2.19, -0.72], ["c", 0.81, -0.03, 1.47, 0.21, 2.04, 0.78], ["c", 0.57, 0.54, 0.87, 1.26, 0.93, 2.04], ["c", 0.03, 0.57, -0.09, 1.08, -0.36, 1.62], ["c", -0.42, 0.81, -1.02, 1.38, -2.82, 2.61], ["c", -1.14, 0.78, -1.44, 1.02, -1.8, 1.44], ["c", -0.18, 0.18, -0.39, 0.39, -0.45, 0.42], ["c", -0.27, 0.18, -0.57, 0.15, -0.81, -0.06], ["c", -0.06, -0.09, -0.12, -0.18, -0.15, -0.27], ["c", -0.03, -0.06, -0.09, -3.27, -0.18, -8.34], ["c", -0.09, -4.53, -0.15, -8.58, -0.18, -9.03], ["l", 0, -0.78], ["l", 0.12, -0.06], ["c", 0.06, -0.03, 0.18, -0.09, 0.27, -0.12], ["z"], ["m", 3.18, 11.01], ["c", -0.21, -0.12, -0.54, -0.15, -0.81, -0.06], ["c", -0.54, 0.15, -0.99, 0.63, -1.17, 1.26], ["c", -0.06, 0.3, -0.12, 2.88, -0.06, 3.87], ["c", 0.03, 0.42, 0.03, 0.81, 0.06, 0.9], ["l", 0.03, 0.12], ["l", 0.45, -0.39], ["c", 0.63, -0.54, 1.26, -1.17, 1.56, -1.59], ["c", 0.3, -0.42, 0.6, -0.99, 0.72, -1.41], ["c", 0.18, -0.69, 0.09, -1.47, -0.18, -2.07], ["c", -0.15, -0.3, -0.33, -0.51, -0.6, -0.63], ["z"], ["m", 3, -11], ["c", 0.33, -0.06, 0.87, 0, 1.08, 0.15], ["c", 0.06, 0.03, 0.06, 0.36, -0.03, 5.25], ["c", -0.06, 2.85, -0.09, 5.19, -0.09, 5.19], ["c", 0, 0.03, 0.12, -0.03, 0.24, -0.12], ["c", 0.63, -0.42, 1.41, -0.66, 2.19, -0.72], ["c", 0.81, -0.03, 1.47, 0.21, 2.04, 0.78], ["c", 0.57, 0.54, 0.87, 1.26, 0.93, 2.04], ["c", 0.03, 0.57, -0.09, 1.08, -0.36, 1.62], ["c", -0.42, 0.81, -1.02, 1.38, -2.82, 2.61], ["c", -1.14, 0.78, -1.44, 1.02, -1.8, 1.44], ["c", -0.18, 0.18, -0.39, 0.39, -0.45, 0.42], ["c", -0.27, 0.18, -0.57, 0.15, -0.81, -0.06], ["c", -0.06, -0.09, -0.12, -0.18, -0.15, -0.27], ["c", -0.03, -0.06, -0.09, -3.27, -0.18, -8.34], ["c", -0.09, -4.53, -0.15, -8.58, -0.18, -9.03], ["l", 0, -0.78], ["l", 0.12, -0.06], ["c", 0.06, -0.03, 0.18, -0.09, 0.27, -0.12], ["z"], ["m", 3.18, 11.01], ["c", -0.21, -0.12, -0.54, -0.15, -0.81, -0.06], ["c", -0.54, 0.15, -0.99, 0.63, -1.17, 1.26], ["c", -0.06, 0.3, -0.12, 2.88, -0.06, 3.87], ["c", 0.03, 0.42, 0.03, 0.81, 0.06, 0.9], ["l", 0.03, 0.12], ["l", 0.45, -0.39], ["c", 0.63, -0.54, 1.26, -1.17, 1.56, -1.59], ["c", 0.3, -0.42, 0.6, -0.99, 0.72, -1.41], ["c", 0.18, -0.69, 0.09, -1.47, -0.18, -2.07], ["c", -0.15, -0.3, -0.33, -0.51, -0.6, -0.63], ["z"]], w: 12.1, h: 18.804 },
      "accidentals.dblsharp": { d: [["M", -0.18, -3.96], ["c", 0.06, -0.03, 0.12, -0.06, 0.15, -0.06], ["c", 0.09, 0, 2.76, 0.27, 2.79, 0.3], ["c", 0.12, 0.03, 0.15, 0.12, 0.15, 0.51], ["c", 0.06, 0.96, 0.24, 1.59, 0.57, 2.1], ["c", 0.06, 0.09, 0.15, 0.21, 0.18, 0.24], ["l", 0.09, 0.06], ["l", 0.09, -0.06], ["c", 0.03, -0.03, 0.12, -0.15, 0.18, -0.24], ["c", 0.33, -0.51, 0.51, -1.14, 0.57, -2.1], ["c", 0, -0.39, 0.03, -0.45, 0.12, -0.51], ["c", 0.03, 0, 0.66, -0.09, 1.44, -0.15], ["c", 1.47, -0.15, 1.5, -0.15, 1.56, -0.03], ["c", 0.03, 0.06, 0, 0.42, -0.09, 1.44], ["c", -0.09, 0.72, -0.15, 1.35, -0.15, 1.38], ["c", 0, 0.03, -0.03, 0.09, -0.06, 0.12], ["c", -0.06, 0.06, -0.12, 0.09, -0.51, 0.09], ["c", -1.08, 0.06, -1.8, 0.3, -2.28, 0.75], ["l", -0.12, 0.09], ["l", 0.09, 0.09], ["c", 0.12, 0.15, 0.39, 0.33, 0.63, 0.45], ["c", 0.42, 0.18, 0.96, 0.27, 1.68, 0.33], ["c", 0.39, 0, 0.45, 0.03, 0.51, 0.09], ["c", 0.03, 0.03, 0.06, 0.09, 0.06, 0.12], ["c", 0, 0.03, 0.06, 0.66, 0.15, 1.38], ["c", 0.09, 1.02, 0.12, 1.38, 0.09, 1.44], ["c", -0.06, 0.12, -0.09, 0.12, -1.56, -0.03], ["c", -0.78, -0.06, -1.41, -0.15, -1.44, -0.15], ["c", -0.09, -0.06, -0.12, -0.12, -0.12, -0.54], ["c", -0.06, -0.93, -0.24, -1.56, -0.57, -2.07], ["c", -0.06, -0.09, -0.15, -0.21, -0.18, -0.24], ["l", -0.09, -0.06], ["l", -0.09, 0.06], ["c", -0.03, 0.03, -0.12, 0.15, -0.18, 0.24], ["c", -0.33, 0.51, -0.51, 1.14, -0.57, 2.07], ["c", 0, 0.42, -0.03, 0.48, -0.12, 0.54], ["c", -0.03, 0, -0.66, 0.09, -1.44, 0.15], ["c", -1.47, 0.15, -1.5, 0.15, -1.56, 0.03], ["c", -0.03, -0.06, 0, -0.42, 0.09, -1.44], ["c", 0.09, -0.72, 0.15, -1.35, 0.15, -1.38], ["c", 0, -0.03, 0.03, -0.09, 0.06, -0.12], ["c", 0.06, -0.06, 0.12, -0.09, 0.51, -0.09], ["c", 0.72, -0.06, 1.26, -0.15, 1.68, -0.33], ["c", 0.24, -0.12, 0.51, -0.3, 0.63, -0.45], ["l", 0.09, -0.09], ["l", -0.12, -0.09], ["c", -0.48, -0.45, -1.2, -0.69, -2.28, -0.75], ["c", -0.39, 0, -0.45, -0.03, -0.51, -0.09], ["c", -0.03, -0.03, -0.06, -0.09, -0.06, -0.12], ["c", 0, -0.03, -0.06, -0.63, -0.12, -1.38], ["c", -0.09, -0.72, -0.15, -1.35, -0.15, -1.38], ["z"]], w: 7.95, h: 7.977 },
      "dots.dot": { d: [["M", 1.32, -1.68], ["c", 0.09, -0.03, 0.27, -0.06, 0.39, -0.06], ["c", 0.96, 0, 1.74, 0.78, 1.74, 1.71], ["c", 0, 0.96, -0.78, 1.74, -1.71, 1.74], ["c", -0.96, 0, -1.74, -0.78, -1.74, -1.71], ["c", 0, -0.78, 0.54, -1.5, 1.32, -1.68], ["z"]], w: 3.45, h: 3.45 },
      "noteheads.dbl": { d: [["M", -0.69, -4.02], ["c", 0.18, -0.09, 0.36, -0.09, 0.54, 0], ["c", 0.18, 0.09, 0.24, 0.15, 0.33, 0.3], ["c", 0.06, 0.15, 0.06, 0.18, 0.06, 1.41], ["l", 0, 1.23], ["l", 0.12, -0.18], ["c", 0.72, -1.26, 2.64, -2.31, 4.86, -2.64], ["c", 0.81, -0.15, 1.11, -0.15, 2.13, -0.15], ["c", 0.99, 0, 1.29, 0, 2.1, 0.15], ["c", 0.75, 0.12, 1.38, 0.27, 2.04, 0.54], ["c", 1.35, 0.51, 2.34, 1.26, 2.82, 2.1], ["l", 0.12, 0.18], ["l", 0, -1.23], ["c", 0, -1.2, 0, -1.26, 0.06, -1.38], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["c", 0.18, -0.09, 0.36, -0.09, 0.54, 0], ["c", 0.18, 0.09, 0.24, 0.15, 0.33, 0.3], ["l", 0.06, 0.15], ["l", 0, 3.54], ["l", 0, 3.54], ["l", -0.06, 0.15], ["c", -0.09, 0.18, -0.15, 0.24, -0.33, 0.33], ["c", -0.18, 0.09, -0.36, 0.09, -0.54, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.06, -0.12, -0.06, -0.18, -0.06, -1.38], ["l", 0, -1.23], ["l", -0.12, 0.18], ["c", -0.48, 0.84, -1.47, 1.59, -2.82, 2.1], ["c", -0.84, 0.33, -1.71, 0.54, -2.85, 0.66], ["c", -0.45, 0.06, -2.16, 0.06, -2.61, 0], ["c", -1.14, -0.12, -2.01, -0.33, -2.85, -0.66], ["c", -1.35, -0.51, -2.34, -1.26, -2.82, -2.1], ["l", -0.12, -0.18], ["l", 0, 1.23], ["c", 0, 1.23, 0, 1.26, -0.06, 1.38], ["c", -0.09, 0.18, -0.15, 0.24, -0.33, 0.33], ["c", -0.18, 0.09, -0.36, 0.09, -0.54, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["l", -0.06, -0.15], ["l", 0, -3.54], ["c", 0, -3.48, 0, -3.54, 0.06, -3.66], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["z"], ["m", 7.71, 0.63], ["c", -0.36, -0.06, -0.9, -0.06, -1.14, 0], ["c", -0.3, 0.03, -0.66, 0.24, -0.87, 0.42], ["c", -0.6, 0.54, -0.9, 1.62, -0.75, 2.82], ["c", 0.12, 0.93, 0.51, 1.68, 1.11, 2.31], ["c", 0.75, 0.72, 1.83, 1.2, 2.85, 1.26], ["c", 1.05, 0.06, 1.83, -0.54, 2.1, -1.65], ["c", 0.21, -0.9, 0.12, -1.95, -0.24, -2.82], ["c", -0.36, -0.81, -1.08, -1.53, -1.95, -1.95], ["c", -0.3, -0.15, -0.78, -0.3, -1.11, -0.39], ["z"]], w: 16.83, h: 8.145 },
      "noteheads.whole": { d: [["M", 6.51, -4.05], ["c", 0.51, -0.03, 2.01, 0, 2.52, 0.03], ["c", 1.41, 0.18, 2.64, 0.51, 3.72, 1.08], ["c", 1.2, 0.63, 1.95, 1.41, 2.19, 2.31], ["c", 0.09, 0.33, 0.09, 0.9, 0, 1.23], ["c", -0.24, 0.9, -0.99, 1.68, -2.19, 2.31], ["c", -1.08, 0.57, -2.28, 0.9, -3.75, 1.08], ["c", -0.66, 0.06, -2.31, 0.06, -2.97, 0], ["c", -1.47, -0.18, -2.67, -0.51, -3.75, -1.08], ["c", -1.2, -0.63, -1.95, -1.41, -2.19, -2.31], ["c", -0.09, -0.33, -0.09, -0.9, 0, -1.23], ["c", 0.24, -0.9, 0.99, -1.68, 2.19, -2.31], ["c", 1.2, -0.63, 2.61, -0.99, 4.23, -1.11], ["z"], ["m", 0.57, 0.66], ["c", -0.87, -0.15, -1.53, 0, -2.04, 0.51], ["c", -0.15, 0.15, -0.24, 0.27, -0.33, 0.48], ["c", -0.24, 0.51, -0.36, 1.08, -0.33, 1.77], ["c", 0.03, 0.69, 0.18, 1.26, 0.42, 1.77], ["c", 0.6, 1.17, 1.74, 1.98, 3.18, 2.22], ["c", 1.11, 0.21, 1.95, -0.15, 2.34, -0.99], ["c", 0.24, -0.51, 0.36, -1.08, 0.33, -1.8], ["c", -0.06, -1.11, -0.45, -2.04, -1.17, -2.76], ["c", -0.63, -0.63, -1.47, -1.05, -2.4, -1.2], ["z"]], w: 14.985, h: 8.097 },
      "noteheads.half": { d: [["M", 7.44, -4.05], ["c", 0.06, -0.03, 0.27, -0.03, 0.48, -0.03], ["c", 1.05, 0, 1.71, 0.24, 2.1, 0.81], ["c", 0.42, 0.6, 0.45, 1.35, 0.18, 2.4], ["c", -0.42, 1.59, -1.14, 2.73, -2.16, 3.39], ["c", -1.41, 0.93, -3.18, 1.44, -5.4, 1.53], ["c", -1.17, 0.03, -1.89, -0.21, -2.28, -0.81], ["c", -0.42, -0.6, -0.45, -1.35, -0.18, -2.4], ["c", 0.42, -1.59, 1.14, -2.73, 2.16, -3.39], ["c", 0.63, -0.42, 1.23, -0.72, 1.98, -0.96], ["c", 0.9, -0.3, 1.65, -0.42, 3.12, -0.54], ["z"], ["m", 1.29, 0.87], ["c", -0.27, -0.09, -0.63, -0.12, -0.9, -0.03], ["c", -0.72, 0.24, -1.53, 0.69, -3.27, 1.8], ["c", -2.34, 1.5, -3.3, 2.25, -3.57, 2.79], ["c", -0.36, 0.72, -0.06, 1.5, 0.66, 1.77], ["c", 0.24, 0.12, 0.69, 0.09, 0.99, 0], ["c", 0.84, -0.3, 1.92, -0.93, 4.14, -2.37], ["c", 1.62, -1.08, 2.37, -1.71, 2.61, -2.19], ["c", 0.36, -0.72, 0.06, -1.5, -0.66, -1.77], ["z"]], w: 10.37, h: 8.132 },
      "noteheads.quarter": { d: [["M", 6.09, -4.05], ["c", 0.36, -0.03, 1.2, 0, 1.53, 0.06], ["c", 1.17, 0.24, 1.89, 0.84, 2.16, 1.83], ["c", 0.06, 0.18, 0.06, 0.3, 0.06, 0.66], ["c", 0, 0.45, 0, 0.63, -0.15, 1.08], ["c", -0.66, 2.04, -3.06, 3.93, -5.52, 4.38], ["c", -0.54, 0.09, -1.44, 0.09, -1.83, 0.03], ["c", -1.23, -0.27, -1.98, -0.87, -2.25, -1.86], ["c", -0.06, -0.18, -0.06, -0.3, -0.06, -0.66], ["c", 0, -0.45, 0, -0.63, 0.15, -1.08], ["c", 0.24, -0.78, 0.75, -1.53, 1.44, -2.22], ["c", 1.2, -1.2, 2.85, -2.01, 4.47, -2.22], ["z"]], w: 9.81, h: 8.094 },
      "noteheads.slash.nostem": { d: [["M", 9.3, -7.77], ["c", 0.06, -0.06, 0.18, -0.06, 1.71, -0.06], ["l", 1.65, 0], ["l", 0.09, 0.09], ["c", 0.06, 0.06, 0.06, 0.09, 0.06, 0.15], ["c", -0.03, 0.12, -9.21, 15.24, -9.3, 15.33], ["c", -0.06, 0.06, -0.18, 0.06, -1.71, 0.06], ["l", -1.65, 0], ["l", -0.09, -0.09], ["c", -0.06, -0.06, -0.06, -0.09, -0.06, -0.15], ["c", 0.03, -0.12, 9.21, -15.24, 9.3, -15.33], ["z"]], w: 12.81, h: 15.63 },
      "noteheads.indeterminate": { d: [["M", 0.78, -4.05], ["c", 0.12, -0.03, 0.24, -0.03, 0.36, 0.03], ["c", 0.03, 0.03, 0.93, 0.72, 1.95, 1.56], ["l", 1.86, 1.5], ["l", 1.86, -1.5], ["c", 1.02, -0.84, 1.92, -1.53, 1.95, -1.56], ["c", 0.21, -0.12, 0.33, -0.09, 0.75, 0.24], ["c", 0.3, 0.27, 0.36, 0.36, 0.36, 0.54], ["c", 0, 0.03, -0.03, 0.12, -0.06, 0.18], ["c", -0.03, 0.06, -0.9, 0.75, -1.89, 1.56], ["l", -1.8, 1.47], ["c", 0, 0.03, 0.81, 0.69, 1.8, 1.5], ["c", 0.99, 0.81, 1.86, 1.5, 1.89, 1.56], ["c", 0.03, 0.06, 0.06, 0.15, 0.06, 0.18], ["c", 0, 0.18, -0.06, 0.27, -0.36, 0.54], ["c", -0.42, 0.33, -0.54, 0.36, -0.75, 0.24], ["c", -0.03, -0.03, -0.93, -0.72, -1.95, -1.56], ["l", -1.86, -1.5], ["l", -1.86, 1.5], ["c", -1.02, 0.84, -1.92, 1.53, -1.95, 1.56], ["c", -0.21, 0.12, -0.33, 0.09, -0.75, -0.24], ["c", -0.3, -0.27, -0.36, -0.36, -0.36, -0.54], ["c", 0, -0.03, 0.03, -0.12, 0.06, -0.18], ["c", 0.03, -0.06, 0.9, -0.75, 1.89, -1.56], ["l", 1.8, -1.47], ["c", 0, -0.03, -0.81, -0.69, -1.8, -1.5], ["c", -0.99, -0.81, -1.86, -1.5, -1.89, -1.56], ["c", -0.06, -0.12, -0.09, -0.21, -0.03, -0.36], ["c", 0.03, -0.09, 0.57, -0.57, 0.72, -0.63], ["z"]], w: 9.843, h: 8.139 },
      "scripts.ufermata": { d: [["M", -0.75, -10.77], ["c", 0.12, 0, 0.45, -0.03, 0.69, -0.03], ["c", 2.91, -0.03, 5.55, 1.53, 7.41, 4.35], ["c", 1.17, 1.71, 1.95, 3.72, 2.43, 6.03], ["c", 0.12, 0.51, 0.12, 0.57, 0.03, 0.69], ["c", -0.12, 0.21, -0.48, 0.27, -0.69, 0.12], ["c", -0.12, -0.09, -0.18, -0.24, -0.27, -0.69], ["c", -0.78, -3.63, -3.42, -6.54, -6.78, -7.38], ["c", -0.78, -0.21, -1.2, -0.24, -2.07, -0.24], ["c", -0.63, 0, -0.84, 0, -1.2, 0.06], ["c", -1.83, 0.27, -3.42, 1.08, -4.8, 2.37], ["c", -1.41, 1.35, -2.4, 3.21, -2.85, 5.19], ["c", -0.09, 0.45, -0.15, 0.6, -0.27, 0.69], ["c", -0.21, 0.15, -0.57, 0.09, -0.69, -0.12], ["c", -0.09, -0.12, -0.09, -0.18, 0.03, -0.69], ["c", 0.33, -1.62, 0.78, -3, 1.47, -4.38], ["c", 1.77, -3.54, 4.44, -5.67, 7.56, -5.97], ["z"], ["m", 0.33, 7.47], ["c", 1.38, -0.3, 2.58, 0.9, 2.31, 2.25], ["c", -0.15, 0.72, -0.78, 1.35, -1.47, 1.5], ["c", -1.38, 0.27, -2.58, -0.93, -2.31, -2.31], ["c", 0.15, -0.69, 0.78, -1.29, 1.47, -1.44], ["z"]], w: 19.748, h: 11.289 },
      "scripts.dfermata": { d: [["M", -9.63, -0.42], ["c", 0.15, -0.09, 0.36, -0.06, 0.51, 0.03], ["c", 0.12, 0.09, 0.18, 0.24, 0.27, 0.66], ["c", 0.78, 3.66, 3.42, 6.57, 6.78, 7.41], ["c", 0.78, 0.21, 1.2, 0.24, 2.07, 0.24], ["c", 0.63, 0, 0.84, 0, 1.2, -0.06], ["c", 1.83, -0.27, 3.42, -1.08, 4.8, -2.37], ["c", 1.41, -1.35, 2.4, -3.21, 2.85, -5.22], ["c", 0.09, -0.42, 0.15, -0.57, 0.27, -0.66], ["c", 0.21, -0.15, 0.57, -0.09, 0.69, 0.12], ["c", 0.09, 0.12, 0.09, 0.18, -0.03, 0.69], ["c", -0.33, 1.62, -0.78, 3, -1.47, 4.38], ["c", -1.92, 3.84, -4.89, 6, -8.31, 6], ["c", -3.42, 0, -6.39, -2.16, -8.31, -6], ["c", -0.48, -0.96, -0.84, -1.92, -1.14, -2.97], ["c", -0.18, -0.69, -0.42, -1.74, -0.42, -1.92], ["c", 0, -0.12, 0.09, -0.27, 0.24, -0.33], ["z"], ["m", 9.21, 0], ["c", 1.2, -0.27, 2.34, 0.63, 2.34, 1.86], ["c", 0, 0.9, -0.66, 1.68, -1.5, 1.89], ["c", -1.38, 0.27, -2.58, -0.93, -2.31, -2.31], ["c", 0.15, -0.69, 0.78, -1.29, 1.47, -1.44], ["z"]], w: 19.744, h: 11.274 },
      "scripts.sforzato": { d: [["M", -6.45, -3.69], ["c", 0.06, -0.03, 0.15, -0.06, 0.18, -0.06], ["c", 0.06, 0, 2.85, 0.72, 6.24, 1.59], ["l", 6.33, 1.65], ["c", 0.33, 0.06, 0.45, 0.21, 0.45, 0.51], ["c", 0, 0.3, -0.12, 0.45, -0.45, 0.51], ["l", -6.33, 1.65], ["c", -3.39, 0.87, -6.18, 1.59, -6.21, 1.59], ["c", -0.21, 0, -0.48, -0.24, -0.51, -0.45], ["c", 0, -0.15, 0.06, -0.36, 0.18, -0.45], ["c", 0.09, -0.06, 0.87, -0.27, 3.84, -1.05], ["c", 2.04, -0.54, 3.84, -0.99, 4.02, -1.02], ["c", 0.15, -0.06, 1.14, -0.24, 2.22, -0.42], ["c", 1.05, -0.18, 1.92, -0.36, 1.92, -0.36], ["c", 0, 0, -0.87, -0.18, -1.92, -0.36], ["c", -1.08, -0.18, -2.07, -0.36, -2.22, -0.42], ["c", -0.18, -0.03, -1.98, -0.48, -4.02, -1.02], ["c", -2.97, -0.78, -3.75, -0.99, -3.84, -1.05], ["c", -0.12, -0.09, -0.18, -0.3, -0.18, -0.45], ["c", 0.03, -0.15, 0.15, -0.3, 0.3, -0.39], ["z"]], w: 13.5, h: 7.5 },
      "scripts.staccato": { d: [["M", -0.36, -1.47], ["c", 0.93, -0.21, 1.86, 0.51, 1.86, 1.47], ["c", 0, 0.93, -0.87, 1.65, -1.8, 1.47], ["c", -0.54, -0.12, -1.02, -0.57, -1.14, -1.08], ["c", -0.21, -0.81, 0.27, -1.65, 1.08, -1.86], ["z"]], w: 2.989, h: 3.004 },
      "scripts.tenuto": { d: [["M", -4.2, -0.48], ["l", 0.12, -0.06], ["l", 4.08, 0], ["l", 4.08, 0], ["l", 0.12, 0.06], ["c", 0.39, 0.21, 0.39, 0.75, 0, 0.96], ["l", -0.12, 0.06], ["l", -4.08, 0], ["l", -4.08, 0], ["l", -0.12, -0.06], ["c", -0.39, -0.21, -0.39, -0.75, 0, -0.96], ["z"]], w: 8.985, h: 1.08 },
      "scripts.umarcato": { d: [["M", -0.15, -8.19], ["c", 0.15, -0.12, 0.36, -0.03, 0.45, 0.15], ["c", 0.21, 0.42, 3.45, 7.65, 3.45, 7.71], ["c", 0, 0.12, -0.12, 0.27, -0.21, 0.3], ["c", -0.03, 0.03, -0.51, 0.03, -1.14, 0.03], ["c", -1.05, 0, -1.08, 0, -1.17, -0.06], ["c", -0.09, -0.06, -0.24, -0.36, -1.17, -2.4], ["c", -0.57, -1.29, -1.05, -2.34, -1.08, -2.34], ["c", 0, -0.03, -0.51, 1.02, -1.08, 2.34], ["c", -0.93, 2.07, -1.08, 2.34, -1.14, 2.4], ["c", -0.06, 0.03, -0.15, 0.06, -0.18, 0.06], ["c", -0.15, 0, -0.33, -0.18, -0.33, -0.33], ["c", 0, -0.06, 3.24, -7.32, 3.45, -7.71], ["c", 0.03, -0.06, 0.09, -0.15, 0.15, -0.15], ["z"]], w: 7.5, h: 8.245 },
      "scripts.dmarcato": { d: [["M", -3.57, 0.03], ["c", 0.03, 0, 0.57, -0.03, 1.17, -0.03], ["c", 1.05, 0, 1.08, 0, 1.17, 0.06], ["c", 0.09, 0.06, 0.24, 0.36, 1.17, 2.4], ["c", 0.57, 1.29, 1.05, 2.34, 1.08, 2.34], ["c", 0, 0.03, 0.51, -1.02, 1.08, -2.34], ["c", 0.93, -2.07, 1.08, -2.34, 1.14, -2.4], ["c", 0.06, -0.03, 0.15, -0.06, 0.18, -0.06], ["c", 0.15, 0, 0.33, 0.18, 0.33, 0.33], ["c", 0, 0.09, -3.45, 7.74, -3.54, 7.83], ["c", -0.12, 0.12, -0.3, 0.12, -0.42, 0], ["c", -0.09, -0.09, -3.54, -7.74, -3.54, -7.83], ["c", 0, -0.09, 0.12, -0.27, 0.18, -0.3], ["z"]], w: 7.5, h: 8.25 },
      "scripts.stopped": { d: [["M", -0.27, -4.08], ["c", 0.18, -0.09, 0.36, -0.09, 0.54, 0], ["c", 0.18, 0.09, 0.24, 0.15, 0.33, 0.3], ["l", 0.06, 0.15], ["l", 0, 1.5], ["l", 0, 1.47], ["l", 1.47, 0], ["l", 1.5, 0], ["l", 0.15, 0.06], ["c", 0.15, 0.09, 0.21, 0.15, 0.3, 0.33], ["c", 0.09, 0.18, 0.09, 0.36, 0, 0.54], ["c", -0.09, 0.18, -0.15, 0.24, -0.33, 0.33], ["c", -0.12, 0.06, -0.18, 0.06, -1.62, 0.06], ["l", -1.47, 0], ["l", 0, 1.47], ["l", 0, 1.47], ["l", -0.06, 0.15], ["c", -0.09, 0.18, -0.15, 0.24, -0.33, 0.33], ["c", -0.18, 0.09, -0.36, 0.09, -0.54, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["l", -0.06, -0.15], ["l", 0, -1.47], ["l", 0, -1.47], ["l", -1.47, 0], ["c", -1.44, 0, -1.5, 0, -1.62, -0.06], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.09, -0.18, -0.09, -0.36, 0, -0.54], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["l", 0.15, -0.06], ["l", 1.47, 0], ["l", 1.47, 0], ["l", 0, -1.47], ["c", 0, -1.44, 0, -1.5, 0.06, -1.62], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["z"]], w: 8.295, h: 8.295 },
      "scripts.upbow": { d: [["M", -4.65, -15.54], ["c", 0.12, -0.09, 0.36, -0.06, 0.48, 0.03], ["c", 0.03, 0.03, 0.09, 0.09, 0.12, 0.15], ["c", 0.03, 0.06, 0.66, 2.13, 1.41, 4.62], ["c", 1.35, 4.41, 1.38, 4.56, 2.01, 6.96], ["l", 0.63, 2.46], ["l", 0.63, -2.46], ["c", 0.63, -2.4, 0.66, -2.55, 2.01, -6.96], ["c", 0.75, -2.49, 1.38, -4.56, 1.41, -4.62], ["c", 0.06, -0.15, 0.18, -0.21, 0.36, -0.24], ["c", 0.15, 0, 0.3, 0.06, 0.39, 0.18], ["c", 0.15, 0.21, 0.24, -0.18, -2.1, 7.56], ["c", -1.2, 3.96, -2.22, 7.32, -2.25, 7.41], ["c", 0, 0.12, -0.06, 0.27, -0.09, 0.3], ["c", -0.12, 0.21, -0.6, 0.21, -0.72, 0], ["c", -0.03, -0.03, -0.09, -0.18, -0.09, -0.3], ["c", -0.03, -0.09, -1.05, -3.45, -2.25, -7.41], ["c", -2.34, -7.74, -2.25, -7.35, -2.1, -7.56], ["c", 0.03, -0.03, 0.09, -0.09, 0.15, -0.12], ["z"]], w: 9.73, h: 15.608 },
      "scripts.downbow": { d: [["M", -5.55, -9.93], ["l", 0.09, -0.06], ["l", 5.46, 0], ["l", 5.46, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 4.77], ["c", 0, 5.28, 0, 4.89, -0.18, 5.01], ["c", -0.18, 0.12, -0.42, 0.06, -0.54, -0.12], ["c", -0.06, -0.09, -0.06, -0.18, -0.06, -2.97], ["l", 0, -2.85], ["l", -4.83, 0], ["l", -4.83, 0], ["l", 0, 2.85], ["c", 0, 2.79, 0, 2.88, -0.06, 2.97], ["c", -0.15, 0.24, -0.51, 0.24, -0.66, 0], ["c", -0.06, -0.09, -0.06, -0.21, -0.06, -4.89], ["l", 0, -4.77], ["z"]], w: 11.22, h: 9.992 },
      "scripts.turn": { d: [["M", -4.77, -3.9], ["c", 0.36, -0.06, 1.05, -0.06, 1.44, 0.03], ["c", 0.78, 0.15, 1.5, 0.51, 2.34, 1.14], ["c", 0.6, 0.45, 1.05, 0.87, 2.22, 2.01], ["c", 1.11, 1.08, 1.62, 1.5, 2.22, 1.86], ["c", 0.6, 0.36, 1.32, 0.57, 1.92, 0.57], ["c", 0.9, 0, 1.71, -0.57, 1.89, -1.35], ["c", 0.24, -0.93, -0.39, -1.89, -1.35, -2.1], ["l", -0.15, -0.06], ["l", -0.09, 0.15], ["c", -0.03, 0.09, -0.15, 0.24, -0.24, 0.33], ["c", -0.72, 0.72, -2.04, 0.54, -2.49, -0.36], ["c", -0.48, -0.93, 0.03, -1.86, 1.17, -2.19], ["c", 0.3, -0.09, 1.02, -0.09, 1.35, 0], ["c", 0.99, 0.27, 1.74, 0.87, 2.25, 1.83], ["c", 0.69, 1.41, 0.63, 3, -0.21, 4.26], ["c", -0.21, 0.3, -0.69, 0.81, -0.99, 1.02], ["c", -0.3, 0.21, -0.84, 0.45, -1.17, 0.54], ["c", -1.23, 0.36, -2.49, 0.15, -3.72, -0.6], ["c", -0.75, -0.48, -1.41, -1.02, -2.85, -2.46], ["c", -1.11, -1.08, -1.62, -1.5, -2.22, -1.86], ["c", -0.6, -0.36, -1.32, -0.57, -1.92, -0.57], ["c", -0.9, 0, -1.71, 0.57, -1.89, 1.35], ["c", -0.24, 0.93, 0.39, 1.89, 1.35, 2.1], ["l", 0.15, 0.06], ["l", 0.09, -0.15], ["c", 0.03, -0.09, 0.15, -0.24, 0.24, -0.33], ["c", 0.72, -0.72, 2.04, -0.54, 2.49, 0.36], ["c", 0.48, 0.93, -0.03, 1.86, -1.17, 2.19], ["c", -0.3, 0.09, -1.02, 0.09, -1.35, 0], ["c", -0.99, -0.27, -1.74, -0.87, -2.25, -1.83], ["c", -0.69, -1.41, -0.63, -3, 0.21, -4.26], ["c", 0.21, -0.3, 0.69, -0.81, 0.99, -1.02], ["c", 0.48, -0.33, 1.11, -0.57, 1.74, -0.66], ["z"]], w: 16.366, h: 7.893 },
      "scripts.trill": { d: [["M", -0.51, -16.02], ["c", 0.12, -0.09, 0.21, -0.18, 0.21, -0.18], ["l", -0.81, 4.02], ["l", -0.81, 4.02], ["c", 0.03, 0, 0.51, -0.27, 1.08, -0.6], ["c", 0.6, -0.3, 1.14, -0.63, 1.26, -0.66], ["c", 1.14, -0.54, 2.31, -0.6, 3.09, -0.18], ["c", 0.27, 0.15, 0.54, 0.36, 0.6, 0.51], ["l", 0.06, 0.12], ["l", 0.21, -0.21], ["c", 0.9, -0.81, 2.22, -0.99, 3.12, -0.42], ["c", 0.6, 0.42, 0.9, 1.14, 0.78, 2.07], ["c", -0.15, 1.29, -1.05, 2.31, -1.95, 2.25], ["c", -0.48, -0.03, -0.78, -0.3, -0.96, -0.81], ["c", -0.09, -0.27, -0.09, -0.9, -0.03, -1.2], ["c", 0.21, -0.75, 0.81, -1.23, 1.59, -1.32], ["l", 0.24, -0.03], ["l", -0.09, -0.12], ["c", -0.51, -0.66, -1.62, -0.63, -2.31, 0.03], ["c", -0.39, 0.42, -0.3, 0.09, -1.23, 4.77], ["l", -0.81, 4.14], ["c", -0.03, 0, -0.12, -0.03, -0.21, -0.09], ["c", -0.33, -0.15, -0.54, -0.18, -0.99, -0.18], ["c", -0.42, 0, -0.66, 0.03, -1.05, 0.18], ["c", -0.12, 0.06, -0.21, 0.09, -0.21, 0.09], ["c", 0, -0.03, 0.36, -1.86, 0.81, -4.11], ["c", 0.9, -4.47, 0.87, -4.26, 0.69, -4.53], ["c", -0.21, -0.36, -0.66, -0.51, -1.17, -0.36], ["c", -0.15, 0.06, -2.22, 1.14, -2.58, 1.38], ["c", -0.12, 0.09, -0.12, 0.09, -0.21, 0.6], ["l", -0.09, 0.51], ["l", 0.21, 0.24], ["c", 0.63, 0.75, 1.02, 1.47, 1.2, 2.19], ["c", 0.06, 0.27, 0.06, 0.36, 0.06, 0.81], ["c", 0, 0.42, 0, 0.54, -0.06, 0.78], ["c", -0.15, 0.54, -0.33, 0.93, -0.63, 1.35], ["c", -0.18, 0.24, -0.57, 0.63, -0.81, 0.78], ["c", -0.24, 0.15, -0.63, 0.36, -0.84, 0.42], ["c", -0.27, 0.06, -0.66, 0.06, -0.87, 0.03], ["c", -0.81, -0.18, -1.32, -1.05, -1.38, -2.46], ["c", -0.03, -0.6, 0.03, -0.99, 0.33, -2.46], ["c", 0.21, -1.08, 0.24, -1.32, 0.21, -1.29], ["c", -1.2, 0.48, -2.4, 0.75, -3.21, 0.72], ["c", -0.69, -0.06, -1.17, -0.3, -1.41, -0.72], ["c", -0.39, -0.75, -0.12, -1.8, 0.66, -2.46], ["c", 0.24, -0.18, 0.69, -0.42, 1.02, -0.51], ["c", 0.69, -0.18, 1.53, -0.15, 2.31, 0.09], ["c", 0.3, 0.09, 0.75, 0.3, 0.99, 0.45], ["c", 0.12, 0.09, 0.15, 0.09, 0.15, 0.03], ["c", 0.03, -0.03, 0.33, -1.59, 0.72, -3.45], ["c", 0.36, -1.86, 0.66, -3.42, 0.69, -3.45], ["c", 0, -0.03, 0.03, -0.03, 0.21, 0.03], ["c", 0.21, 0.06, 0.27, 0.06, 0.48, 0.06], ["c", 0.42, -0.03, 0.78, -0.18, 1.26, -0.48], ["c", 0.15, -0.12, 0.36, -0.27, 0.48, -0.39], ["z"], ["m", -5.73, 7.68], ["c", -0.27, -0.03, -0.96, -0.06, -1.2, -0.03], ["c", -0.81, 0.12, -1.35, 0.57, -1.5, 1.2], ["c", -0.18, 0.66, 0.12, 1.14, 0.75, 1.29], ["c", 0.66, 0.12, 1.92, -0.12, 3.18, -0.66], ["l", 0.33, -0.15], ["l", 0.09, -0.39], ["c", 0.06, -0.21, 0.09, -0.42, 0.09, -0.45], ["c", 0, -0.03, -0.45, -0.3, -0.75, -0.45], ["c", -0.27, -0.15, -0.66, -0.27, -0.99, -0.36], ["z"], ["m", 4.29, 3.63], ["c", -0.24, -0.39, -0.51, -0.75, -0.51, -0.69], ["c", -0.06, 0.12, -0.39, 1.92, -0.45, 2.28], ["c", -0.09, 0.54, -0.12, 1.14, -0.06, 1.38], ["c", 0.06, 0.42, 0.21, 0.6, 0.51, 0.57], ["c", 0.39, -0.06, 0.75, -0.48, 0.93, -1.14], ["c", 0.09, -0.33, 0.09, -1.05, 0, -1.38], ["c", -0.09, -0.39, -0.24, -0.69, -0.42, -1.02], ["z"]], w: 17.963, h: 16.49 },
      "scripts.segno": { d: [["M", -3.72, -11.22], ["c", 0.78, -0.09, 1.59, 0.03, 2.31, 0.42], ["c", 1.2, 0.6, 2.01, 1.71, 2.31, 3.09], ["c", 0.09, 0.42, 0.09, 1.2, 0.03, 1.5], ["c", -0.15, 0.45, -0.39, 0.81, -0.66, 0.93], ["c", -0.33, 0.18, -0.84, 0.21, -1.23, 0.15], ["c", -0.81, -0.18, -1.32, -0.93, -1.26, -1.89], ["c", 0.03, -0.36, 0.09, -0.57, 0.24, -0.9], ["c", 0.15, -0.33, 0.45, -0.6, 0.72, -0.75], ["c", 0.12, -0.06, 0.18, -0.09, 0.18, -0.12], ["c", 0, -0.03, -0.03, -0.15, -0.09, -0.24], ["c", -0.18, -0.45, -0.54, -0.87, -0.96, -1.08], ["c", -1.11, -0.57, -2.34, -0.18, -2.88, 0.9], ["c", -0.24, 0.51, -0.33, 1.11, -0.24, 1.83], ["c", 0.27, 1.92, 1.5, 3.54, 3.93, 5.13], ["c", 0.48, 0.33, 1.26, 0.78, 1.29, 0.78], ["c", 0.03, 0, 1.35, -2.19, 2.94, -4.89], ["l", 2.88, -4.89], ["l", 0.84, 0], ["l", 0.87, 0], ["l", -0.03, 0.06], ["c", -0.15, 0.21, -6.15, 10.41, -6.15, 10.44], ["c", 0, 0, 0.21, 0.15, 0.48, 0.27], ["c", 2.61, 1.47, 4.35, 3.03, 5.13, 4.65], ["c", 1.14, 2.34, 0.51, 5.07, -1.44, 6.39], ["c", -0.66, 0.42, -1.32, 0.63, -2.13, 0.69], ["c", -2.01, 0.09, -3.81, -1.41, -4.26, -3.54], ["c", -0.09, -0.42, -0.09, -1.2, -0.03, -1.5], ["c", 0.15, -0.45, 0.39, -0.81, 0.66, -0.93], ["c", 0.33, -0.18, 0.84, -0.21, 1.23, -0.15], ["c", 0.81, 0.18, 1.32, 0.93, 1.26, 1.89], ["c", -0.03, 0.36, -0.09, 0.57, -0.24, 0.9], ["c", -0.15, 0.33, -0.45, 0.6, -0.72, 0.75], ["c", -0.12, 0.06, -0.18, 0.09, -0.18, 0.12], ["c", 0, 0.03, 0.03, 0.15, 0.09, 0.24], ["c", 0.18, 0.45, 0.54, 0.87, 0.96, 1.08], ["c", 1.11, 0.57, 2.34, 0.18, 2.88, -0.9], ["c", 0.24, -0.51, 0.33, -1.11, 0.24, -1.83], ["c", -0.27, -1.92, -1.5, -3.54, -3.93, -5.13], ["c", -0.48, -0.33, -1.26, -0.78, -1.29, -0.78], ["c", -0.03, 0, -1.35, 2.19, -2.91, 4.89], ["l", -2.88, 4.89], ["l", -0.87, 0], ["l", -0.87, 0], ["l", 0.03, -0.06], ["c", 0.15, -0.21, 6.15, -10.41, 6.15, -10.44], ["c", 0, 0, -0.21, -0.15, -0.48, -0.3], ["c", -2.61, -1.44, -4.35, -3, -5.13, -4.62], ["c", -0.9, -1.89, -0.72, -4.02, 0.48, -5.52], ["c", 0.69, -0.84, 1.68, -1.41, 2.73, -1.53], ["z"], ["m", 8.76, 9.09], ["c", 0.03, -0.03, 0.15, -0.03, 0.27, -0.03], ["c", 0.33, 0.03, 0.57, 0.18, 0.72, 0.48], ["c", 0.09, 0.18, 0.09, 0.57, 0, 0.75], ["c", -0.09, 0.18, -0.21, 0.3, -0.36, 0.39], ["c", -0.15, 0.06, -0.21, 0.06, -0.39, 0.06], ["c", -0.21, 0, -0.27, 0, -0.39, -0.06], ["c", -0.3, -0.15, -0.48, -0.45, -0.48, -0.75], ["c", 0, -0.39, 0.24, -0.72, 0.63, -0.84], ["z"], ["m", -10.53, 2.61], ["c", 0.03, -0.03, 0.15, -0.03, 0.27, -0.03], ["c", 0.33, 0.03, 0.57, 0.18, 0.72, 0.48], ["c", 0.09, 0.18, 0.09, 0.57, 0, 0.75], ["c", -0.09, 0.18, -0.21, 0.3, -0.36, 0.39], ["c", -0.15, 0.06, -0.21, 0.06, -0.39, 0.06], ["c", -0.21, 0, -0.27, 0, -0.39, -0.06], ["c", -0.3, -0.15, -0.48, -0.45, -0.48, -0.75], ["c", 0, -0.39, 0.24, -0.72, 0.63, -0.84], ["z"]], w: 15, h: 22.504 },
      "scripts.coda": { d: [["M", -0.21, -10.47], ["c", 0.18, -0.12, 0.42, -0.06, 0.54, 0.12], ["c", 0.06, 0.09, 0.06, 0.18, 0.06, 1.5], ["l", 0, 1.38], ["l", 0.18, 0], ["c", 0.39, 0.06, 0.96, 0.24, 1.38, 0.48], ["c", 1.68, 0.93, 2.82, 3.24, 3.03, 6.12], ["c", 0.03, 0.24, 0.03, 0.45, 0.03, 0.45], ["c", 0, 0.03, 0.6, 0.03, 1.35, 0.03], ["c", 1.5, 0, 1.47, 0, 1.59, 0.18], ["c", 0.09, 0.12, 0.09, 0.3, 0, 0.42], ["c", -0.12, 0.18, -0.09, 0.18, -1.59, 0.18], ["c", -0.75, 0, -1.35, 0, -1.35, 0.03], ["c", 0, 0, 0, 0.21, -0.03, 0.42], ["c", -0.24, 3.15, -1.53, 5.58, -3.45, 6.36], ["c", -0.27, 0.12, -0.72, 0.24, -0.96, 0.27], ["l", -0.18, 0], ["l", 0, 1.38], ["c", 0, 1.32, 0, 1.41, -0.06, 1.5], ["c", -0.15, 0.24, -0.51, 0.24, -0.66, 0], ["c", -0.06, -0.09, -0.06, -0.18, -0.06, -1.5], ["l", 0, -1.38], ["l", -0.18, 0], ["c", -0.39, -0.06, -0.96, -0.24, -1.38, -0.48], ["c", -1.68, -0.93, -2.82, -3.24, -3.03, -6.15], ["c", -0.03, -0.21, -0.03, -0.42, -0.03, -0.42], ["c", 0, -0.03, -0.6, -0.03, -1.35, -0.03], ["c", -1.5, 0, -1.47, 0, -1.59, -0.18], ["c", -0.09, -0.12, -0.09, -0.3, 0, -0.42], ["c", 0.12, -0.18, 0.09, -0.18, 1.59, -0.18], ["c", 0.75, 0, 1.35, 0, 1.35, -0.03], ["c", 0, 0, 0, -0.21, 0.03, -0.45], ["c", 0.24, -3.12, 1.53, -5.55, 3.45, -6.33], ["c", 0.27, -0.12, 0.72, -0.24, 0.96, -0.27], ["l", 0.18, 0], ["l", 0, -1.38], ["c", 0, -1.53, 0, -1.5, 0.18, -1.62], ["z"], ["m", -0.18, 6.93], ["c", 0, -2.97, 0, -3.15, -0.06, -3.15], ["c", -0.09, 0, -0.51, 0.15, -0.66, 0.21], ["c", -0.87, 0.51, -1.38, 1.62, -1.56, 3.51], ["c", -0.06, 0.54, -0.12, 1.59, -0.12, 2.16], ["l", 0, 0.42], ["l", 1.2, 0], ["l", 1.2, 0], ["l", 0, -3.15], ["z"], ["m", 1.17, -3.06], ["c", -0.09, -0.03, -0.21, -0.06, -0.27, -0.09], ["l", -0.12, 0], ["l", 0, 3.15], ["l", 0, 3.15], ["l", 1.2, 0], ["l", 1.2, 0], ["l", 0, -0.81], ["c", -0.06, -2.4, -0.33, -3.69, -0.93, -4.59], ["c", -0.27, -0.39, -0.66, -0.69, -1.08, -0.81], ["z"], ["m", -1.17, 10.14], ["l", 0, -3.15], ["l", -1.2, 0], ["l", -1.2, 0], ["l", 0, 0.81], ["c", 0.03, 0.96, 0.06, 1.47, 0.15, 2.13], ["c", 0.24, 2.04, 0.96, 3.12, 2.13, 3.36], ["l", 0.12, 0], ["l", 0, -3.15], ["z"], ["m", 3.18, -2.34], ["l", 0, -0.81], ["l", -1.2, 0], ["l", -1.2, 0], ["l", 0, 3.15], ["l", 0, 3.15], ["l", 0.12, 0], ["c", 1.17, -0.24, 1.89, -1.32, 2.13, -3.36], ["c", 0.09, -0.66, 0.12, -1.17, 0.15, -2.13], ["z"]], w: 16.035, h: 21.062 },
      "scripts.comma": { d: [["M", 1.14, -4.62], ["c", 0.3, -0.12, 0.69, -0.03, 0.93, 0.15], ["c", 0.12, 0.12, 0.36, 0.45, 0.51, 0.78], ["c", 0.9, 1.77, 0.54, 4.05, -1.08, 6.75], ["c", -0.36, 0.63, -0.87, 1.38, -0.96, 1.44], ["c", -0.18, 0.12, -0.42, 0.06, -0.54, -0.12], ["c", -0.09, -0.18, -0.09, -0.3, 0.12, -0.6], ["c", 0.96, -1.44, 1.44, -2.97, 1.38, -4.35], ["c", -0.06, -0.93, -0.3, -1.68, -0.78, -2.46], ["c", -0.27, -0.39, -0.33, -0.63, -0.24, -0.96], ["c", 0.09, -0.27, 0.36, -0.54, 0.66, -0.63], ["z"]], w: 3.042, h: 9.237 },
      "scripts.roll": { d: [["M", 1.95, -6], ["c", 0.21, -0.09, 0.36, -0.09, 0.57, 0], ["c", 0.39, 0.15, 0.63, 0.39, 1.47, 1.35], ["c", 0.66, 0.75, 0.78, 0.87, 1.08, 1.05], ["c", 0.75, 0.45, 1.65, 0.42, 2.4, -0.06], ["c", 0.12, -0.09, 0.27, -0.27, 0.54, -0.6], ["c", 0.42, -0.54, 0.51, -0.63, 0.69, -0.63], ["c", 0.09, 0, 0.3, 0.12, 0.36, 0.21], ["c", 0.09, 0.12, 0.12, 0.3, 0.03, 0.42], ["c", -0.06, 0.12, -3.15, 3.9, -3.3, 4.08], ["c", -0.06, 0.06, -0.18, 0.12, -0.27, 0.18], ["c", -0.27, 0.12, -0.6, 0.06, -0.99, -0.27], ["c", -0.27, -0.21, -0.42, -0.39, -1.08, -1.14], ["c", -0.63, -0.72, -0.81, -0.9, -1.17, -1.08], ["c", -0.36, -0.18, -0.57, -0.21, -0.99, -0.21], ["c", -0.39, 0, -0.63, 0.03, -0.93, 0.18], ["c", -0.36, 0.15, -0.51, 0.27, -0.9, 0.81], ["c", -0.24, 0.27, -0.45, 0.51, -0.48, 0.54], ["c", -0.12, 0.09, -0.27, 0.06, -0.39, 0], ["c", -0.24, -0.15, -0.33, -0.39, -0.21, -0.6], ["c", 0.09, -0.12, 3.18, -3.87, 3.33, -4.02], ["c", 0.06, -0.06, 0.18, -0.15, 0.24, -0.21], ["z"]], w: 10.817, h: 6.125 },
      "scripts.prall": { d: [["M", -4.38, -3.69], ["c", 0.06, -0.03, 0.18, -0.06, 0.24, -0.06], ["c", 0.3, 0, 0.27, -0.03, 1.89, 1.95], ["l", 1.53, 1.83], ["c", 0.03, 0, 0.57, -0.84, 1.23, -1.83], ["c", 1.14, -1.68, 1.23, -1.83, 1.35, -1.89], ["c", 0.06, -0.03, 0.18, -0.06, 0.24, -0.06], ["c", 0.3, 0, 0.27, -0.03, 1.89, 1.95], ["l", 1.53, 1.83], ["l", 0.48, -0.69], ["c", 0.51, -0.78, 0.54, -0.84, 0.69, -0.9], ["c", 0.42, -0.18, 0.87, 0.15, 0.81, 0.6], ["c", -0.03, 0.12, -0.3, 0.51, -1.5, 2.37], ["c", -1.38, 2.07, -1.5, 2.22, -1.62, 2.28], ["c", -0.06, 0.03, -0.18, 0.06, -0.24, 0.06], ["c", -0.3, 0, -0.27, 0.03, -1.89, -1.95], ["l", -1.53, -1.83], ["c", -0.03, 0, -0.57, 0.84, -1.23, 1.83], ["c", -1.14, 1.68, -1.23, 1.83, -1.35, 1.89], ["c", -0.06, 0.03, -0.18, 0.06, -0.24, 0.06], ["c", -0.3, 0, -0.27, 0.03, -1.89, -1.95], ["l", -1.53, -1.83], ["l", -0.48, 0.69], ["c", -0.51, 0.78, -0.54, 0.84, -0.69, 0.9], ["c", -0.42, 0.18, -0.87, -0.15, -0.81, -0.6], ["c", 0.03, -0.12, 0.3, -0.51, 1.5, -2.37], ["c", 1.38, -2.07, 1.5, -2.22, 1.62, -2.28], ["z"]], w: 15.011, h: 7.5 },
      "scripts.arpeggio": { d: [["M", 1.5, 0], ["c", 1.5, 2, 1.5, 3, 1.5, 3], ["s", 0, 1, -2, 1.5], ["s", -0.5, 3, 1, 5.5], ["l", 1.5, 0], ["s", -1.75, -2, -1.9, -3.25], ["s", 2.15, -0.6, 2.95, -1.6], ["s", 0.45, -1, 0.5, -1.25], ["s", 0, -1, -2, -3.9], ["l", -1.5, 0], ["z"]], w: 5, h: 10 },
      "scripts.mordent": { d: [["M", -0.21, -4.95], ["c", 0.27, -0.15, 0.63, 0, 0.75, 0.27], ["c", 0.06, 0.12, 0.06, 0.24, 0.06, 1.44], ["l", 0, 1.29], ["l", 0.57, -0.84], ["c", 0.51, -0.75, 0.57, -0.84, 0.69, -0.9], ["c", 0.06, -0.03, 0.18, -0.06, 0.24, -0.06], ["c", 0.3, 0, 0.27, -0.03, 1.89, 1.95], ["l", 1.53, 1.83], ["l", 0.48, -0.69], ["c", 0.51, -0.78, 0.54, -0.84, 0.69, -0.9], ["c", 0.42, -0.18, 0.87, 0.15, 0.81, 0.6], ["c", -0.03, 0.12, -0.3, 0.51, -1.5, 2.37], ["c", -1.38, 2.07, -1.5, 2.22, -1.62, 2.28], ["c", -0.06, 0.03, -0.18, 0.06, -0.24, 0.06], ["c", -0.3, 0, -0.27, 0.03, -1.83, -1.89], ["c", -0.81, -0.99, -1.5, -1.8, -1.53, -1.86], ["c", -0.06, -0.03, -0.06, -0.03, -0.12, 0.03], ["c", -0.06, 0.06, -0.06, 0.15, -0.06, 2.28], ["c", 0, 1.95, 0, 2.25, -0.06, 2.34], ["c", -0.18, 0.45, -0.81, 0.48, -1.05, 0.03], ["c", -0.03, -0.06, -0.06, -0.24, -0.06, -1.41], ["l", 0, -1.35], ["l", -0.57, 0.84], ["c", -0.54, 0.78, -0.6, 0.87, -0.72, 0.93], ["c", -0.06, 0.03, -0.18, 0.06, -0.24, 0.06], ["c", -0.3, 0, -0.27, 0.03, -1.89, -1.95], ["l", -1.53, -1.83], ["l", -0.48, 0.69], ["c", -0.51, 0.78, -0.54, 0.84, -0.69, 0.9], ["c", -0.42, 0.18, -0.87, -0.15, -0.81, -0.6], ["c", 0.03, -0.12, 0.3, -0.51, 1.5, -2.37], ["c", 1.38, -2.07, 1.5, -2.22, 1.62, -2.28], ["c", 0.06, -0.03, 0.18, -0.06, 0.24, -0.06], ["c", 0.3, 0, 0.27, -0.03, 1.89, 1.95], ["l", 1.53, 1.83], ["c", 0.03, 0, 0.06, -0.06, 0.09, -0.09], ["c", 0.06, -0.12, 0.06, -0.15, 0.06, -2.28], ["c", 0, -1.92, 0, -2.22, 0.06, -2.31], ["c", 0.06, -0.15, 0.15, -0.24, 0.3, -0.3], ["z"]], w: 15.011, h: 10.012 },
      "flags.u8th": { d: [["M", -0.42, 3.75], ["l", 0, -3.75], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 0.18], ["c", 0, 0.3, 0.06, 0.84, 0.12, 1.23], ["c", 0.24, 1.53, 0.9, 3.12, 2.13, 5.16], ["l", 0.99, 1.59], ["c", 0.87, 1.44, 1.38, 2.34, 1.77, 3.09], ["c", 0.81, 1.68, 1.2, 3.06, 1.26, 4.53], ["c", 0.03, 1.53, -0.21, 3.27, -0.75, 5.01], ["c", -0.21, 0.69, -0.51, 1.5, -0.6, 1.59], ["c", -0.09, 0.12, -0.27, 0.21, -0.42, 0.21], ["c", -0.15, 0, -0.42, -0.12, -0.51, -0.21], ["c", -0.15, -0.18, -0.18, -0.42, -0.09, -0.66], ["c", 0.15, -0.33, 0.45, -1.2, 0.57, -1.62], ["c", 0.42, -1.38, 0.6, -2.58, 0.6, -3.9], ["c", 0, -0.66, 0, -0.81, -0.06, -1.11], ["c", -0.39, -2.07, -1.8, -4.26, -4.59, -7.14], ["l", -0.42, -0.45], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -3.75], ["z"]], w: 6.692, h: 22.59 },
      "flags.u16th": { d: [["M", -0.42, 7.5], ["l", 0, -7.5], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 0.39], ["c", 0.06, 1.08, 0.39, 2.19, 0.99, 3.39], ["c", 0.45, 0.9, 0.87, 1.59, 1.95, 3.12], ["c", 1.29, 1.86, 1.77, 2.64, 2.22, 3.57], ["c", 0.45, 0.93, 0.72, 1.8, 0.87, 2.64], ["c", 0.06, 0.51, 0.06, 1.5, 0, 1.92], ["c", -0.12, 0.6, -0.3, 1.2, -0.54, 1.71], ["l", -0.09, 0.24], ["l", 0.18, 0.45], ["c", 0.51, 1.2, 0.72, 2.22, 0.69, 3.42], ["c", -0.06, 1.53, -0.39, 3.03, -0.99, 4.53], ["c", -0.3, 0.75, -0.36, 0.81, -0.57, 0.9], ["c", -0.15, 0.09, -0.33, 0.06, -0.48, 0], ["c", -0.18, -0.09, -0.27, -0.18, -0.33, -0.33], ["c", -0.09, -0.18, -0.06, -0.3, 0.12, -0.75], ["c", 0.66, -1.41, 1.02, -2.88, 1.08, -4.32], ["c", 0, -0.6, -0.03, -1.05, -0.18, -1.59], ["c", -0.3, -1.2, -0.99, -2.4, -2.25, -3.87], ["c", -0.42, -0.48, -1.53, -1.62, -2.19, -2.22], ["l", -0.45, -0.42], ["l", -0.03, 1.11], ["l", 0, 1.11], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -7.5], ["z"], ["m", 1.65, 0.09], ["c", -0.3, -0.3, -0.69, -0.72, -0.9, -0.87], ["l", -0.33, -0.33], ["l", 0, 0.15], ["c", 0, 0.3, 0.06, 0.81, 0.15, 1.26], ["c", 0.27, 1.29, 0.87, 2.61, 2.04, 4.29], ["c", 0.15, 0.24, 0.6, 0.87, 0.96, 1.38], ["l", 1.08, 1.53], ["l", 0.42, 0.63], ["c", 0.03, 0, 0.12, -0.36, 0.21, -0.72], ["c", 0.06, -0.33, 0.06, -1.2, 0, -1.62], ["c", -0.33, -1.71, -1.44, -3.48, -3.63, -5.7], ["z"]], w: 6.693, h: 26.337 },
      "flags.u32nd": { d: [["M", -0.42, 11.25], ["l", 0, -11.25], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 0.36], ["c", 0.09, 1.68, 0.69, 3.27, 2.07, 5.46], ["l", 0.87, 1.35], ["c", 1.02, 1.62, 1.47, 2.37, 1.86, 3.18], ["c", 0.48, 1.02, 0.78, 1.92, 0.93, 2.88], ["c", 0.06, 0.48, 0.06, 1.5, 0, 1.89], ["c", -0.09, 0.42, -0.21, 0.87, -0.36, 1.26], ["l", -0.12, 0.3], ["l", 0.15, 0.39], ["c", 0.69, 1.56, 0.84, 2.88, 0.54, 4.38], ["c", -0.09, 0.45, -0.27, 1.08, -0.45, 1.47], ["l", -0.12, 0.24], ["l", 0.18, 0.36], ["c", 0.33, 0.72, 0.57, 1.56, 0.69, 2.34], ["c", 0.12, 1.02, -0.06, 2.52, -0.42, 3.84], ["c", -0.27, 0.93, -0.75, 2.13, -0.93, 2.31], ["c", -0.18, 0.15, -0.45, 0.18, -0.66, 0.09], ["c", -0.18, -0.09, -0.27, -0.18, -0.33, -0.33], ["c", -0.09, -0.18, -0.06, -0.3, 0.06, -0.6], ["c", 0.21, -0.36, 0.42, -0.9, 0.57, -1.38], ["c", 0.51, -1.41, 0.69, -3.06, 0.48, -4.08], ["c", -0.15, -0.81, -0.57, -1.68, -1.2, -2.55], ["c", -0.72, -0.99, -1.83, -2.13, -3.3, -3.33], ["l", -0.48, -0.42], ["l", -0.03, 1.53], ["l", 0, 1.56], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -11.25], ["z"], ["m", 1.26, -3.96], ["c", -0.27, -0.3, -0.54, -0.6, -0.66, -0.72], ["l", -0.18, -0.21], ["l", 0, 0.42], ["c", 0.06, 0.87, 0.24, 1.74, 0.66, 2.67], ["c", 0.36, 0.87, 0.96, 1.86, 1.92, 3.18], ["c", 0.21, 0.33, 0.63, 0.87, 0.87, 1.23], ["c", 0.27, 0.39, 0.6, 0.84, 0.75, 1.08], ["l", 0.27, 0.39], ["l", 0.03, -0.12], ["c", 0.12, -0.45, 0.15, -1.05, 0.09, -1.59], ["c", -0.27, -1.86, -1.38, -3.78, -3.75, -6.33], ["z"], ["m", -0.27, 6.09], ["c", -0.27, -0.21, -0.48, -0.42, -0.51, -0.45], ["c", -0.06, -0.03, -0.06, -0.03, -0.06, 0.21], ["c", 0, 0.9, 0.3, 2.04, 0.81, 3.09], ["c", 0.48, 1.02, 0.96, 1.77, 2.37, 3.63], ["c", 0.6, 0.78, 1.05, 1.44, 1.29, 1.77], ["c", 0.06, 0.12, 0.15, 0.21, 0.15, 0.18], ["c", 0.03, -0.03, 0.18, -0.57, 0.24, -0.87], ["c", 0.06, -0.45, 0.06, -1.32, -0.03, -1.74], ["c", -0.09, -0.48, -0.24, -0.9, -0.51, -1.44], ["c", -0.66, -1.35, -1.83, -2.7, -3.75, -4.38], ["z"]], w: 6.697, h: 32.145 },
      "flags.u64th": { d: [["M", -0.42, 15], ["l", 0, -15], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 0.36], ["c", 0.06, 1.2, 0.39, 2.37, 1.02, 3.66], ["c", 0.39, 0.81, 0.84, 1.56, 1.8, 3.09], ["c", 0.81, 1.26, 1.05, 1.68, 1.35, 2.22], ["c", 0.87, 1.5, 1.35, 2.79, 1.56, 4.08], ["c", 0.06, 0.54, 0.06, 1.56, -0.03, 2.04], ["c", -0.09, 0.48, -0.21, 0.99, -0.36, 1.35], ["l", -0.12, 0.27], ["l", 0.12, 0.27], ["c", 0.09, 0.15, 0.21, 0.45, 0.27, 0.66], ["c", 0.69, 1.89, 0.63, 3.66, -0.18, 5.46], ["l", -0.18, 0.39], ["l", 0.15, 0.33], ["c", 0.3, 0.66, 0.51, 1.44, 0.63, 2.1], ["c", 0.06, 0.48, 0.06, 1.35, 0, 1.71], ["c", -0.15, 0.57, -0.42, 1.2, -0.78, 1.68], ["l", -0.21, 0.27], ["l", 0.18, 0.33], ["c", 0.57, 1.05, 0.93, 2.13, 1.02, 3.18], ["c", 0.06, 0.72, 0, 1.83, -0.21, 2.79], ["c", -0.18, 1.02, -0.63, 2.34, -1.02, 3.09], ["c", -0.15, 0.33, -0.48, 0.45, -0.78, 0.3], ["c", -0.18, -0.09, -0.27, -0.18, -0.33, -0.33], ["c", -0.09, -0.18, -0.06, -0.3, 0.03, -0.54], ["c", 0.75, -1.5, 1.23, -3.45, 1.17, -4.89], ["c", -0.06, -1.02, -0.42, -2.01, -1.17, -3.15], ["c", -0.48, -0.72, -1.02, -1.35, -1.89, -2.22], ["c", -0.57, -0.57, -1.56, -1.5, -1.92, -1.77], ["l", -0.12, -0.09], ["l", 0, 1.68], ["l", 0, 1.68], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -15], ["z"], ["m", 0.93, -8.07], ["c", -0.27, -0.3, -0.48, -0.54, -0.51, -0.54], ["c", 0, 0, 0, 0.69, 0.03, 1.02], ["c", 0.15, 1.47, 0.75, 2.94, 2.04, 4.83], ["l", 1.08, 1.53], ["c", 0.39, 0.57, 0.84, 1.2, 0.99, 1.44], ["c", 0.15, 0.24, 0.3, 0.45, 0.3, 0.45], ["c", 0, 0, 0.03, -0.09, 0.06, -0.21], ["c", 0.36, -1.59, -0.15, -3.33, -1.47, -5.4], ["c", -0.63, -0.93, -1.35, -1.83, -2.52, -3.12], ["z"], ["m", 0.06, 6.72], ["c", -0.24, -0.21, -0.48, -0.42, -0.51, -0.45], ["l", -0.06, -0.06], ["l", 0, 0.33], ["c", 0, 1.2, 0.3, 2.34, 0.93, 3.6], ["c", 0.45, 0.9, 0.96, 1.68, 2.25, 3.51], ["c", 0.39, 0.54, 0.84, 1.17, 1.02, 1.44], ["c", 0.21, 0.33, 0.33, 0.51, 0.33, 0.48], ["c", 0.06, -0.09, 0.21, -0.63, 0.3, -0.99], ["c", 0.06, -0.33, 0.06, -0.45, 0.06, -0.96], ["c", 0, -0.6, -0.03, -0.84, -0.18, -1.35], ["c", -0.3, -1.08, -1.02, -2.28, -2.13, -3.57], ["c", -0.39, -0.45, -1.44, -1.47, -2.01, -1.98], ["z"], ["m", 0, 6.72], ["c", -0.24, -0.21, -0.48, -0.39, -0.51, -0.42], ["l", -0.06, -0.06], ["l", 0, 0.33], ["c", 0, 1.41, 0.45, 2.82, 1.38, 4.35], ["c", 0.42, 0.72, 0.72, 1.14, 1.86, 2.73], ["c", 0.36, 0.45, 0.75, 0.99, 0.87, 1.2], ["c", 0.15, 0.21, 0.3, 0.36, 0.3, 0.36], ["c", 0.06, 0, 0.3, -0.48, 0.39, -0.75], ["c", 0.09, -0.36, 0.12, -0.63, 0.12, -1.05], ["c", -0.06, -1.05, -0.45, -2.04, -1.2, -3.18], ["c", -0.57, -0.87, -1.11, -1.53, -2.07, -2.49], ["c", -0.36, -0.33, -0.84, -0.78, -1.08, -1.02], ["z"]], w: 6.682, h: 39.694 },
      "flags.d8th": { d: [["M", 5.67, -21.63], ["c", 0.24, -0.12, 0.54, -0.06, 0.69, 0.15], ["c", 0.06, 0.06, 0.21, 0.36, 0.39, 0.66], ["c", 0.84, 1.77, 1.26, 3.36, 1.32, 5.1], ["c", 0.03, 1.29, -0.21, 2.37, -0.81, 3.63], ["c", -0.6, 1.23, -1.26, 2.13, -3.21, 4.38], ["c", -1.35, 1.53, -1.86, 2.19, -2.4, 2.97], ["c", -0.63, 0.93, -1.11, 1.92, -1.38, 2.79], ["c", -0.15, 0.54, -0.27, 1.35, -0.27, 1.8], ["l", 0, 0.15], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -3.75], ["l", 0, -3.75], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0.48, -0.3], ["c", 1.83, -1.11, 3.12, -2.1, 4.17, -3.12], ["c", 0.78, -0.81, 1.32, -1.53, 1.71, -2.31], ["c", 0.45, -0.93, 0.6, -1.74, 0.51, -2.88], ["c", -0.12, -1.56, -0.63, -3.18, -1.47, -4.68], ["c", -0.12, -0.21, -0.15, -0.33, -0.06, -0.51], ["c", 0.06, -0.15, 0.15, -0.24, 0.33, -0.33], ["z"]], w: 8.492, h: 21.691 },
      "flags.ugrace": { d: [["M", 6.03, 6.93], ["c", 0.15, -0.09, 0.33, -0.06, 0.51, 0], ["c", 0.15, 0.09, 0.21, 0.15, 0.3, 0.33], ["c", 0.09, 0.18, 0.06, 0.39, -0.03, 0.54], ["c", -0.06, 0.15, -10.89, 8.88, -11.07, 8.97], ["c", -0.15, 0.09, -0.33, 0.06, -0.48, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.09, -0.18, -0.06, -0.39, 0.03, -0.54], ["c", 0.06, -0.15, 10.89, -8.88, 11.07, -8.97], ["z"]], w: 12.019, h: 9.954 },
      "flags.dgrace": { d: [["M", -6.06, -15.93], ["c", 0.18, -0.09, 0.33, -0.12, 0.48, -0.06], ["c", 0.18, 0.09, 14.01, 8.04, 14.1, 8.1], ["c", 0.12, 0.12, 0.18, 0.33, 0.18, 0.51], ["c", -0.03, 0.21, -0.15, 0.39, -0.36, 0.48], ["c", -0.18, 0.09, -0.33, 0.12, -0.48, 0.06], ["c", -0.18, -0.09, -14.01, -8.04, -14.1, -8.1], ["c", -0.12, -0.12, -0.18, -0.33, -0.18, -0.51], ["c", 0.03, -0.21, 0.15, -0.39, 0.36, -0.48], ["z"]], w: 15.12, h: 9.212 },
      "flags.d16th": { d: [["M", 6.84, -22.53], ["c", 0.27, -0.12, 0.57, -0.06, 0.72, 0.15], ["c", 0.15, 0.15, 0.33, 0.87, 0.45, 1.56], ["c", 0.06, 0.33, 0.06, 1.35, 0, 1.65], ["c", -0.06, 0.33, -0.15, 0.78, -0.27, 1.11], ["c", -0.12, 0.33, -0.45, 0.96, -0.66, 1.32], ["l", -0.18, 0.27], ["l", 0.09, 0.18], ["c", 0.48, 1.02, 0.72, 2.25, 0.69, 3.3], ["c", -0.06, 1.23, -0.42, 2.28, -1.26, 3.45], ["c", -0.57, 0.87, -0.99, 1.32, -3, 3.39], ["c", -1.56, 1.56, -2.22, 2.4, -2.76, 3.45], ["c", -0.42, 0.84, -0.66, 1.8, -0.66, 2.55], ["l", 0, 0.15], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -7.5], ["l", 0, -7.5], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 1.14], ["l", 0, 1.11], ["l", 0.27, -0.15], ["c", 1.11, -0.57, 1.77, -0.99, 2.52, -1.47], ["c", 2.37, -1.56, 3.69, -3.15, 4.05, -4.83], ["c", 0.03, -0.18, 0.03, -0.39, 0.03, -0.78], ["c", 0, -0.6, -0.03, -0.93, -0.24, -1.5], ["c", -0.06, -0.18, -0.12, -0.39, -0.15, -0.45], ["c", -0.03, -0.24, 0.12, -0.48, 0.36, -0.6], ["z"], ["m", -0.63, 7.5], ["c", -0.06, -0.18, -0.15, -0.36, -0.15, -0.36], ["c", -0.03, 0, -0.03, 0.03, -0.06, 0.06], ["c", -0.06, 0.12, -0.96, 1.02, -1.95, 1.98], ["c", -0.63, 0.57, -1.26, 1.17, -1.44, 1.35], ["c", -1.53, 1.62, -2.28, 2.85, -2.55, 4.32], ["c", -0.03, 0.18, -0.03, 0.54, -0.06, 0.99], ["l", 0, 0.69], ["l", 0.18, -0.09], ["c", 0.93, -0.54, 2.1, -1.29, 2.82, -1.83], ["c", 0.69, -0.51, 1.02, -0.81, 1.53, -1.29], ["c", 1.86, -1.89, 2.37, -3.66, 1.68, -5.82], ["z"]], w: 8.475, h: 22.591 },
      "flags.d32nd": { d: [["M", 6.84, -29.13], ["c", 0.27, -0.12, 0.57, -0.06, 0.72, 0.15], ["c", 0.12, 0.12, 0.27, 0.63, 0.36, 1.11], ["c", 0.33, 1.59, 0.06, 3.06, -0.81, 4.47], ["l", -0.18, 0.27], ["l", 0.09, 0.15], ["c", 0.12, 0.24, 0.33, 0.69, 0.45, 1.05], ["c", 0.63, 1.83, 0.45, 3.57, -0.57, 5.22], ["l", -0.18, 0.3], ["l", 0.15, 0.27], ["c", 0.42, 0.87, 0.6, 1.71, 0.57, 2.61], ["c", -0.06, 1.29, -0.48, 2.46, -1.35, 3.78], ["c", -0.54, 0.81, -0.93, 1.29, -2.46, 3], ["c", -0.51, 0.54, -1.05, 1.17, -1.26, 1.41], ["c", -1.56, 1.86, -2.25, 3.36, -2.37, 5.01], ["l", 0, 0.33], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -11.25], ["l", 0, -11.25], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 1.35], ["l", 0.03, 1.35], ["l", 0.78, -0.39], ["c", 1.38, -0.69, 2.34, -1.26, 3.24, -1.92], ["c", 1.38, -1.02, 2.28, -2.13, 2.64, -3.21], ["c", 0.15, -0.48, 0.18, -0.72, 0.18, -1.29], ["c", 0, -0.57, -0.06, -0.9, -0.24, -1.47], ["c", -0.06, -0.18, -0.12, -0.39, -0.15, -0.45], ["c", -0.03, -0.24, 0.12, -0.48, 0.36, -0.6], ["z"], ["m", -0.63, 7.2], ["c", -0.09, -0.18, -0.12, -0.21, -0.12, -0.15], ["c", -0.03, 0.09, -1.02, 1.08, -2.04, 2.04], ["c", -1.17, 1.08, -1.65, 1.56, -2.07, 2.04], ["c", -0.84, 0.96, -1.38, 1.86, -1.68, 2.76], ["c", -0.21, 0.57, -0.27, 0.99, -0.3, 1.65], ["l", 0, 0.54], ["l", 0.66, -0.33], ["c", 3.57, -1.86, 5.49, -3.69, 5.94, -5.7], ["c", 0.06, -0.39, 0.06, -1.2, -0.03, -1.65], ["c", -0.06, -0.39, -0.24, -0.9, -0.36, -1.2], ["z"], ["m", -0.06, 7.2], ["c", -0.06, -0.15, -0.12, -0.33, -0.15, -0.45], ["l", -0.06, -0.18], ["l", -0.18, 0.21], ["l", -1.83, 1.83], ["c", -0.87, 0.9, -1.77, 1.8, -1.95, 2.01], ["c", -1.08, 1.29, -1.62, 2.31, -1.89, 3.51], ["c", -0.06, 0.3, -0.06, 0.51, -0.09, 0.93], ["l", 0, 0.57], ["l", 0.09, -0.06], ["c", 0.75, -0.45, 1.89, -1.26, 2.52, -1.74], ["c", 0.81, -0.66, 1.74, -1.53, 2.22, -2.16], ["c", 1.26, -1.53, 1.68, -3.06, 1.32, -4.47], ["z"]], w: 8.385, h: 29.191 },
      "flags.d64th": { d: [["M", 7.08, -32.88], ["c", 0.3, -0.12, 0.66, -0.03, 0.78, 0.24], ["c", 0.18, 0.33, 0.27, 2.1, 0.15, 2.64], ["c", -0.09, 0.39, -0.21, 0.78, -0.39, 1.08], ["l", -0.15, 0.3], ["l", 0.09, 0.27], ["c", 0.03, 0.12, 0.09, 0.45, 0.12, 0.69], ["c", 0.27, 1.44, 0.18, 2.55, -0.3, 3.6], ["l", -0.12, 0.33], ["l", 0.06, 0.42], ["c", 0.27, 1.35, 0.33, 2.82, 0.21, 3.63], ["c", -0.12, 0.6, -0.3, 1.23, -0.57, 1.8], ["l", -0.15, 0.27], ["l", 0.03, 0.42], ["c", 0.06, 1.02, 0.06, 2.7, 0.03, 3.06], ["c", -0.15, 1.47, -0.66, 2.76, -1.74, 4.41], ["c", -0.45, 0.69, -0.75, 1.11, -1.74, 2.37], ["c", -1.05, 1.38, -1.5, 1.98, -1.95, 2.73], ["c", -0.93, 1.5, -1.38, 2.82, -1.44, 4.2], ["l", 0, 0.42], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -15], ["l", 0, -15], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 1.86], ["l", 0, 1.89], ["c", 0, 0, 0.21, -0.03, 0.45, -0.09], ["c", 2.22, -0.39, 4.08, -1.11, 5.19, -2.01], ["c", 0.63, -0.54, 1.02, -1.14, 1.2, -1.8], ["c", 0.06, -0.3, 0.06, -1.14, -0.03, -1.65], ["c", -0.03, -0.18, -0.06, -0.39, -0.09, -0.48], ["c", -0.03, -0.24, 0.12, -0.48, 0.36, -0.6], ["z"], ["m", -0.45, 6.15], ["c", -0.03, -0.18, -0.06, -0.42, -0.06, -0.54], ["l", -0.03, -0.18], ["l", -0.33, 0.3], ["c", -0.42, 0.36, -0.87, 0.72, -1.68, 1.29], ["c", -1.98, 1.38, -2.25, 1.59, -2.85, 2.16], ["c", -0.75, 0.69, -1.23, 1.44, -1.47, 2.19], ["c", -0.15, 0.45, -0.18, 0.63, -0.21, 1.35], ["l", 0, 0.66], ["l", 0.39, -0.18], ["c", 1.83, -0.9, 3.45, -1.95, 4.47, -2.91], ["c", 0.93, -0.9, 1.53, -1.83, 1.74, -2.82], ["c", 0.06, -0.33, 0.06, -0.87, 0.03, -1.32], ["z"], ["m", -0.27, 4.86], ["c", -0.03, -0.21, -0.06, -0.36, -0.06, -0.36], ["c", 0, -0.03, -0.12, 0.09, -0.24, 0.24], ["c", -0.39, 0.48, -0.99, 1.08, -2.16, 2.19], ["c", -1.47, 1.38, -1.92, 1.83, -2.46, 2.49], ["c", -0.66, 0.87, -1.08, 1.74, -1.29, 2.58], ["c", -0.09, 0.42, -0.15, 0.87, -0.15, 1.44], ["l", 0, 0.54], ["l", 0.48, -0.33], ["c", 1.5, -1.02, 2.58, -1.89, 3.51, -2.82], ["c", 1.47, -1.47, 2.25, -2.85, 2.4, -4.26], ["c", 0.03, -0.39, 0.03, -1.17, -0.03, -1.71], ["z"], ["m", -0.66, 7.68], ["c", 0.03, -0.15, 0.03, -0.6, 0.03, -0.99], ["l", 0, -0.72], ["l", -0.27, 0.33], ["l", -1.74, 1.98], ["c", -1.77, 1.92, -2.43, 2.76, -2.97, 3.9], ["c", -0.51, 1.02, -0.72, 1.77, -0.75, 2.91], ["c", 0, 0.63, 0, 0.63, 0.06, 0.6], ["c", 0.03, -0.03, 0.3, -0.27, 0.63, -0.54], ["c", 0.66, -0.6, 1.86, -1.8, 2.31, -2.31], ["c", 1.65, -1.89, 2.52, -3.54, 2.7, -5.16], ["z"]], w: 8.485, h: 32.932 },
      "clefs.C": { d: [["M", 0.06, -14.94], ["l", 0.09, -0.06], ["l", 1.92, 0], ["l", 1.92, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 14.85], ["l", 0, 14.82], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -1.92, 0], ["l", -1.92, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -14.82], ["l", 0, -14.85], ["z"], ["m", 5.37, 0], ["c", 0.09, -0.06, 0.09, -0.06, 0.57, -0.06], ["c", 0.45, 0, 0.45, 0, 0.54, 0.06], ["l", 0.06, 0.09], ["l", 0, 7.14], ["l", 0, 7.11], ["l", 0.09, -0.06], ["c", 0.18, -0.18, 0.72, -0.84, 0.96, -1.2], ["c", 0.3, -0.45, 0.66, -1.17, 0.84, -1.65], ["c", 0.36, -0.9, 0.57, -1.83, 0.6, -2.79], ["c", 0.03, -0.48, 0.03, -0.54, 0.09, -0.63], ["c", 0.12, -0.18, 0.36, -0.21, 0.54, -0.12], ["c", 0.18, 0.09, 0.21, 0.15, 0.24, 0.66], ["c", 0.06, 0.87, 0.21, 1.56, 0.57, 2.22], ["c", 0.51, 1.02, 1.26, 1.68, 2.22, 1.92], ["c", 0.21, 0.06, 0.33, 0.06, 0.78, 0.06], ["c", 0.45, 0, 0.57, 0, 0.84, -0.06], ["c", 0.45, -0.12, 0.81, -0.33, 1.08, -0.6], ["c", 0.57, -0.57, 0.87, -1.41, 0.99, -2.88], ["c", 0.06, -0.54, 0.06, -3, 0, -3.57], ["c", -0.21, -2.58, -0.84, -3.87, -2.16, -4.5], ["c", -0.48, -0.21, -1.17, -0.36, -1.77, -0.36], ["c", -0.69, 0, -1.29, 0.27, -1.5, 0.72], ["c", -0.06, 0.15, -0.06, 0.21, -0.06, 0.42], ["c", 0, 0.24, 0, 0.3, 0.06, 0.45], ["c", 0.12, 0.24, 0.24, 0.39, 0.63, 0.66], ["c", 0.42, 0.3, 0.57, 0.48, 0.69, 0.72], ["c", 0.06, 0.15, 0.06, 0.21, 0.06, 0.48], ["c", 0, 0.39, -0.03, 0.63, -0.21, 0.96], ["c", -0.3, 0.6, -0.87, 1.08, -1.5, 1.26], ["c", -0.27, 0.06, -0.87, 0.06, -1.14, 0], ["c", -0.78, -0.24, -1.44, -0.87, -1.65, -1.68], ["c", -0.12, -0.42, -0.09, -1.17, 0.09, -1.71], ["c", 0.51, -1.65, 1.98, -2.82, 3.81, -3.09], ["c", 0.84, -0.09, 2.46, 0.03, 3.51, 0.27], ["c", 2.22, 0.57, 3.69, 1.8, 4.44, 3.75], ["c", 0.36, 0.93, 0.57, 2.13, 0.57, 3.36], ["c", 0, 1.44, -0.48, 2.73, -1.38, 3.81], ["c", -1.26, 1.5, -3.27, 2.43, -5.28, 2.43], ["c", -0.48, 0, -0.51, 0, -0.75, -0.09], ["c", -0.15, -0.03, -0.48, -0.21, -0.78, -0.36], ["c", -0.69, -0.36, -0.87, -0.42, -1.26, -0.42], ["c", -0.27, 0, -0.3, 0, -0.51, 0.09], ["c", -0.57, 0.3, -0.81, 0.9, -0.81, 2.1], ["c", 0, 1.23, 0.24, 1.83, 0.81, 2.13], ["c", 0.21, 0.09, 0.24, 0.09, 0.51, 0.09], ["c", 0.39, 0, 0.57, -0.06, 1.26, -0.42], ["c", 0.3, -0.15, 0.63, -0.33, 0.78, -0.36], ["c", 0.24, -0.09, 0.27, -0.09, 0.75, -0.09], ["c", 2.01, 0, 4.02, 0.93, 5.28, 2.4], ["c", 0.9, 1.11, 1.38, 2.4, 1.38, 3.84], ["c", 0, 1.5, -0.3, 2.88, -0.84, 3.96], ["c", -0.78, 1.59, -2.19, 2.64, -4.17, 3.15], ["c", -1.05, 0.24, -2.67, 0.36, -3.51, 0.27], ["c", -1.83, -0.27, -3.3, -1.44, -3.81, -3.09], ["c", -0.18, -0.54, -0.21, -1.29, -0.09, -1.74], ["c", 0.15, -0.6, 0.63, -1.2, 1.23, -1.47], ["c", 0.36, -0.18, 0.57, -0.21, 0.99, -0.21], ["c", 0.42, 0, 0.63, 0.03, 1.02, 0.21], ["c", 0.42, 0.21, 0.84, 0.63, 1.05, 1.05], ["c", 0.18, 0.36, 0.21, 0.6, 0.21, 0.96], ["c", 0, 0.3, 0, 0.36, -0.06, 0.51], ["c", -0.12, 0.24, -0.27, 0.42, -0.69, 0.72], ["c", -0.57, 0.42, -0.69, 0.63, -0.69, 1.08], ["c", 0, 0.24, 0, 0.3, 0.06, 0.45], ["c", 0.12, 0.21, 0.3, 0.39, 0.57, 0.54], ["c", 0.42, 0.18, 0.87, 0.21, 1.53, 0.15], ["c", 1.08, -0.15, 1.8, -0.57, 2.34, -1.32], ["c", 0.54, -0.75, 0.84, -1.83, 0.99, -3.51], ["c", 0.06, -0.57, 0.06, -3.03, 0, -3.57], ["c", -0.12, -1.47, -0.42, -2.31, -0.99, -2.88], ["c", -0.27, -0.27, -0.63, -0.48, -1.08, -0.6], ["c", -0.27, -0.06, -0.39, -0.06, -0.84, -0.06], ["c", -0.45, 0, -0.57, 0, -0.78, 0.06], ["c", -1.14, 0.27, -2.01, 1.17, -2.46, 2.49], ["c", -0.21, 0.57, -0.3, 0.99, -0.33, 1.65], ["c", -0.03, 0.51, -0.06, 0.57, -0.24, 0.66], ["c", -0.12, 0.06, -0.27, 0.06, -0.39, 0], ["c", -0.21, -0.09, -0.21, -0.15, -0.24, -0.75], ["c", -0.09, -1.92, -0.78, -3.72, -2.01, -5.19], ["c", -0.18, -0.21, -0.36, -0.42, -0.39, -0.45], ["l", -0.09, -0.06], ["l", 0, 7.11], ["l", 0, 7.14], ["l", -0.06, 0.09], ["c", -0.09, 0.06, -0.09, 0.06, -0.54, 0.06], ["c", -0.48, 0, -0.48, 0, -0.57, -0.06], ["l", -0.06, -0.09], ["l", 0, -14.82], ["l", 0, -14.85], ["z"]], w: 20.31, h: 29.97 },
      "clefs.F": { d: [["M", 6.3, -7.8], ["c", 0.36, -0.03, 1.65, 0, 2.13, 0.03], ["c", 3.6, 0.42, 6.03, 2.1, 6.93, 4.86], ["c", 0.27, 0.84, 0.36, 1.5, 0.36, 2.58], ["c", 0, 0.9, -0.03, 1.35, -0.18, 2.16], ["c", -0.78, 3.78, -3.54, 7.08, -8.37, 9.96], ["c", -1.74, 1.05, -3.87, 2.13, -6.18, 3.12], ["c", -0.39, 0.18, -0.75, 0.33, -0.81, 0.36], ["c", -0.06, 0.03, -0.15, 0.06, -0.18, 0.06], ["c", -0.15, 0, -0.33, -0.18, -0.33, -0.33], ["c", 0, -0.15, 0.06, -0.21, 0.51, -0.48], ["c", 3, -1.77, 5.13, -3.21, 6.84, -4.74], ["c", 0.51, -0.45, 1.59, -1.5, 1.95, -1.95], ["c", 1.89, -2.19, 2.88, -4.32, 3.15, -6.78], ["c", 0.06, -0.42, 0.06, -1.77, 0, -2.19], ["c", -0.24, -2.01, -0.93, -3.63, -2.04, -4.71], ["c", -0.63, -0.63, -1.29, -1.02, -2.07, -1.2], ["c", -1.62, -0.39, -3.36, 0.15, -4.56, 1.44], ["c", -0.54, 0.6, -1.05, 1.47, -1.32, 2.22], ["l", -0.09, 0.21], ["l", 0.24, -0.12], ["c", 0.39, -0.21, 0.63, -0.24, 1.11, -0.24], ["c", 0.3, 0, 0.45, 0, 0.66, 0.06], ["c", 1.92, 0.48, 2.85, 2.55, 1.95, 4.38], ["c", -0.45, 0.99, -1.41, 1.62, -2.46, 1.71], ["c", -1.47, 0.09, -2.91, -0.87, -3.39, -2.25], ["c", -0.18, -0.57, -0.21, -1.32, -0.03, -2.28], ["c", 0.39, -2.25, 1.83, -4.2, 3.81, -5.19], ["c", 0.69, -0.36, 1.59, -0.6, 2.37, -0.69], ["z"], ["m", 11.58, 2.52], ["c", 0.84, -0.21, 1.71, 0.3, 1.89, 1.14], ["c", 0.3, 1.17, -0.72, 2.19, -1.89, 1.89], ["c", -0.99, -0.21, -1.5, -1.32, -1.02, -2.25], ["c", 0.18, -0.39, 0.6, -0.69, 1.02, -0.78], ["z"], ["m", 0, 7.5], ["c", 0.84, -0.21, 1.71, 0.3, 1.89, 1.14], ["c", 0.21, 0.87, -0.3, 1.71, -1.14, 1.89], ["c", -0.87, 0.21, -1.71, -0.3, -1.89, -1.14], ["c", -0.21, -0.84, 0.3, -1.71, 1.14, -1.89], ["z"]], w: 20.153, h: 23.142 },
      "clefs.G": { d: [["M", 9.69, -37.41], ["c", 0.09, -0.09, 0.24, -0.06, 0.36, 0], ["c", 0.12, 0.09, 0.57, 0.6, 0.96, 1.11], ["c", 1.77, 2.34, 3.21, 5.85, 3.57, 8.73], ["c", 0.21, 1.56, 0.03, 3.27, -0.45, 4.86], ["c", -0.69, 2.31, -1.92, 4.47, -4.23, 7.44], ["c", -0.3, 0.39, -0.57, 0.72, -0.6, 0.75], ["c", -0.03, 0.06, 0, 0.15, 0.18, 0.78], ["c", 0.54, 1.68, 1.38, 4.44, 1.68, 5.49], ["l", 0.09, 0.42], ["l", 0.39, 0], ["c", 1.47, 0.09, 2.76, 0.51, 3.96, 1.29], ["c", 1.83, 1.23, 3.06, 3.21, 3.39, 5.52], ["c", 0.09, 0.45, 0.12, 1.29, 0.06, 1.74], ["c", -0.09, 1.02, -0.33, 1.83, -0.75, 2.73], ["c", -0.84, 1.71, -2.28, 3.06, -4.02, 3.72], ["l", -0.33, 0.12], ["l", 0.03, 1.26], ["c", 0, 1.74, -0.06, 3.63, -0.21, 4.62], ["c", -0.45, 3.06, -2.19, 5.49, -4.47, 6.21], ["c", -0.57, 0.18, -0.9, 0.21, -1.59, 0.21], ["c", -0.69, 0, -1.02, -0.03, -1.65, -0.21], ["c", -1.14, -0.27, -2.13, -0.84, -2.94, -1.65], ["c", -0.99, -0.99, -1.56, -2.16, -1.71, -3.54], ["c", -0.09, -0.81, 0.06, -1.53, 0.45, -2.13], ["c", 0.63, -0.99, 1.83, -1.56, 3, -1.53], ["c", 1.5, 0.09, 2.64, 1.32, 2.73, 2.94], ["c", 0.06, 1.47, -0.93, 2.7, -2.37, 2.97], ["c", -0.45, 0.06, -0.84, 0.03, -1.29, -0.09], ["l", -0.21, -0.09], ["l", 0.09, 0.12], ["c", 0.39, 0.54, 0.78, 0.93, 1.32, 1.26], ["c", 1.35, 0.87, 3.06, 1.02, 4.35, 0.36], ["c", 1.44, -0.72, 2.52, -2.28, 2.97, -4.35], ["c", 0.15, -0.66, 0.24, -1.5, 0.3, -3.03], ["c", 0.03, -0.84, 0.03, -2.94, 0, -3], ["c", -0.03, 0, -0.18, 0, -0.36, 0.03], ["c", -0.66, 0.12, -0.99, 0.12, -1.83, 0.12], ["c", -1.05, 0, -1.71, -0.06, -2.61, -0.3], ["c", -4.02, -0.99, -7.11, -4.35, -7.8, -8.46], ["c", -0.12, -0.66, -0.12, -0.99, -0.12, -1.83], ["c", 0, -0.84, 0, -1.14, 0.15, -1.92], ["c", 0.36, -2.28, 1.41, -4.62, 3.3, -7.29], ["l", 2.79, -3.6], ["c", 0.54, -0.66, 0.96, -1.2, 0.96, -1.23], ["c", 0, -0.03, -0.09, -0.33, -0.18, -0.69], ["c", -0.96, -3.21, -1.41, -5.28, -1.59, -7.68], ["c", -0.12, -1.38, -0.15, -3.09, -0.06, -3.96], ["c", 0.33, -2.67, 1.38, -5.07, 3.12, -7.08], ["c", 0.36, -0.42, 0.99, -1.05, 1.17, -1.14], ["z"], ["m", 2.01, 4.71], ["c", -0.15, -0.3, -0.3, -0.54, -0.3, -0.54], ["c", -0.03, 0, -0.18, 0.09, -0.3, 0.21], ["c", -2.4, 1.74, -3.87, 4.2, -4.26, 7.11], ["c", -0.06, 0.54, -0.06, 1.41, -0.03, 1.89], ["c", 0.09, 1.29, 0.48, 3.12, 1.08, 5.22], ["c", 0.15, 0.42, 0.24, 0.78, 0.24, 0.81], ["c", 0, 0.03, 0.84, -1.11, 1.23, -1.68], ["c", 1.89, -2.73, 2.88, -5.07, 3.15, -7.53], ["c", 0.09, -0.57, 0.12, -1.74, 0.06, -2.37], ["c", -0.09, -1.23, -0.27, -1.92, -0.87, -3.12], ["z"], ["m", -2.94, 20.7], ["c", -0.21, -0.72, -0.39, -1.32, -0.42, -1.32], ["c", 0, 0, -1.2, 1.47, -1.86, 2.37], ["c", -2.79, 3.63, -4.02, 6.3, -4.35, 9.3], ["c", -0.03, 0.21, -0.03, 0.69, -0.03, 1.08], ["c", 0, 0.69, 0, 0.75, 0.06, 1.11], ["c", 0.12, 0.54, 0.27, 0.99, 0.51, 1.47], ["c", 0.69, 1.38, 1.83, 2.55, 3.42, 3.42], ["c", 0.96, 0.54, 2.07, 0.9, 3.21, 1.08], ["c", 0.78, 0.12, 2.04, 0.12, 2.94, -0.03], ["c", 0.51, -0.06, 0.45, -0.03, 0.42, -0.3], ["c", -0.24, -3.33, -0.72, -6.33, -1.62, -10.08], ["c", -0.09, -0.39, -0.18, -0.75, -0.18, -0.78], ["c", -0.03, -0.03, -0.42, 0, -0.81, 0.09], ["c", -0.9, 0.18, -1.65, 0.57, -2.22, 1.14], ["c", -0.72, 0.72, -1.08, 1.65, -1.05, 2.64], ["c", 0.06, 0.96, 0.48, 1.83, 1.23, 2.58], ["c", 0.36, 0.36, 0.72, 0.63, 1.17, 0.9], ["c", 0.33, 0.18, 0.36, 0.21, 0.42, 0.33], ["c", 0.18, 0.42, -0.18, 0.9, -0.6, 0.87], ["c", -0.18, -0.03, -0.84, -0.36, -1.26, -0.63], ["c", -0.78, -0.51, -1.38, -1.11, -1.86, -1.83], ["c", -1.77, -2.7, -0.99, -6.42, 1.71, -8.19], ["c", 0.3, -0.21, 0.81, -0.48, 1.17, -0.63], ["c", 0.3, -0.09, 1.02, -0.3, 1.14, -0.3], ["c", 0.06, 0, 0.09, 0, 0.09, -0.03], ["c", 0.03, -0.03, -0.51, -1.92, -1.23, -4.26], ["z"], ["m", 3.78, 7.41], ["c", -0.18, -0.03, -0.36, -0.06, -0.39, -0.06], ["c", -0.03, 0, 0, 0.21, 0.18, 1.02], ["c", 0.75, 3.18, 1.26, 6.3, 1.5, 9.09], ["c", 0.06, 0.72, 0, 0.69, 0.51, 0.42], ["c", 0.78, -0.36, 1.44, -0.96, 1.98, -1.77], ["c", 1.08, -1.62, 1.2, -3.69, 0.3, -5.55], ["c", -0.81, -1.62, -2.31, -2.79, -4.08, -3.15], ["z"]], w: 19.051, h: 57.057 },
      "clefs.perc": { d: [["M", 5.07, -7.44], ["l", 0.09, -0.06], ["l", 1.53, 0], ["l", 1.53, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 7.35], ["l", 0, 7.32], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -1.53, 0], ["l", -1.53, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -7.32], ["l", 0, -7.35], ["z"], ["m", 6.63, 0], ["l", 0.09, -0.06], ["l", 1.53, 0], ["l", 1.53, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 7.35], ["l", 0, 7.32], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -1.53, 0], ["l", -1.53, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -7.32], ["l", 0, -7.35], ["z"]], w: 21, h: 14.97 },
      "tab.big": { d: [["M", 20.16, -21.66], ["c", 0.24, -0.09, 0.66, 0.09, 0.78, 0.36], ["c", 0.09, 0.21, 0.09, 0.24, -0.18, 0.54], ["c", -0.78, 0.81, -1.86, 1.44, -2.94, 1.71], ["c", -0.87, 0.24, -1.71, 0.24, -2.55, 0.03], ["l", -0.06, -0.03], ["l", -0.18, 0.99], ["c", -0.33, 1.98, -0.75, 4.26, -0.96, 5.04], ["c", -0.42, 1.65, -1.26, 3.18, -2.28, 4.14], ["c", -0.57, 0.57, -1.17, 0.9, -1.86, 1.08], ["c", -0.18, 0.06, -0.33, 0.06, -0.66, 0.06], ["c", -0.54, 0, -0.78, -0.03, -1.23, -0.27], ["c", -0.39, -0.18, -0.66, -0.39, -1.38, -0.99], ["c", -0.3, -0.24, -0.66, -0.51, -0.75, -0.57], ["c", -0.21, -0.15, -0.27, -0.24, -0.24, -0.45], ["c", 0.06, -0.27, 0.36, -0.6, 0.6, -0.66], ["c", 0.18, -0.03, 0.33, 0.06, 0.9, 0.57], ["c", 0.48, 0.42, 0.72, 0.57, 0.93, 0.69], ["c", 0.66, 0.33, 1.38, 0.21, 1.95, -0.36], ["c", 0.63, -0.6, 1.05, -1.62, 1.23, -3], ["c", 0.03, -0.18, 0.09, -0.66, 0.09, -1.11], ["c", 0.09, -1.56, 0.33, -3.81, 0.57, -5.49], ["c", 0.06, -0.33, 0.09, -0.63, 0.09, -0.63], ["c", -0.03, -0.03, -0.81, -0.12, -1.02, -0.12], ["c", -0.57, 0, -1.32, 0.12, -1.8, 0.33], ["c", -0.87, 0.3, -1.35, 0.78, -1.5, 1.41], ["c", -0.18, 0.63, 0.09, 1.26, 0.66, 1.65], ["c", 0.12, 0.06, 0.15, 0.12, 0.18, 0.24], ["c", 0.09, 0.27, 0.06, 0.57, -0.09, 0.75], ["c", -0.03, 0.06, -0.12, 0.09, -0.27, 0.15], ["c", -0.72, 0.21, -1.44, 0.15, -2.1, -0.18], ["c", -0.54, -0.27, -0.96, -0.66, -1.2, -1.14], ["c", -0.39, -0.75, -0.33, -1.74, 0.15, -2.52], ["c", 0.27, -0.42, 0.84, -0.93, 1.41, -1.23], ["c", 1.17, -0.57, 2.88, -0.9, 4.8, -0.9], ["c", 0.69, 0, 0.78, 0, 1.08, 0.06], ["c", 0.45, 0.09, 1.11, 0.3, 2.07, 0.6], ["c", 1.47, 0.48, 1.83, 0.57, 2.55, 0.54], ["c", 1.02, -0.06, 2.04, -0.45, 2.94, -1.11], ["c", 0.12, -0.09, 0.24, -0.18, 0.27, -0.18], ["z"], ["m", -5.88, 13.05], ["c", 0.21, -0.03, 0.81, 0, 1.08, 0.06], ["c", 0.48, 0.12, 0.9, 0.42, 0.99, 0.69], ["c", 0.03, 0.09, 0.03, 0.15, 0, 0.27], ["c", 0, 0.09, -0.03, 0.57, -0.06, 1.08], ["c", -0.09, 2.19, -0.24, 5.76, -0.39, 8.28], ["c", -0.06, 1.53, -0.06, 1.77, 0.03, 2.01], ["c", 0.09, 0.18, 0.15, 0.24, 0.3, 0.3], ["c", 0.24, 0.12, 0.54, 0.06, 1.23, -0.27], ["c", 0.57, -0.27, 0.66, -0.3, 0.75, -0.24], ["c", 0.09, 0.06, 0.18, 0.3, 0.18, 0.45], ["c", 0, 0.33, -0.15, 0.51, -0.45, 0.63], ["c", -0.12, 0.03, -0.39, 0.15, -0.6, 0.27], ["c", -1.17, 0.6, -1.38, 0.69, -1.8, 0.72], ["c", -0.45, 0.03, -0.78, -0.09, -1.08, -0.39], ["c", -0.39, -0.42, -0.66, -1.2, -1.02, -3.12], ["c", -0.24, -1.23, -0.36, -2.07, -0.54, -3.75], ["l", 0, -0.18], ["l", -0.36, 0.45], ["c", -0.6, 0.75, -1.32, 1.59, -1.95, 2.25], ["c", -0.15, 0.18, -0.27, 0.3, -0.27, 0.33], ["c", 0, 0, 0.06, 0.09, 0.15, 0.18], ["c", 0.24, 0.33, 0.6, 0.57, 1.05, 0.69], ["c", 0.18, 0.06, 0.3, 0.06, 0.69, 0.06], ["l", 0.48, 0.03], ["l", 0.06, 0.12], ["c", 0.15, 0.27, 0.03, 0.72, -0.21, 0.9], ["c", -0.18, 0.12, -0.93, 0.27, -1.41, 0.27], ["c", -0.84, 0, -1.59, -0.3, -1.98, -0.84], ["l", -0.12, -0.15], ["l", -0.45, 0.42], ["c", -0.99, 0.87, -1.53, 1.32, -2.16, 1.74], ["c", -0.78, 0.51, -1.5, 0.84, -2.1, 0.93], ["c", -0.69, 0.12, -1.2, 0.03, -1.95, -0.42], ["c", -0.21, -0.12, -0.51, -0.27, -0.66, -0.36], ["c", -0.24, -0.12, -0.3, -0.18, -0.33, -0.24], ["c", -0.12, -0.27, 0.15, -0.78, 0.45, -0.93], ["c", 0.24, -0.12, 0.33, -0.09, 0.9, 0.18], ["c", 0.6, 0.3, 0.84, 0.39, 1.2, 0.36], ["c", 0.87, -0.09, 1.77, -0.69, 3.24, -2.31], ["c", 2.67, -2.85, 4.59, -5.94, 5.7, -9.15], ["c", 0.15, -0.45, 0.24, -0.63, 0.42, -0.81], ["c", 0.21, -0.24, 0.6, -0.45, 0.99, -0.51], ["z"], ["m", -3.99, 16.05], ["c", 0.18, 0, 0.69, -0.03, 1.17, 0], ["c", 3.27, 0.03, 5.37, 0.75, 6, 2.07], ["c", 0.45, 0.99, 0.12, 2.4, -0.81, 3.42], ["c", -0.24, 0.27, -0.57, 0.57, -0.84, 0.75], ["c", -0.09, 0.06, -0.18, 0.09, -0.18, 0.12], ["c", 0, 0, 0.18, 0.03, 0.42, 0.09], ["c", 1.23, 0.3, 2.01, 0.81, 2.37, 1.59], ["c", 0.27, 0.54, 0.3, 1.32, 0.09, 2.1], ["c", -0.12, 0.36, -0.45, 1.05, -0.69, 1.35], ["c", -0.87, 1.17, -2.1, 1.92, -3.54, 2.25], ["c", -0.36, 0.06, -0.48, 0.06, -0.96, 0.06], ["c", -0.45, 0, -0.66, 0, -0.84, -0.03], ["c", -0.84, -0.18, -1.47, -0.51, -2.07, -1.11], ["c", -0.33, -0.33, -0.45, -0.51, -0.45, -0.63], ["c", 0, -0.06, 0.03, -0.15, 0.06, -0.24], ["c", 0.18, -0.33, 0.69, -0.6, 0.93, -0.48], ["c", 0.03, 0.03, 0.15, 0.12, 0.27, 0.24], ["c", 0.39, 0.42, 0.99, 0.57, 1.62, 0.45], ["c", 1.05, -0.21, 1.98, -1.02, 2.31, -2.01], ["c", 0.48, -1.53, -0.48, -2.55, -2.58, -2.67], ["c", -0.21, 0, -0.36, -0.03, -0.42, -0.06], ["c", -0.15, -0.09, -0.21, -0.51, -0.06, -0.78], ["c", 0.12, -0.27, 0.24, -0.33, 0.6, -0.36], ["c", 0.57, -0.06, 1.11, -0.42, 1.5, -0.99], ["c", 0.48, -0.72, 0.54, -1.59, 0.18, -2.31], ["c", -0.12, -0.21, -0.45, -0.54, -0.69, -0.69], ["c", -0.33, -0.21, -0.93, -0.45, -1.35, -0.51], ["l", -0.12, -0.03], ["l", -0.06, 0.48], ["c", -0.54, 2.94, -1.14, 6.24, -1.29, 6.75], ["c", -0.33, 1.35, -0.93, 2.61, -1.65, 3.6], ["c", -0.3, 0.36, -0.81, 0.9, -1.14, 1.14], ["c", -0.3, 0.24, -0.84, 0.48, -1.14, 0.57], ["c", -0.33, 0.09, -0.96, 0.09, -1.26, 0.03], ["c", -0.45, -0.12, -0.87, -0.39, -1.53, -0.96], ["c", -0.24, -0.15, -0.51, -0.39, -0.63, -0.48], ["c", -0.3, -0.21, -0.33, -0.33, -0.21, -0.63], ["c", 0.12, -0.18, 0.27, -0.36, 0.42, -0.45], ["c", 0.27, -0.12, 0.36, -0.09, 0.87, 0.33], ["c", 0.78, 0.6, 1.08, 0.75, 1.65, 0.72], ["c", 0.45, -0.03, 0.81, -0.21, 1.17, -0.54], ["c", 0.87, -0.9, 1.38, -2.85, 1.38, -5.37], ["c", 0, -0.6, 0.03, -1.11, 0.12, -2.04], ["c", 0.06, -0.69, 0.24, -2.01, 0.33, -2.58], ["c", 0.06, -0.24, 0.06, -0.42, 0.06, -0.42], ["c", 0, 0, -0.12, 0.03, -0.21, 0.09], ["c", -1.44, 0.57, -2.16, 1.65, -1.74, 2.55], ["c", 0.09, 0.15, 0.18, 0.24, 0.27, 0.33], ["c", 0.24, 0.21, 0.3, 0.27, 0.33, 0.39], ["c", 0.06, 0.24, 0, 0.63, -0.15, 0.78], ["c", -0.09, 0.12, -0.54, 0.21, -0.96, 0.24], ["c", -1.02, 0.03, -2.01, -0.48, -2.43, -1.32], ["c", -0.21, -0.45, -0.27, -0.9, -0.15, -1.44], ["c", 0.06, -0.27, 0.21, -0.66, 0.39, -0.93], ["c", 0.87, -1.29, 3, -2.22, 5.64, -2.43], ["z"]], w: 19.643, h: 43.325 },
      "tab.tiny": { d: [["M", 16.02, -17.25], ["c", 0.12, -0.09, 0.15, -0.09, 0.27, -0.09], ["c", 0.21, 0.03, 0.51, 0.3, 0.51, 0.45], ["c", 0, 0.06, -0.12, 0.18, -0.3, 0.36], ["c", -1.11, 1.08, -2.55, 1.59, -3.84, 1.41], ["c", -0.15, -0.03, -0.33, -0.06, -0.39, -0.09], ["c", -0.06, -0.03, -0.09, -0.03, -0.12, -0.03], ["c", 0, 0, -0.06, 0.42, -0.15, 0.93], ["c", -0.33, 2.01, -0.66, 3.69, -0.84, 4.26], ["c", -0.42, 1.41, -1.23, 2.67, -2.16, 3.33], ["c", -0.27, 0.18, -0.75, 0.42, -0.99, 0.48], ["c", -0.3, 0.09, -0.72, 0.09, -1.02, 0.06], ["c", -0.45, -0.09, -0.84, -0.33, -1.53, -0.9], ["c", -0.21, -0.18, -0.51, -0.39, -0.63, -0.48], ["c", -0.27, -0.21, -0.3, -0.24, -0.3, -0.36], ["c", 0, -0.12, 0.09, -0.36, 0.18, -0.45], ["c", 0.09, -0.09, 0.27, -0.18, 0.36, -0.18], ["c", 0.12, 0, 0.3, 0.12, 0.66, 0.45], ["c", 0.57, 0.51, 0.87, 0.69, 1.23, 0.72], ["c", 0.93, 0.06, 1.68, -0.78, 1.98, -2.37], ["c", 0.09, -0.39, 0.15, -0.75, 0.18, -1.53], ["c", 0.06, -0.99, 0.24, -2.79, 0.42, -4.05], ["c", 0.03, -0.3, 0.06, -0.57, 0.06, -0.6], ["c", 0, -0.06, -0.03, -0.09, -0.15, -0.12], ["c", -0.9, -0.18, -2.13, 0.06, -2.76, 0.57], ["c", -0.36, 0.3, -0.51, 0.6, -0.51, 1.02], ["c", 0, 0.45, 0.15, 0.75, 0.48, 0.99], ["c", 0.06, 0.06, 0.15, 0.18, 0.18, 0.24], ["c", 0.12, 0.24, 0.03, 0.63, -0.15, 0.69], ["c", -0.24, 0.12, -0.6, 0.15, -0.9, 0.15], ["c", -0.36, -0.03, -0.57, -0.09, -0.87, -0.24], ["c", -0.78, -0.36, -1.23, -1.11, -1.2, -1.92], ["c", 0.12, -1.53, 1.74, -2.49, 4.62, -2.7], ["c", 1.2, -0.09, 1.47, -0.03, 3.33, 0.57], ["c", 0.9, 0.3, 1.14, 0.36, 1.56, 0.39], ["c", 0.45, 0, 0.93, -0.06, 1.38, -0.21], ["c", 0.51, -0.18, 0.81, -0.33, 1.41, -0.75], ["z"], ["m", -4.68, 10.38], ["c", 0.39, -0.06, 0.84, 0, 1.2, 0.15], ["c", 0.24, 0.12, 0.36, 0.21, 0.45, 0.36], ["l", 0.09, 0.09], ["l", -0.06, 1.41], ["c", -0.09, 2.19, -0.18, 3.96, -0.27, 5.49], ["c", -0.03, 0.78, -0.06, 1.59, -0.06, 1.86], ["c", 0, 0.42, 0, 0.48, 0.06, 0.57], ["c", 0.06, 0.18, 0.18, 0.24, 0.36, 0.27], ["c", 0.18, 0, 0.39, -0.06, 0.84, -0.27], ["c", 0.45, -0.21, 0.54, -0.24, 0.63, -0.18], ["c", 0.12, 0.12, 0.15, 0.54, 0.03, 0.69], ["c", -0.03, 0.03, -0.15, 0.12, -0.27, 0.18], ["c", -0.15, 0.03, -0.3, 0.12, -0.36, 0.15], ["c", -0.87, 0.45, -1.02, 0.51, -1.26, 0.57], ["c", -0.33, 0.09, -0.6, 0.06, -0.84, -0.06], ["c", -0.42, -0.18, -0.63, -0.6, -0.87, -1.44], ["c", -0.3, -1.23, -0.57, -2.97, -0.66, -4.08], ["c", 0, -0.18, -0.03, -0.3, -0.03, -0.33], ["l", -0.06, 0.06], ["c", -0.18, 0.27, -1.11, 1.38, -1.68, 2.01], ["l", -0.33, 0.33], ["l", 0.06, 0.09], ["c", 0.06, 0.15, 0.27, 0.33, 0.48, 0.42], ["c", 0.27, 0.18, 0.51, 0.24, 0.96, 0.27], ["l", 0.39, 0], ["l", 0.03, 0.12], ["c", 0.12, 0.21, 0.03, 0.57, -0.15, 0.69], ["c", -0.03, 0.03, -0.21, 0.09, -0.36, 0.15], ["c", -0.27, 0.06, -0.39, 0.06, -0.75, 0.06], ["c", -0.48, 0, -0.75, -0.03, -1.08, -0.21], ["c", -0.21, -0.12, -0.51, -0.36, -0.57, -0.48], ["l", -0.03, -0.09], ["l", -0.39, 0.36], ["c", -1.47, 1.35, -2.49, 1.98, -3.42, 2.13], ["c", -0.54, 0.09, -0.96, -0.03, -1.62, -0.39], ["c", -0.21, -0.15, -0.45, -0.27, -0.54, -0.3], ["c", -0.18, -0.09, -0.21, -0.21, -0.12, -0.45], ["c", 0.06, -0.27, 0.33, -0.48, 0.54, -0.48], ["c", 0.03, 0, 0.27, 0.09, 0.48, 0.21], ["c", 0.48, 0.24, 0.69, 0.27, 0.99, 0.27], ["c", 0.6, -0.06, 1.17, -0.42, 2.1, -1.35], ["c", 2.22, -2.22, 4.02, -4.98, 4.95, -7.59], ["c", 0.21, -0.57, 0.3, -0.78, 0.48, -0.93], ["c", 0.15, -0.15, 0.42, -0.27, 0.66, -0.33], ["z"], ["m", -3.06, 12.84], ["c", 0.27, -0.03, 1.68, 0, 2.01, 0.03], ["c", 1.92, 0.18, 3.15, 0.69, 3.63, 1.5], ["c", 0.18, 0.33, 0.24, 0.51, 0.21, 0.93], ["c", 0, 0.45, -0.06, 0.72, -0.24, 1.11], ["c", -0.24, 0.51, -0.69, 1.02, -1.17, 1.35], ["c", -0.21, 0.15, -0.21, 0.15, -0.12, 0.18], ["c", 0.72, 0.15, 1.11, 0.3, 1.5, 0.57], ["c", 0.39, 0.24, 0.63, 0.57, 0.75, 0.96], ["c", 0.09, 0.3, 0.09, 0.96, 0, 1.29], ["c", -0.15, 0.57, -0.39, 1.05, -0.78, 1.5], ["c", -0.66, 0.75, -1.62, 1.32, -2.61, 1.53], ["c", -0.27, 0.06, -0.42, 0.06, -0.84, 0.06], ["c", -0.48, 0, -0.57, 0, -0.81, -0.06], ["c", -0.6, -0.18, -1.05, -0.42, -1.47, -0.81], ["c", -0.36, -0.39, -0.42, -0.51, -0.3, -0.75], ["c", 0.12, -0.21, 0.39, -0.39, 0.6, -0.39], ["c", 0.09, 0, 0.15, 0.03, 0.33, 0.18], ["c", 0.12, 0.12, 0.27, 0.24, 0.36, 0.27], ["c", 0.96, 0.48, 2.46, -0.33, 2.82, -1.5], ["c", 0.24, -0.81, -0.03, -1.44, -0.69, -1.77], ["c", -0.39, -0.21, -1.02, -0.33, -1.53, -0.33], ["c", -0.18, 0, -0.21, 0, -0.27, -0.09], ["c", -0.06, -0.09, -0.06, -0.3, -0.03, -0.48], ["c", 0.06, -0.18, 0.18, -0.36, 0.33, -0.36], ["c", 0.39, -0.06, 0.51, -0.09, 0.72, -0.18], ["c", 0.69, -0.36, 1.11, -1.23, 0.99, -2.01], ["c", -0.09, -0.51, -0.42, -0.9, -0.93, -1.17], ["c", -0.24, -0.12, -0.6, -0.27, -0.87, -0.3], ["c", -0.09, -0.03, -0.09, -0.03, -0.12, 0.12], ["c", 0, 0.09, -0.21, 1.11, -0.42, 2.25], ["c", -0.66, 3.75, -0.72, 3.99, -1.26, 5.07], ["c", -0.9, 1.89, -2.25, 2.85, -3.48, 2.61], ["c", -0.39, -0.09, -0.69, -0.27, -1.38, -0.84], ["c", -0.63, -0.51, -0.63, -0.48, -0.63, -0.6], ["c", 0, -0.18, 0.18, -0.48, 0.39, -0.57], ["c", 0.21, -0.12, 0.3, -0.09, 0.81, 0.33], ["c", 0.15, 0.15, 0.39, 0.3, 0.54, 0.36], ["c", 0.18, 0.12, 0.27, 0.12, 0.48, 0.15], ["c", 0.99, 0.06, 1.71, -0.78, 2.04, -2.46], ["c", 0.12, -0.66, 0.18, -1.14, 0.21, -2.22], ["c", 0.03, -1.23, 0.12, -2.25, 0.36, -3.63], ["c", 0.03, -0.24, 0.06, -0.45, 0.06, -0.48], ["c", -0.06, -0.03, -0.66, 0.27, -0.9, 0.42], ["c", -0.06, 0.06, -0.21, 0.18, -0.33, 0.3], ["c", -0.57, 0.57, -0.6, 1.35, -0.06, 1.74], ["c", 0.18, 0.12, 0.24, 0.24, 0.21, 0.51], ["c", -0.03, 0.3, -0.15, 0.42, -0.57, 0.48], ["c", -1.11, 0.24, -2.22, -0.42, -2.43, -1.38], ["c", -0.09, -0.45, 0.03, -1.02, 0.3, -1.47], ["c", 0.18, -0.24, 0.6, -0.63, 0.9, -0.84], ["c", 0.9, -0.6, 2.28, -1.02, 3.69, -1.11], ["z"]], w: 15.709, h: 34.656 },
      "timesig.common": { d: [["M", 6.66, -7.83], ["c", 0.72, -0.06, 1.41, -0.03, 1.98, 0.09], ["c", 1.2, 0.27, 2.34, 0.96, 3.09, 1.92], ["c", 0.63, 0.81, 1.08, 1.86, 1.14, 2.73], ["c", 0.06, 1.02, -0.51, 1.92, -1.44, 2.22], ["c", -0.24, 0.09, -0.3, 0.09, -0.63, 0.09], ["c", -0.33, 0, -0.42, 0, -0.63, -0.06], ["c", -0.66, -0.24, -1.14, -0.63, -1.41, -1.2], ["c", -0.15, -0.3, -0.21, -0.51, -0.24, -0.9], ["c", -0.06, -1.08, 0.57, -2.04, 1.56, -2.37], ["c", 0.18, -0.06, 0.27, -0.06, 0.63, -0.06], ["l", 0.45, 0], ["c", 0.06, 0.03, 0.09, 0.03, 0.09, 0], ["c", 0, 0, -0.09, -0.12, -0.24, -0.27], ["c", -1.02, -1.11, -2.55, -1.68, -4.08, -1.5], ["c", -1.29, 0.15, -2.04, 0.69, -2.4, 1.74], ["c", -0.36, 0.93, -0.42, 1.89, -0.42, 5.37], ["c", 0, 2.97, 0.06, 3.96, 0.24, 4.77], ["c", 0.24, 1.08, 0.63, 1.68, 1.41, 2.07], ["c", 0.81, 0.39, 2.16, 0.45, 3.18, 0.09], ["c", 1.29, -0.45, 2.37, -1.53, 3.03, -2.97], ["c", 0.15, -0.33, 0.33, -0.87, 0.39, -1.17], ["c", 0.09, -0.24, 0.15, -0.36, 0.3, -0.39], ["c", 0.21, -0.03, 0.42, 0.15, 0.39, 0.36], ["c", -0.06, 0.39, -0.42, 1.38, -0.69, 1.89], ["c", -0.96, 1.8, -2.49, 2.94, -4.23, 3.18], ["c", -0.99, 0.12, -2.58, -0.06, -3.63, -0.45], ["c", -0.96, -0.36, -1.71, -0.84, -2.4, -1.5], ["c", -1.11, -1.11, -1.8, -2.61, -2.04, -4.56], ["c", -0.06, -0.6, -0.06, -2.01, 0, -2.61], ["c", 0.24, -1.95, 0.9, -3.45, 2.01, -4.56], ["c", 0.69, -0.66, 1.44, -1.11, 2.37, -1.47], ["c", 0.63, -0.24, 1.47, -0.42, 2.22, -0.48], ["z"]], w: 13.038, h: 15.689 },
      "timesig.cut": { d: [["M", 6.24, -10.44], ["c", 0.09, -0.06, 0.09, -0.06, 0.48, -0.06], ["c", 0.36, 0, 0.36, 0, 0.45, 0.06], ["l", 0.06, 0.09], ["l", 0, 1.23], ["l", 0, 1.26], ["l", 0.27, 0], ["c", 1.26, 0, 2.49, 0.45, 3.48, 1.29], ["c", 1.05, 0.87, 1.8, 2.28, 1.89, 3.48], ["c", 0.06, 1.02, -0.51, 1.92, -1.44, 2.22], ["c", -0.24, 0.09, -0.3, 0.09, -0.63, 0.09], ["c", -0.33, 0, -0.42, 0, -0.63, -0.06], ["c", -0.66, -0.24, -1.14, -0.63, -1.41, -1.2], ["c", -0.15, -0.3, -0.21, -0.51, -0.24, -0.9], ["c", -0.06, -1.08, 0.57, -2.04, 1.56, -2.37], ["c", 0.18, -0.06, 0.27, -0.06, 0.63, -0.06], ["l", 0.45, 0], ["c", 0.06, 0.03, 0.09, 0.03, 0.09, 0], ["c", 0, -0.03, -0.45, -0.51, -0.66, -0.69], ["c", -0.87, -0.69, -1.83, -1.05, -2.94, -1.11], ["l", -0.42, 0], ["l", 0, 7.17], ["l", 0, 7.14], ["l", 0.42, 0], ["c", 0.69, -0.03, 1.23, -0.18, 1.86, -0.51], ["c", 1.05, -0.51, 1.89, -1.47, 2.46, -2.7], ["c", 0.15, -0.33, 0.33, -0.87, 0.39, -1.17], ["c", 0.09, -0.24, 0.15, -0.36, 0.3, -0.39], ["c", 0.21, -0.03, 0.42, 0.15, 0.39, 0.36], ["c", -0.03, 0.24, -0.21, 0.78, -0.39, 1.2], ["c", -0.96, 2.37, -2.94, 3.9, -5.13, 3.9], ["l", -0.3, 0], ["l", 0, 1.26], ["l", 0, 1.23], ["l", -0.06, 0.09], ["c", -0.09, 0.06, -0.09, 0.06, -0.45, 0.06], ["c", -0.39, 0, -0.39, 0, -0.48, -0.06], ["l", -0.06, -0.09], ["l", 0, -1.29], ["l", 0, -1.29], ["l", -0.21, -0.03], ["c", -1.23, -0.21, -2.31, -0.63, -3.21, -1.29], ["c", -0.15, -0.09, -0.45, -0.36, -0.66, -0.57], ["c", -1.11, -1.11, -1.8, -2.61, -2.04, -4.56], ["c", -0.06, -0.6, -0.06, -2.01, 0, -2.61], ["c", 0.24, -1.95, 0.93, -3.45, 2.04, -4.59], ["c", 0.42, -0.39, 0.78, -0.66, 1.26, -0.93], ["c", 0.75, -0.45, 1.65, -0.75, 2.61, -0.9], ["l", 0.21, -0.03], ["l", 0, -1.29], ["l", 0, -1.29], ["z"], ["m", -0.06, 10.44], ["c", 0, -5.58, 0, -6.99, -0.03, -6.99], ["c", -0.15, 0, -0.63, 0.27, -0.87, 0.45], ["c", -0.45, 0.36, -0.75, 0.93, -0.93, 1.77], ["c", -0.18, 0.81, -0.24, 1.8, -0.24, 4.74], ["c", 0, 2.97, 0.06, 3.96, 0.24, 4.77], ["c", 0.24, 1.08, 0.66, 1.68, 1.41, 2.07], ["c", 0.12, 0.06, 0.3, 0.12, 0.33, 0.15], ["l", 0.09, 0], ["l", 0, -6.96], ["z"]], w: 13.038, h: 20.97 },
      "timesig.imperfectum": { d: [["M", 13, -5], ["a", 8, 8, 0, 1, 0, 0, 10]], w: 13.038, h: 20.97 },
      "timesig.imperfectum2": { d: [["M", 13, -5], ["a", 8, 8, 0, 1, 0, 0, 10]], w: 13.038, h: 20.97 },
      "timesig.perfectum": { d: [["M", 13, -5], ["a", 8, 8, 0, 1, 0, 0, 10]], w: 13.038, h: 20.97 },
      "timesig.perfectum2": { d: [["M", 13, -5], ["a", 8, 8, 0, 1, 0, 0, 10]], w: 13.038, h: 20.97 },
      "f": { d: [["M", 9.93, -14.28], ["c", 1.53, -0.18, 2.88, 0.45, 3.12, 1.5], ["c", 0.12, 0.51, 0, 1.32, -0.27, 1.86], ["c", -0.15, 0.3, -0.42, 0.57, -0.63, 0.69], ["c", -0.69, 0.36, -1.56, 0.03, -1.83, -0.69], ["c", -0.09, -0.24, -0.09, -0.69, 0, -0.87], ["c", 0.06, -0.12, 0.21, -0.24, 0.45, -0.42], ["c", 0.42, -0.24, 0.57, -0.45, 0.6, -0.72], ["c", 0.03, -0.33, -0.09, -0.39, -0.63, -0.42], ["c", -0.3, 0, -0.45, 0, -0.6, 0.03], ["c", -0.81, 0.21, -1.35, 0.93, -1.74, 2.46], ["c", -0.06, 0.27, -0.48, 2.25, -0.48, 2.31], ["c", 0, 0.03, 0.39, 0.03, 0.9, 0.03], ["c", 0.72, 0, 0.9, 0, 0.99, 0.06], ["c", 0.42, 0.15, 0.45, 0.72, 0.03, 0.9], ["c", -0.12, 0.06, -0.24, 0.06, -1.17, 0.06], ["l", -1.05, 0], ["l", -0.78, 2.55], ["c", -0.45, 1.41, -0.87, 2.79, -0.96, 3.06], ["c", -0.87, 2.37, -2.37, 4.74, -3.78, 5.91], ["c", -1.05, 0.9, -2.04, 1.23, -3.09, 1.08], ["c", -1.11, -0.18, -1.89, -0.78, -2.04, -1.59], ["c", -0.12, -0.66, 0.15, -1.71, 0.54, -2.19], ["c", 0.69, -0.75, 1.86, -0.54, 2.22, 0.39], ["c", 0.06, 0.15, 0.09, 0.27, 0.09, 0.48], ["c", 0, 0.24, -0.03, 0.27, -0.12, 0.42], ["c", -0.03, 0.09, -0.15, 0.18, -0.27, 0.27], ["c", -0.09, 0.06, -0.27, 0.21, -0.36, 0.27], ["c", -0.24, 0.18, -0.36, 0.36, -0.39, 0.6], ["c", -0.03, 0.33, 0.09, 0.39, 0.63, 0.42], ["c", 0.42, 0, 0.63, -0.03, 0.9, -0.15], ["c", 0.6, -0.3, 0.96, -0.96, 1.38, -2.64], ["c", 0.09, -0.42, 0.63, -2.55, 1.17, -4.77], ["l", 1.02, -4.08], ["c", 0, -0.03, -0.36, -0.03, -0.81, -0.03], ["c", -0.72, 0, -0.81, 0, -0.93, -0.06], ["c", -0.42, -0.18, -0.39, -0.75, 0.03, -0.9], ["c", 0.09, -0.06, 0.27, -0.06, 1.05, -0.06], ["l", 0.96, 0], ["l", 0, -0.09], ["c", 0.06, -0.18, 0.3, -0.72, 0.51, -1.17], ["c", 1.2, -2.46, 3.3, -4.23, 5.34, -4.5], ["z"]], w: 16.155, h: 19.445 },
      "m": { d: [["M", 2.79, -8.91], ["c", 0.09, 0, 0.3, -0.03, 0.45, -0.03], ["c", 0.24, 0.03, 0.3, 0.03, 0.45, 0.12], ["c", 0.36, 0.15, 0.63, 0.54, 0.75, 1.02], ["l", 0.03, 0.21], ["l", 0.33, -0.3], ["c", 0.69, -0.69, 1.38, -1.02, 2.07, -1.02], ["c", 0.27, 0, 0.33, 0, 0.48, 0.06], ["c", 0.21, 0.09, 0.48, 0.36, 0.63, 0.6], ["c", 0.03, 0.09, 0.12, 0.27, 0.18, 0.42], ["c", 0.03, 0.15, 0.09, 0.27, 0.12, 0.27], ["c", 0, 0, 0.09, -0.09, 0.18, -0.21], ["c", 0.33, -0.39, 0.87, -0.81, 1.29, -0.99], ["c", 0.78, -0.33, 1.47, -0.21, 2.01, 0.33], ["c", 0.3, 0.33, 0.48, 0.69, 0.6, 1.14], ["c", 0.09, 0.42, 0.06, 0.54, -0.54, 3.06], ["c", -0.33, 1.29, -0.57, 2.4, -0.57, 2.43], ["c", 0, 0.12, 0.09, 0.21, 0.21, 0.21], ["c", 0.24, 0, 0.75, -0.3, 1.2, -0.72], ["c", 0.45, -0.39, 0.6, -0.45, 0.78, -0.27], ["c", 0.18, 0.18, 0.09, 0.36, -0.45, 0.87], ["c", -1.05, 0.96, -1.83, 1.47, -2.58, 1.71], ["c", -0.93, 0.33, -1.53, 0.21, -1.8, -0.33], ["c", -0.06, -0.15, -0.06, -0.21, -0.06, -0.45], ["c", 0, -0.24, 0.03, -0.48, 0.6, -2.82], ["c", 0.42, -1.71, 0.6, -2.64, 0.63, -2.79], ["c", 0.03, -0.57, -0.3, -0.75, -0.84, -0.48], ["c", -0.24, 0.12, -0.54, 0.39, -0.66, 0.63], ["c", -0.03, 0.09, -0.42, 1.38, -0.9, 3], ["c", -0.9, 3.15, -0.84, 3, -1.14, 3.15], ["l", -0.15, 0.09], ["l", -0.78, 0], ["c", -0.6, 0, -0.78, 0, -0.84, -0.06], ["c", -0.09, -0.03, -0.18, -0.18, -0.18, -0.27], ["c", 0, -0.03, 0.36, -1.38, 0.84, -2.97], ["c", 0.57, -2.04, 0.81, -2.97, 0.84, -3.12], ["c", 0.03, -0.54, -0.3, -0.72, -0.84, -0.45], ["c", -0.24, 0.12, -0.57, 0.42, -0.66, 0.63], ["c", -0.06, 0.09, -0.51, 1.44, -1.05, 2.97], ["c", -0.51, 1.56, -0.99, 2.85, -0.99, 2.91], ["c", -0.06, 0.12, -0.21, 0.24, -0.36, 0.3], ["c", -0.12, 0.06, -0.21, 0.06, -0.9, 0.06], ["c", -0.6, 0, -0.78, 0, -0.84, -0.06], ["c", -0.09, -0.03, -0.18, -0.18, -0.18, -0.27], ["c", 0, -0.03, 0.45, -1.38, 0.99, -2.97], ["c", 1.05, -3.18, 1.05, -3.18, 0.93, -3.45], ["c", -0.12, -0.27, -0.39, -0.3, -0.72, -0.15], ["c", -0.54, 0.27, -1.14, 1.17, -1.56, 2.4], ["c", -0.06, 0.15, -0.15, 0.3, -0.18, 0.36], ["c", -0.21, 0.21, -0.57, 0.27, -0.72, 0.09], ["c", -0.09, -0.09, -0.06, -0.21, 0.06, -0.63], ["c", 0.48, -1.26, 1.26, -2.46, 2.01, -3.21], ["c", 0.57, -0.54, 1.2, -0.87, 1.83, -1.02], ["z"]], w: 14.687, h: 9.126 },
      "p": { d: [["M", 1.92, -8.7], ["c", 0.27, -0.09, 0.81, -0.06, 1.11, 0.03], ["c", 0.54, 0.18, 0.93, 0.51, 1.17, 0.99], ["c", 0.09, 0.15, 0.15, 0.33, 0.18, 0.36], ["l", 0, 0.12], ["l", 0.3, -0.27], ["c", 0.66, -0.6, 1.35, -1.02, 2.13, -1.2], ["c", 0.21, -0.06, 0.33, -0.06, 0.78, -0.06], ["c", 0.45, 0, 0.51, 0, 0.84, 0.09], ["c", 1.29, 0.33, 2.07, 1.32, 2.25, 2.79], ["c", 0.09, 0.81, -0.09, 2.01, -0.45, 2.79], ["c", -0.54, 1.26, -1.86, 2.55, -3.18, 3.03], ["c", -0.45, 0.18, -0.81, 0.24, -1.29, 0.24], ["c", -0.69, -0.03, -1.35, -0.18, -1.86, -0.45], ["c", -0.3, -0.15, -0.51, -0.18, -0.69, -0.09], ["c", -0.09, 0.03, -0.18, 0.09, -0.18, 0.12], ["c", -0.09, 0.12, -1.05, 2.94, -1.05, 3.06], ["c", 0, 0.24, 0.18, 0.48, 0.51, 0.63], ["c", 0.18, 0.06, 0.54, 0.15, 0.75, 0.15], ["c", 0.21, 0, 0.36, 0.06, 0.42, 0.18], ["c", 0.12, 0.18, 0.06, 0.42, -0.12, 0.54], ["c", -0.09, 0.03, -0.15, 0.03, -0.78, 0], ["c", -1.98, -0.15, -3.81, -0.15, -5.79, 0], ["c", -0.63, 0.03, -0.69, 0.03, -0.78, 0], ["c", -0.24, -0.15, -0.24, -0.57, 0.03, -0.66], ["c", 0.06, -0.03, 0.48, -0.09, 0.99, -0.12], ["c", 0.87, -0.06, 1.11, -0.09, 1.35, -0.21], ["c", 0.18, -0.06, 0.33, -0.18, 0.39, -0.3], ["c", 0.06, -0.12, 3.24, -9.42, 3.27, -9.6], ["c", 0.06, -0.33, 0.03, -0.57, -0.15, -0.69], ["c", -0.09, -0.06, -0.12, -0.06, -0.3, -0.06], ["c", -0.69, 0.06, -1.53, 1.02, -2.28, 2.61], ["c", -0.09, 0.21, -0.21, 0.45, -0.27, 0.51], ["c", -0.09, 0.12, -0.33, 0.24, -0.48, 0.24], ["c", -0.18, 0, -0.36, -0.15, -0.36, -0.3], ["c", 0, -0.24, 0.78, -1.83, 1.26, -2.55], ["c", 0.72, -1.11, 1.47, -1.74, 2.28, -1.92], ["z"], ["m", 5.37, 1.47], ["c", -0.27, -0.12, -0.75, -0.03, -1.14, 0.21], ["c", -0.75, 0.48, -1.47, 1.68, -1.89, 3.15], ["c", -0.45, 1.47, -0.42, 2.34, 0, 2.7], ["c", 0.45, 0.39, 1.26, 0.21, 1.83, -0.36], ["c", 0.51, -0.51, 0.99, -1.68, 1.38, -3.27], ["c", 0.3, -1.17, 0.33, -1.74, 0.15, -2.13], ["c", -0.09, -0.15, -0.15, -0.21, -0.33, -0.3], ["z"]], w: 14.689, h: 13.127 },
      "r": { d: [["M", 6.33, -9.12], ["c", 0.27, -0.03, 0.93, 0, 1.2, 0.06], ["c", 0.84, 0.21, 1.23, 0.81, 1.02, 1.53], ["c", -0.24, 0.75, -0.9, 1.17, -1.56, 0.96], ["c", -0.33, -0.09, -0.51, -0.3, -0.66, -0.75], ["c", -0.03, -0.12, -0.09, -0.24, -0.12, -0.3], ["c", -0.09, -0.15, -0.3, -0.24, -0.48, -0.24], ["c", -0.57, 0, -1.38, 0.54, -1.65, 1.08], ["c", -0.06, 0.15, -0.33, 1.17, -0.9, 3.27], ["c", -0.57, 2.31, -0.81, 3.12, -0.87, 3.21], ["c", -0.03, 0.06, -0.12, 0.15, -0.18, 0.21], ["l", -0.12, 0.06], ["l", -0.81, 0.03], ["c", -0.69, 0, -0.81, 0, -0.9, -0.03], ["c", -0.09, -0.06, -0.18, -0.21, -0.18, -0.3], ["c", 0, -0.06, 0.39, -1.62, 0.9, -3.51], ["c", 0.84, -3.24, 0.87, -3.45, 0.87, -3.72], ["c", 0, -0.21, 0, -0.27, -0.03, -0.36], ["c", -0.12, -0.15, -0.21, -0.24, -0.42, -0.24], ["c", -0.24, 0, -0.45, 0.15, -0.78, 0.42], ["c", -0.33, 0.36, -0.45, 0.54, -0.72, 1.14], ["c", -0.03, 0.12, -0.21, 0.24, -0.36, 0.27], ["c", -0.12, 0, -0.15, 0, -0.24, -0.06], ["c", -0.18, -0.12, -0.18, -0.21, -0.06, -0.54], ["c", 0.21, -0.57, 0.42, -0.93, 0.78, -1.32], ["c", 0.54, -0.51, 1.2, -0.81, 1.95, -0.87], ["c", 0.81, -0.03, 1.53, 0.3, 1.92, 0.87], ["l", 0.12, 0.18], ["l", 0.09, -0.09], ["c", 0.57, -0.45, 1.41, -0.84, 2.19, -0.96], ["z"]], w: 9.41, h: 9.132 },
      "s": { d: [["M", 4.47, -8.73], ["c", 0.09, 0, 0.36, -0.03, 0.57, -0.03], ["c", 0.75, 0.03, 1.29, 0.24, 1.71, 0.63], ["c", 0.51, 0.54, 0.66, 1.26, 0.36, 1.83], ["c", -0.24, 0.42, -0.63, 0.57, -1.11, 0.42], ["c", -0.33, -0.09, -0.6, -0.36, -0.6, -0.57], ["c", 0, -0.03, 0.06, -0.21, 0.15, -0.39], ["c", 0.12, -0.21, 0.15, -0.33, 0.18, -0.48], ["c", 0, -0.24, -0.06, -0.48, -0.15, -0.6], ["c", -0.15, -0.21, -0.42, -0.24, -0.75, -0.15], ["c", -0.27, 0.06, -0.48, 0.18, -0.69, 0.36], ["c", -0.39, 0.39, -0.51, 0.96, -0.33, 1.38], ["c", 0.09, 0.21, 0.42, 0.51, 0.78, 0.72], ["c", 1.11, 0.69, 1.59, 1.11, 1.89, 1.68], ["c", 0.21, 0.39, 0.24, 0.78, 0.15, 1.29], ["c", -0.18, 1.2, -1.17, 2.16, -2.52, 2.52], ["c", -1.02, 0.24, -1.95, 0.12, -2.7, -0.42], ["c", -0.72, -0.51, -0.99, -1.47, -0.6, -2.19], ["c", 0.24, -0.48, 0.72, -0.63, 1.17, -0.42], ["c", 0.33, 0.18, 0.54, 0.45, 0.57, 0.81], ["c", 0, 0.21, -0.03, 0.3, -0.33, 0.51], ["c", -0.33, 0.24, -0.39, 0.42, -0.27, 0.69], ["c", 0.06, 0.15, 0.21, 0.27, 0.45, 0.33], ["c", 0.3, 0.09, 0.87, 0.09, 1.2, 0], ["c", 0.75, -0.21, 1.23, -0.72, 1.29, -1.35], ["c", 0.03, -0.42, -0.15, -0.81, -0.54, -1.2], ["c", -0.24, -0.24, -0.48, -0.42, -1.41, -1.02], ["c", -0.69, -0.42, -1.05, -0.93, -1.05, -1.47], ["c", 0, -0.39, 0.12, -0.87, 0.3, -1.23], ["c", 0.27, -0.57, 0.78, -1.05, 1.38, -1.35], ["c", 0.24, -0.12, 0.63, -0.27, 0.9, -0.3], ["z"]], w: 6.632, h: 8.758 },
      "z": { d: [["M", 2.64, -7.95], ["c", 0.36, -0.09, 0.81, -0.03, 1.71, 0.27], ["c", 0.78, 0.21, 0.96, 0.27, 1.74, 0.3], ["c", 0.87, 0.06, 1.02, 0.03, 1.38, -0.21], ["c", 0.21, -0.15, 0.33, -0.15, 0.48, -0.06], ["c", 0.15, 0.09, 0.21, 0.3, 0.15, 0.45], ["c", -0.03, 0.06, -1.26, 1.26, -2.76, 2.67], ["l", -2.73, 2.55], ["l", 0.54, 0.03], ["c", 0.54, 0.03, 0.72, 0.03, 2.01, 0.15], ["c", 0.36, 0.03, 0.9, 0.06, 1.2, 0.09], ["c", 0.66, 0, 0.81, -0.03, 1.02, -0.24], ["c", 0.3, -0.3, 0.39, -0.72, 0.27, -1.23], ["c", -0.06, -0.27, -0.06, -0.27, -0.03, -0.39], ["c", 0.15, -0.3, 0.54, -0.27, 0.69, 0.03], ["c", 0.15, 0.33, 0.27, 1.02, 0.27, 1.5], ["c", 0, 1.47, -1.11, 2.7, -2.52, 2.79], ["c", -0.57, 0.03, -1.02, -0.09, -2.01, -0.51], ["c", -1.02, -0.42, -1.23, -0.48, -2.13, -0.54], ["c", -0.81, -0.06, -0.96, -0.03, -1.26, 0.18], ["c", -0.12, 0.06, -0.24, 0.12, -0.27, 0.12], ["c", -0.27, 0, -0.45, -0.3, -0.36, -0.51], ["c", 0.03, -0.06, 1.32, -1.32, 2.91, -2.79], ["l", 2.88, -2.73], ["c", -0.03, 0, -0.21, 0.03, -0.42, 0.06], ["c", -0.21, 0.03, -0.78, 0.09, -1.23, 0.12], ["c", -1.11, 0.12, -1.23, 0.15, -1.95, 0.27], ["c", -0.72, 0.15, -1.17, 0.18, -1.29, 0.09], ["c", -0.27, -0.18, -0.21, -0.75, 0.12, -1.26], ["c", 0.39, -0.6, 0.93, -1.02, 1.59, -1.2], ["z"]], w: 8.573, h: 8.743 },
      "+": { d: [["M", 3.48, -9.3], ["c", 0.18, -0.09, 0.36, -0.09, 0.54, 0], ["c", 0.18, 0.09, 0.24, 0.15, 0.33, 0.3], ["l", 0.06, 0.15], ["l", 0, 1.29], ["l", 0, 1.29], ["l", 1.29, 0], ["c", 1.23, 0, 1.29, 0, 1.41, 0.06], ["c", 0.06, 0.03, 0.15, 0.09, 0.18, 0.12], ["c", 0.12, 0.09, 0.21, 0.33, 0.21, 0.48], ["c", 0, 0.15, -0.09, 0.39, -0.21, 0.48], ["c", -0.03, 0.03, -0.12, 0.09, -0.18, 0.12], ["c", -0.12, 0.06, -0.18, 0.06, -1.41, 0.06], ["l", -1.29, 0], ["l", 0, 1.29], ["c", 0, 1.23, 0, 1.29, -0.06, 1.41], ["c", -0.09, 0.18, -0.15, 0.24, -0.3, 0.33], ["c", -0.21, 0.09, -0.39, 0.09, -0.57, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.06, -0.12, -0.06, -0.18, -0.06, -1.41], ["l", 0, -1.29], ["l", -1.29, 0], ["c", -1.23, 0, -1.29, 0, -1.41, -0.06], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.09, -0.18, -0.09, -0.36, 0, -0.54], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["l", 0.15, -0.06], ["l", 1.26, 0], ["l", 1.29, 0], ["l", 0, -1.29], ["c", 0, -1.23, 0, -1.29, 0.06, -1.41], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["z"]], w: 7.507, h: 7.515 },
      ",": { d: [["M", 1.32, -3.36], ["c", 0.57, -0.15, 1.17, 0.03, 1.59, 0.45], ["c", 0.45, 0.45, 0.6, 0.96, 0.51, 1.89], ["c", -0.09, 1.23, -0.42, 2.46, -0.99, 3.93], ["c", -0.3, 0.72, -0.72, 1.62, -0.78, 1.68], ["c", -0.18, 0.21, -0.51, 0.18, -0.66, -0.06], ["c", -0.03, -0.06, -0.06, -0.15, -0.06, -0.18], ["c", 0, -0.06, 0.12, -0.33, 0.24, -0.63], ["c", 0.84, -1.8, 1.02, -2.61, 0.69, -3.24], ["c", -0.12, -0.24, -0.27, -0.36, -0.75, -0.6], ["c", -0.36, -0.15, -0.42, -0.21, -0.6, -0.39], ["c", -0.69, -0.69, -0.69, -1.71, 0, -2.4], ["c", 0.21, -0.21, 0.51, -0.39, 0.81, -0.45], ["z"]], w: 3.452, h: 8.143 },
      "-": { d: [["M", 0.18, -5.34], ["c", 0.09, -0.06, 0.15, -0.06, 2.31, -0.06], ["c", 2.46, 0, 2.37, 0, 2.46, 0.21], ["c", 0.12, 0.21, 0.03, 0.42, -0.15, 0.54], ["c", -0.09, 0.06, -0.15, 0.06, -2.28, 0.06], ["c", -2.16, 0, -2.22, 0, -2.31, -0.06], ["c", -0.27, -0.15, -0.27, -0.54, -0.03, -0.69], ["z"]], w: 5.001, h: 0.81 },
      ".": { d: [["M", 1.32, -3.36], ["c", 1.05, -0.27, 2.1, 0.57, 2.1, 1.65], ["c", 0, 1.08, -1.05, 1.92, -2.1, 1.65], ["c", -0.9, -0.21, -1.5, -1.14, -1.26, -2.04], ["c", 0.12, -0.63, 0.63, -1.11, 1.26, -1.26], ["z"]], w: 3.413, h: 3.402 },
      "scripts.wedge": { d: [["M", -3.66, -7.44], ["c", 0.06, -0.09, 0, -0.09, 0.81, 0.03], ["c", 1.86, 0.3, 3.84, 0.3, 5.73, 0], ["c", 0.78, -0.12, 0.72, -0.12, 0.78, -0.03], ["c", 0.15, 0.15, 0.12, 0.24, -0.24, 0.6], ["c", -0.93, 0.93, -1.98, 2.76, -2.67, 4.62], ["c", -0.3, 0.78, -0.51, 1.71, -0.51, 2.13], ["c", 0, 0.15, 0, 0.18, -0.06, 0.27], ["c", -0.12, 0.09, -0.24, 0.09, -0.36, 0], ["c", -0.06, -0.09, -0.06, -0.12, -0.06, -0.27], ["c", 0, -0.42, -0.21, -1.35, -0.51, -2.13], ["c", -0.69, -1.86, -1.74, -3.69, -2.67, -4.62], ["c", -0.36, -0.36, -0.39, -0.45, -0.24, -0.6], ["z"]], w: 7.49, h: 7.752 },
      "scripts.thumb": { d: [["M", -0.54, -3.69], ["c", 0.15, -0.03, 0.36, -0.06, 0.51, -0.06], ["c", 1.44, 0, 2.58, 1.11, 2.94, 2.85], ["c", 0.09, 0.48, 0.09, 1.32, 0, 1.8], ["c", -0.27, 1.41, -1.08, 2.43, -2.16, 2.73], ["l", -0.18, 0.06], ["l", 0, 0.12], ["c", 0.03, 0.06, 0.06, 0.45, 0.09, 0.87], ["c", 0.03, 0.57, 0.03, 0.78, 0, 0.84], ["c", -0.09, 0.27, -0.39, 0.48, -0.66, 0.48], ["c", -0.27, 0, -0.57, -0.21, -0.66, -0.48], ["c", -0.03, -0.06, -0.03, -0.27, 0, -0.84], ["c", 0.03, -0.42, 0.06, -0.81, 0.09, -0.87], ["l", 0, -0.12], ["l", -0.18, -0.06], ["c", -1.08, -0.3, -1.89, -1.32, -2.16, -2.73], ["c", -0.09, -0.48, -0.09, -1.32, 0, -1.8], ["c", 0.15, -0.84, 0.51, -1.53, 1.02, -2.04], ["c", 0.39, -0.39, 0.84, -0.63, 1.35, -0.75], ["z"], ["m", 1.05, 0.9], ["c", -0.15, -0.09, -0.21, -0.09, -0.45, -0.12], ["c", -0.15, 0, -0.3, 0.03, -0.39, 0.03], ["c", -0.57, 0.18, -0.9, 0.72, -1.08, 1.74], ["c", -0.06, 0.48, -0.06, 1.8, 0, 2.28], ["c", 0.15, 0.9, 0.42, 1.44, 0.9, 1.65], ["c", 0.18, 0.09, 0.21, 0.09, 0.51, 0.09], ["c", 0.3, 0, 0.33, 0, 0.51, -0.09], ["c", 0.48, -0.21, 0.75, -0.75, 0.9, -1.65], ["c", 0.03, -0.27, 0.03, -0.54, 0.03, -1.14], ["c", 0, -0.6, 0, -0.87, -0.03, -1.14], ["c", -0.15, -0.9, -0.45, -1.44, -0.9, -1.65], ["z"]], w: 5.955, h: 9.75 },
      "scripts.open": { d: [["M", -0.54, -3.69], ["c", 0.15, -0.03, 0.36, -0.06, 0.51, -0.06], ["c", 1.44, 0, 2.58, 1.11, 2.94, 2.85], ["c", 0.09, 0.48, 0.09, 1.32, 0, 1.8], ["c", -0.33, 1.74, -1.47, 2.85, -2.91, 2.85], ["c", -1.44, 0, -2.58, -1.11, -2.91, -2.85], ["c", -0.09, -0.48, -0.09, -1.32, 0, -1.8], ["c", 0.15, -0.84, 0.51, -1.53, 1.02, -2.04], ["c", 0.39, -0.39, 0.84, -0.63, 1.35, -0.75], ["z"], ["m", 1.11, 0.9], ["c", -0.21, -0.09, -0.27, -0.09, -0.51, -0.12], ["c", -0.3, 0, -0.42, 0.03, -0.66, 0.15], ["c", -0.24, 0.12, -0.51, 0.39, -0.66, 0.63], ["c", -0.54, 0.93, -0.63, 2.64, -0.21, 3.81], ["c", 0.21, 0.54, 0.51, 0.9, 0.93, 1.11], ["c", 0.21, 0.09, 0.24, 0.09, 0.54, 0.09], ["c", 0.3, 0, 0.33, 0, 0.54, -0.09], ["c", 0.42, -0.21, 0.72, -0.57, 0.93, -1.11], ["c", 0.36, -0.99, 0.36, -2.37, 0, -3.36], ["c", -0.21, -0.54, -0.51, -0.9, -0.9, -1.11], ["z"]], w: 5.955, h: 7.5 },
      "scripts.longphrase": { d: [["M", 1.47, -15.09], ["c", 0.36, -0.09, 0.66, -0.18, 0.69, -0.18], ["c", 0.06, 0, 0.06, 0.54, 0.06, 11.25], ["l", 0, 11.25], ["l", -0.63, 0.15], ["c", -0.66, 0.18, -1.44, 0.39, -1.5, 0.39], ["c", -0.03, 0, -0.03, -3.39, -0.03, -11.25], ["l", 0, -11.25], ["l", 0.36, -0.09], ["c", 0.21, -0.06, 0.66, -0.18, 1.05, -0.27], ["z"]], w: 2.16, h: 23.04 },
      "scripts.mediumphrase": { d: [["M", 1.47, -7.59], ["c", 0.36, -0.09, 0.66, -0.18, 0.69, -0.18], ["c", 0.06, 0, 0.06, 0.39, 0.06, 7.5], ["l", 0, 7.5], ["l", -0.63, 0.15], ["c", -0.66, 0.18, -1.44, 0.39, -1.5, 0.39], ["c", -0.03, 0, -0.03, -2.28, -0.03, -7.5], ["l", 0, -7.5], ["l", 0.36, -0.09], ["c", 0.21, -0.06, 0.66, -0.18, 1.05, -0.27], ["z"]], w: 2.16, h: 15.54 },
      "scripts.shortphrase": { d: [["M", 1.47, -7.59], ["c", 0.36, -0.09, 0.66, -0.18, 0.69, -0.18], ["c", 0.06, 0, 0.06, 0.21, 0.06, 3.75], ["l", 0, 3.75], ["l", -0.42, 0.09], ["c", -0.57, 0.18, -1.65, 0.45, -1.71, 0.45], ["c", -0.03, 0, -0.03, -0.72, -0.03, -3.75], ["l", 0, -3.75], ["l", 0.36, -0.09], ["c", 0.21, -0.06, 0.66, -0.18, 1.05, -0.27], ["z"]], w: 2.16, h: 8.04 },
      "scripts.snap": { d: [["M", 4.5, -3.39], ["c", 0.36, -0.03, 0.96, -0.03, 1.35, 0], ["c", 1.56, 0.15, 3.15, 0.9, 4.2, 2.01], ["c", 0.24, 0.27, 0.33, 0.42, 0.33, 0.6], ["c", 0, 0.27, 0.03, 0.24, -2.46, 2.22], ["c", -1.29, 1.02, -2.4, 1.86, -2.49, 1.92], ["c", -0.18, 0.09, -0.3, 0.09, -0.48, 0], ["c", -0.09, -0.06, -1.2, -0.9, -2.49, -1.92], ["c", -2.49, -1.98, -2.46, -1.95, -2.46, -2.22], ["c", 0, -0.18, 0.09, -0.33, 0.33, -0.6], ["c", 1.05, -1.08, 2.64, -1.86, 4.17, -2.01], ["z"], ["m", 1.29, 1.17], ["c", -1.47, -0.15, -2.97, 0.3, -4.14, 1.2], ["l", -0.18, 0.15], ["l", 0.06, 0.09], ["c", 0.15, 0.12, 3.63, 2.85, 3.66, 2.85], ["c", 0.03, 0, 3.51, -2.73, 3.66, -2.85], ["l", 0.06, -0.09], ["l", -0.18, -0.15], ["c", -0.84, -0.66, -1.89, -1.08, -2.94, -1.2], ["z"]], w: 10.38, h: 6.84 }
    };
    glyphs["noteheads.slash.whole"] = { d: [["M", 5, -5], ["l", 1, 1], ["l", -5, 5], ["l", -1, -1], ["z"], ["m", 4, 6], ["l", -5, -5], ["l", 2, -2], ["l", 5, 5], ["z"], ["m", 0, -2], ["l", 1, 1], ["l", -5, 5], ["l", -1, -1], ["z"], ["m", -4, 6], ["l", -5, -5], ["l", 2, -2], ["l", 5, 5], ["z"]], w: 10.81, h: 15.63 };
    glyphs["noteheads.slash.quarter"] = { d: [["M", 9, -6], ["l", 0, 4], ["l", -9, 9], ["l", 0, -4], ["z"]], w: 9, h: 9 };
    glyphs["noteheads.harmonic.quarter"] = { d: [["M", 3.63, -4.02], ["c", 0.09, -0.06, 0.18, -0.09, 0.24, -0.03], ["c", 0.03, 0.03, 0.87, 0.93, 1.83, 2.01], ["c", 1.5, 1.65, 1.8, 1.98, 1.8, 2.04], ["c", 0, 0.06, -0.3, 0.39, -1.8, 2.04], ["c", -0.96, 1.08, -1.8, 1.98, -1.83, 2.01], ["c", -0.06, 0.06, -0.15, 0.03, -0.24, -0.03], ["c", -0.12, -0.09, -3.54, -3.84, -3.6, -3.93], ["c", -0.03, -0.03, -0.03, -0.09, -0.03, -0.15], ["c", 0.03, -0.06, 3.45, -3.84, 3.63, -3.96], ["z"]], w: 7.5, h: 8.165 };
    glyphs["noteheads.triangle.quarter"] = { d: [["M", 0, 0], ["l", 9, 0], ["l", -4.5, -9], ["z"]], w: 9, h: 9 };
    var pathClone = function(pathArray) {
      var res = [];
      for (var i = 0, ii = pathArray.length; i < ii; i++) {
        res[i] = [];
        for (var j = 0, jj = pathArray[i].length; j < jj; j++) {
          res[i][j] = pathArray[i][j];
        }
      }
      return res;
    };
    var pathScale = function(pathArray, kx, ky) {
      for (var i = 0, ii = pathArray.length; i < ii; i++) {
        var p = pathArray[i];
        var j, jj;
        for (j = 1, jj = p.length; j < jj; j++) {
          p[j] *= j % 2 ? kx : ky;
        }
      }
    };
    var Glyphs = {
      printSymbol: function(x, y, symb, paper, attrs) {
        if (!glyphs[symb])
          return null;
        var pathArray = pathClone(glyphs[symb].d);
        pathArray[0][1] += x;
        pathArray[0][2] += y;
        var path = "";
        for (var i = 0; i < pathArray.length; i++)
          path += pathArray[i].join(" ");
        attrs.path = path;
        return paper.path(attrs);
      },
      getPathForSymbol: function(x, y, symb, scalex, scaley) {
        scalex = scalex || 1;
        scaley = scaley || 1;
        if (!glyphs[symb])
          return null;
        var pathArray = pathClone(glyphs[symb].d);
        if (scalex !== 1 || scaley !== 1)
          pathScale(pathArray, scalex, scaley);
        pathArray[0][1] += x;
        pathArray[0][2] += y;
        return pathArray;
      },
      getSymbolWidth: function(symbol) {
        if (glyphs[symbol])
          return glyphs[symbol].w;
        return 0;
      },
      symbolHeightInPitches: function(symbol) {
        var height = glyphs[symbol] ? glyphs[symbol].h : 0;
        return height / spacing.STEP;
      },
      getSymbolAlign: function(symbol) {
        if (symbol.substring(0, 7) === "scripts" && symbol !== "scripts.roll") {
          return "center";
        }
        return "left";
      },
      getYCorr: function(symbol) {
        switch (symbol) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
          case "+":
            return -2;
          case "timesig.common":
          case "timesig.cut":
            return 0;
          case "flags.d32nd":
            return -1;
          case "flags.d64th":
            return -2;
          case "flags.u32nd":
            return 1;
          case "flags.u64th":
            return 3;
          case "rests.whole":
            return 1;
          case "rests.half":
            return -1;
          case "rests.8th":
            return -1;
          case "rests.quarter":
            return -1;
          case "rests.16th":
            return -1;
          case "rests.32nd":
            return -1;
          case "rests.64th":
            return -1;
          case "f":
          case "m":
          case "p":
          case "s":
          case "z":
            return -4;
          case "scripts.trill":
          case "scripts.upbow":
          case "scripts.downbow":
            return -2;
          case "scripts.ufermata":
          case "scripts.wedge":
          case "scripts.roll":
          case "scripts.shortphrase":
          case "scripts.longphrase":
            return -1;
          case "scripts.dfermata":
            return 1;
          default:
            return 0;
        }
      },
      setSymbol: function(name, path) {
        glyphs[name] = path;
      }
    };
    module.exports = Glyphs;
  }
});

// node_modules/abcjs/src/write/abc_create_clef.js
var require_abc_create_clef = __commonJS({
  "node_modules/abcjs/src/write/abc_create_clef.js"(exports, module) {
    var AbsoluteElement = require_abc_absolute_element();
    var glyphs = require_abc_glyphs();
    var RelativeElement = require_abc_relative_element();
    var createClef = function(elem, tuneNumber) {
      var clef;
      var octave = 0;
      elem.el_type = "clef";
      var abselem = new AbsoluteElement(elem, 0, 10, "staff-extra clef", tuneNumber);
      abselem.isClef = true;
      switch (elem.type) {
        case "treble":
          clef = "clefs.G";
          break;
        case "tenor":
          clef = "clefs.C";
          break;
        case "alto":
          clef = "clefs.C";
          break;
        case "bass":
          clef = "clefs.F";
          break;
        case "treble+8":
          clef = "clefs.G";
          octave = 1;
          break;
        case "tenor+8":
          clef = "clefs.C";
          octave = 1;
          break;
        case "bass+8":
          clef = "clefs.F";
          octave = 1;
          break;
        case "alto+8":
          clef = "clefs.C";
          octave = 1;
          break;
        case "treble-8":
          clef = "clefs.G";
          octave = -1;
          break;
        case "tenor-8":
          clef = "clefs.C";
          octave = -1;
          break;
        case "bass-8":
          clef = "clefs.F";
          octave = -1;
          break;
        case "alto-8":
          clef = "clefs.C";
          octave = -1;
          break;
        case "none":
          return null;
        case "perc":
          clef = "clefs.perc";
          break;
        default:
          abselem.addFixed(new RelativeElement("clef=" + elem.type, 0, 0, void 0, { type: "debug" }));
      }
      var dx = 5;
      if (clef) {
        var height = glyphs.symbolHeightInPitches(clef);
        var ofs = clefOffsets(clef);
        abselem.addRight(new RelativeElement(clef, dx, glyphs.getSymbolWidth(clef), elem.clefPos, { top: height + elem.clefPos + ofs, bottom: elem.clefPos + ofs }));
        if (octave !== 0) {
          var scale = 2 / 3;
          var adjustspacing = (glyphs.getSymbolWidth(clef) - glyphs.getSymbolWidth("8") * scale) / 2;
          var pitch = octave > 0 ? abselem.top + 3 : abselem.bottom - 1;
          var top = octave > 0 ? abselem.top + 3 : abselem.bottom - 3;
          var bottom = top - 2;
          if (elem.type === "bass-8") {
            pitch = 3;
            adjustspacing = 0;
          }
          abselem.addRight(new RelativeElement("8", dx + adjustspacing, glyphs.getSymbolWidth("8") * scale, pitch, {
            scalex: scale,
            scaley: scale,
            top,
            bottom
          }));
        }
      }
      return abselem;
    };
    function clefOffsets(clef) {
      switch (clef) {
        case "clefs.G":
          return -5;
        case "clefs.C":
          return -4;
        case "clefs.F":
          return -4;
        case "clefs.perc":
          return -2;
        default:
          return 0;
      }
    }
    module.exports = createClef;
  }
});

// node_modules/abcjs/src/write/abc_create_key_signature.js
var require_abc_create_key_signature = __commonJS({
  "node_modules/abcjs/src/write/abc_create_key_signature.js"(exports, module) {
    var AbsoluteElement = require_abc_absolute_element();
    var glyphs = require_abc_glyphs();
    var RelativeElement = require_abc_relative_element();
    var parseCommon = require_abc_common();
    var createKeySignature = function(elem, tuneNumber) {
      elem.el_type = "keySignature";
      if (!elem.accidentals || elem.accidentals.length === 0)
        return null;
      var abselem = new AbsoluteElement(elem, 0, 10, "staff-extra key-signature", tuneNumber);
      abselem.isKeySig = true;
      var dx = 0;
      parseCommon.each(elem.accidentals, function(acc) {
        var symbol;
        var fudge = 0;
        switch (acc.acc) {
          case "sharp":
            symbol = "accidentals.sharp";
            fudge = -3;
            break;
          case "natural":
            symbol = "accidentals.nat";
            break;
          case "flat":
            symbol = "accidentals.flat";
            fudge = -1.2;
            break;
          case "quartersharp":
            symbol = "accidentals.halfsharp";
            fudge = -2.5;
            break;
          case "quarterflat":
            symbol = "accidentals.halfflat";
            fudge = -1.2;
            break;
          default:
            symbol = "accidentals.flat";
        }
        abselem.addRight(new RelativeElement(symbol, dx, glyphs.getSymbolWidth(symbol), acc.verticalPos, { thickness: glyphs.symbolHeightInPitches(symbol), top: acc.verticalPos + glyphs.symbolHeightInPitches(symbol) + fudge, bottom: acc.verticalPos + fudge }));
        dx += glyphs.getSymbolWidth(symbol) + 2;
      }, this);
      return abselem;
    };
    module.exports = createKeySignature;
  }
});

// node_modules/abcjs/src/write/abc_create_note_head.js
var require_abc_create_note_head = __commonJS({
  "node_modules/abcjs/src/write/abc_create_note_head.js"(exports, module) {
    var glyphs = require_abc_glyphs();
    var RelativeElement = require_abc_relative_element();
    var createNoteHead = function(abselem, c, pitchelem, options) {
      if (!options)
        options = {};
      var dir = options.dir !== void 0 ? options.dir : null;
      var headx = options.headx !== void 0 ? options.headx : 0;
      var extrax = options.extrax !== void 0 ? options.extrax : 0;
      var flag = options.flag !== void 0 ? options.flag : null;
      var dot = options.dot !== void 0 ? options.dot : 0;
      var dotshiftx = options.dotshiftx !== void 0 ? options.dotshiftx : 0;
      var scale = options.scale !== void 0 ? options.scale : 1;
      var accidentalSlot = options.accidentalSlot !== void 0 ? options.accidentalSlot : [];
      var shouldExtendStem = options.shouldExtendStem !== void 0 ? options.shouldExtendStem : false;
      var printAccidentals = options.printAccidentals !== void 0 ? options.printAccidentals : true;
      var pitch = pitchelem.verticalPos;
      var notehead;
      var accidentalshiftx = 0;
      var newDotShiftX = 0;
      var extraLeft = 0;
      if (c === void 0)
        abselem.addFixed(new RelativeElement("pitch is undefined", 0, 0, 0, { type: "debug" }));
      else if (c === "") {
        notehead = new RelativeElement(null, 0, 0, pitch);
      } else {
        var shiftheadx = headx;
        if (pitchelem.printer_shift) {
          var adjust = pitchelem.printer_shift === "same" ? 1 : 0;
          shiftheadx = dir === "down" ? -glyphs.getSymbolWidth(c) * scale + adjust : glyphs.getSymbolWidth(c) * scale - adjust;
        }
        var opts = { scalex: scale, scaley: scale, thickness: glyphs.symbolHeightInPitches(c) * scale, name: pitchelem.name };
        notehead = new RelativeElement(c, shiftheadx, glyphs.getSymbolWidth(c) * scale, pitch, opts);
        notehead.stemDir = dir;
        if (flag) {
          var pos = pitch + (dir === "down" ? -7 : 7) * scale;
          if (shouldExtendStem) {
            if (dir === "down" && pos > 6)
              pos = 6;
            if (dir === "up" && pos < 6)
              pos = 6;
          }
          var xdelta = dir === "down" ? headx : headx + notehead.w - 0.6;
          abselem.addRight(new RelativeElement(flag, xdelta, glyphs.getSymbolWidth(flag) * scale, pos, { scalex: scale, scaley: scale }));
        }
        newDotShiftX = notehead.w + dotshiftx - 2 + 5 * dot;
        for (; dot > 0; dot--) {
          var dotadjusty = 1 - Math.abs(pitch) % 2;
          abselem.addRight(new RelativeElement("dots.dot", notehead.w + dotshiftx - 2 + 5 * dot, glyphs.getSymbolWidth("dots.dot"), pitch + dotadjusty));
        }
      }
      if (notehead)
        notehead.highestVert = pitchelem.highestVert;
      if (printAccidentals && pitchelem.accidental) {
        var symb;
        switch (pitchelem.accidental) {
          case "quartersharp":
            symb = "accidentals.halfsharp";
            break;
          case "dblsharp":
            symb = "accidentals.dblsharp";
            break;
          case "sharp":
            symb = "accidentals.sharp";
            break;
          case "quarterflat":
            symb = "accidentals.halfflat";
            break;
          case "flat":
            symb = "accidentals.flat";
            break;
          case "dblflat":
            symb = "accidentals.dblflat";
            break;
          case "natural":
            symb = "accidentals.nat";
        }
        var accSlotFound = false;
        var accPlace = extrax;
        for (var j = 0; j < accidentalSlot.length; j++) {
          if (pitch - accidentalSlot[j][0] >= 6) {
            accidentalSlot[j][0] = pitch;
            accPlace = accidentalSlot[j][1];
            accSlotFound = true;
            break;
          }
        }
        if (accSlotFound === false) {
          accPlace -= glyphs.getSymbolWidth(symb) * scale + 2;
          accidentalSlot.push([pitch, accPlace]);
          accidentalshiftx = glyphs.getSymbolWidth(symb) * scale + 2;
        }
        var h = glyphs.symbolHeightInPitches(symb);
        abselem.addExtra(new RelativeElement(symb, accPlace, glyphs.getSymbolWidth(symb), pitch, { scalex: scale, scaley: scale, top: pitch + h / 2, bottom: pitch - h / 2 }));
        extraLeft = glyphs.getSymbolWidth(symb) / 2;
      }
      return { notehead, accidentalshiftx, dotshiftx: newDotShiftX, extraLeft };
    };
    module.exports = createNoteHead;
  }
});

// node_modules/abcjs/src/write/abc_create_time_signature.js
var require_abc_create_time_signature = __commonJS({
  "node_modules/abcjs/src/write/abc_create_time_signature.js"(exports, module) {
    var AbsoluteElement = require_abc_absolute_element();
    var glyphs = require_abc_glyphs();
    var RelativeElement = require_abc_relative_element();
    var createTimeSignature = function(elem, tuneNumber) {
      elem.el_type = "timeSignature";
      var abselem = new AbsoluteElement(elem, 0, 10, "staff-extra time-signature", tuneNumber);
      if (elem.type === "specified") {
        var x = 0;
        for (var i = 0; i < elem.value.length; i++) {
          if (i !== 0) {
            abselem.addRight(new RelativeElement("+", x + 1, glyphs.getSymbolWidth("+"), 6, { thickness: glyphs.symbolHeightInPitches("+") }));
            x += glyphs.getSymbolWidth("+") + 2;
          }
          if (elem.value[i].den) {
            var numWidth = 0;
            for (var i2 = 0; i2 < elem.value[i].num.length; i2++)
              numWidth += glyphs.getSymbolWidth(elem.value[i].num.charAt(i2));
            var denWidth = 0;
            for (i2 = 0; i2 < elem.value[i].num.length; i2++)
              denWidth += glyphs.getSymbolWidth(elem.value[i].den.charAt(i2));
            var maxWidth = Math.max(numWidth, denWidth);
            abselem.addRight(new RelativeElement(elem.value[i].num, x + (maxWidth - numWidth) / 2, numWidth, 8, { thickness: glyphs.symbolHeightInPitches(elem.value[i].num.charAt(0)) }));
            abselem.addRight(new RelativeElement(elem.value[i].den, x + (maxWidth - denWidth) / 2, denWidth, 4, { thickness: glyphs.symbolHeightInPitches(elem.value[i].den.charAt(0)) }));
            x += maxWidth;
          } else {
            var thisWidth = 0;
            for (var i3 = 0; i3 < elem.value[i].num.length; i3++)
              thisWidth += glyphs.getSymbolWidth(elem.value[i].num.charAt(i3));
            abselem.addRight(new RelativeElement(elem.value[i].num, x, thisWidth, 6, { thickness: glyphs.symbolHeightInPitches(elem.value[i].num.charAt(0)) }));
            x += thisWidth;
          }
        }
      } else if (elem.type === "common_time") {
        abselem.addRight(new RelativeElement("timesig.common", 0, glyphs.getSymbolWidth("timesig.common"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.common") }));
      } else if (elem.type === "cut_time") {
        abselem.addRight(new RelativeElement("timesig.cut", 0, glyphs.getSymbolWidth("timesig.cut"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.cut") }));
      } else if (elem.type === "tempus_imperfectum") {
        abselem.addRight(new RelativeElement("timesig.imperfectum", 0, glyphs.getSymbolWidth("timesig.imperfectum"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.imperfectum") }));
      } else if (elem.type === "tempus_imperfectum_prolatio") {
        abselem.addRight(new RelativeElement("timesig.imperfectum2", 0, glyphs.getSymbolWidth("timesig.imperfectum2"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.imperfectum2") }));
      } else if (elem.type === "tempus_perfectum") {
        abselem.addRight(new RelativeElement("timesig.perfectum", 0, glyphs.getSymbolWidth("timesig.perfectum"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.perfectum") }));
      } else if (elem.type === "tempus_perfectum_prolatio") {
        abselem.addRight(new RelativeElement("timesig.perfectum2", 0, glyphs.getSymbolWidth("timesig.perfectum2"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.perfectum2") }));
      } else {
        console.log("time signature:", elem);
      }
      return abselem;
    };
    module.exports = createTimeSignature;
  }
});

// node_modules/abcjs/src/write/abc_dynamic_decoration.js
var require_abc_dynamic_decoration = __commonJS({
  "node_modules/abcjs/src/write/abc_dynamic_decoration.js"(exports, module) {
    var DynamicDecoration = function DynamicDecoration2(anchor, dec, position) {
      this.type = "DynamicDecoration";
      this.anchor = anchor;
      this.dec = dec;
      if (position === "below")
        this.volumeHeightBelow = 6;
      else
        this.volumeHeightAbove = 6;
      this.pitch = void 0;
    };
    module.exports = DynamicDecoration;
  }
});

// node_modules/abcjs/src/write/abc_crescendo_element.js
var require_abc_crescendo_element = __commonJS({
  "node_modules/abcjs/src/write/abc_crescendo_element.js"(exports, module) {
    var CrescendoElem = function CrescendoElem2(anchor1, anchor2, dir, positioning) {
      this.type = "CrescendoElem";
      this.anchor1 = anchor1;
      this.anchor2 = anchor2;
      this.dir = dir;
      if (positioning === "above")
        this.dynamicHeightAbove = 6;
      else
        this.dynamicHeightBelow = 6;
      this.pitch = void 0;
    };
    module.exports = CrescendoElem;
  }
});

// node_modules/abcjs/src/write/abc_tie_element.js
var require_abc_tie_element = __commonJS({
  "node_modules/abcjs/src/write/abc_tie_element.js"(exports, module) {
    var TieElem = function TieElem2(options) {
      this.type = "TieElem";
      this.anchor1 = options.anchor1;
      this.anchor2 = options.anchor2;
      if (options.isGrace)
        this.isGrace = true;
      if (options.fixedY)
        this.fixedY = true;
      if (options.stemDir)
        this.stemDir = options.stemDir;
      if (options.voiceNumber !== void 0)
        this.voiceNumber = options.voiceNumber;
      if (options.style !== void 0)
        this.dotted = true;
      this.internalNotes = [];
    };
    TieElem.prototype.addInternalNote = function(note) {
      this.internalNotes.push(note);
    };
    TieElem.prototype.setEndAnchor = function(anchor2) {
      this.anchor2 = anchor2;
    };
    TieElem.prototype.setStartX = function(startLimitElem) {
      this.startLimitX = startLimitElem;
    };
    TieElem.prototype.setEndX = function(endLimitElem) {
      this.endLimitX = endLimitElem;
    };
    TieElem.prototype.setHint = function() {
      this.hint = true;
    };
    TieElem.prototype.calcTieDirection = function() {
      if (this.isGrace)
        this.above = false;
      else if (this.voiceNumber === 0)
        this.above = true;
      else if (this.voiceNumber > 0)
        this.above = false;
      else {
        var referencePitch;
        if (this.anchor1)
          referencePitch = this.anchor1.pitch;
        else if (this.anchor2)
          referencePitch = this.anchor2.pitch;
        else
          referencePitch = 14;
        if (this.anchor1 && this.anchor1.stemDir === "down" && (this.anchor2 && this.anchor2.stemDir === "down"))
          this.above = true;
        else if (this.anchor1 && this.anchor1.stemDir === "up" && (this.anchor2 && this.anchor2.stemDir === "up"))
          this.above = false;
        else if (this.anchor1 && this.anchor2)
          this.above = referencePitch >= 6;
        else if (this.anchor1)
          this.above = this.anchor1.stemDir === "down";
        else if (this.anchor2)
          this.above = this.anchor2.stemDir === "down";
        else
          this.above = referencePitch >= 6;
      }
    };
    TieElem.prototype.calcSlurDirection = function() {
      if (this.isGrace)
        this.above = false;
      else if (this.voiceNumber === 0)
        this.above = true;
      else if (this.voiceNumber > 0)
        this.above = false;
      else {
        var hasDownStem = false;
        if (this.anchor1 && this.anchor1.stemDir === "down")
          hasDownStem = true;
        if (this.anchor2 && this.anchor2.stemDir === "down")
          hasDownStem = true;
        for (var i = 0; i < this.internalNotes.length; i++) {
          var n = this.internalNotes[i];
          if (n.stemDir === "down")
            hasDownStem = true;
        }
        this.above = hasDownStem;
      }
    };
    TieElem.prototype.calcX = function(lineStartX, lineEndX) {
      if (this.anchor1) {
        this.startX = this.anchor1.x;
        if (this.anchor1.scalex < 1)
          this.startX -= 3;
      } else if (this.startLimitX)
        this.startX = this.startLimitX.x + this.startLimitX.w;
      else
        this.startX = lineStartX;
      if (!this.anchor1 && this.dotted)
        this.startX -= 3;
      if (this.anchor2)
        this.endX = this.anchor2.x;
      else if (this.endLimitX)
        this.endX = this.endLimitX.x;
      else
        this.endX = lineEndX;
    };
    TieElem.prototype.calcTieY = function() {
      if (this.anchor1)
        this.startY = this.anchor1.pitch;
      else if (this.anchor2)
        this.startY = this.anchor2.pitch;
      else
        this.startY = this.above ? 14 : 0;
      if (this.anchor2)
        this.endY = this.anchor2.pitch;
      else if (this.anchor1)
        this.endY = this.anchor1.pitch;
      else
        this.endY = this.above ? 14 : 0;
    };
    TieElem.prototype.calcSlurY = function() {
      if (this.anchor1 && this.anchor2) {
        if (this.above && this.anchor1.stemDir === "up" && !this.fixedY) {
          this.startY = (this.anchor1.highestVert + this.anchor1.pitch) / 2;
          this.startX += this.anchor1.w / 2;
        } else
          this.startY = this.anchor1.pitch;
        var beamInterferes = this.anchor2.parent.beam && this.anchor2.parent.beam.stemsUp && this.anchor2.parent.beam.elems[0] !== this.anchor2.parent;
        var midPoint = (this.anchor2.highestVert + this.anchor2.pitch) / 2;
        if (this.above && this.anchor2.stemDir === "up" && !this.fixedY && !beamInterferes && midPoint < this.startY) {
          this.endY = midPoint;
          this.endX += Math.round(this.anchor2.w / 2);
        } else
          this.endY = this.above && beamInterferes ? this.anchor2.highestVert : this.anchor2.pitch;
      } else if (this.anchor1) {
        this.startY = this.endY = this.anchor1.pitch;
      } else if (this.anchor2) {
        this.startY = this.endY = this.anchor2.pitch;
      } else {
        this.startY = this.above ? 14 : 0;
        this.endY = this.above ? 14 : 0;
      }
    };
    TieElem.prototype.avoidCollisionAbove = function() {
      if (this.above) {
        var maxInnerHeight = -50;
        for (var i = 0; i < this.internalNotes.length; i++) {
          if (this.internalNotes[i].highestVert > maxInnerHeight)
            maxInnerHeight = this.internalNotes[i].highestVert;
        }
        if (maxInnerHeight > this.startY && maxInnerHeight > this.endY)
          this.startY = this.endY = maxInnerHeight - 1;
      }
    };
    module.exports = TieElem;
  }
});

// node_modules/abcjs/src/write/abc_decoration.js
var require_abc_decoration = __commonJS({
  "node_modules/abcjs/src/write/abc_decoration.js"(exports, module) {
    var DynamicDecoration = require_abc_dynamic_decoration();
    var CrescendoElem = require_abc_crescendo_element();
    var glyphs = require_abc_glyphs();
    var RelativeElement = require_abc_relative_element();
    var TieElem = require_abc_tie_element();
    var Decoration = function Decoration2() {
      this.startDiminuendoX = void 0;
      this.startCrescendoX = void 0;
      this.minTop = 12;
      this.minBottom = 0;
    };
    var closeDecoration = function(voice, decoration, pitch, width, abselem, roomtaken, dir, minPitch) {
      var yPos;
      for (var i = 0; i < decoration.length; i++) {
        if (decoration[i] === "staccato" || decoration[i] === "tenuto" || decoration[i] === "accent") {
          var symbol = "scripts." + decoration[i];
          if (decoration[i] === "accent")
            symbol = "scripts.sforzato";
          if (yPos === void 0)
            yPos = dir === "down" ? pitch + 2 : minPitch - 2;
          else
            yPos = dir === "down" ? yPos + 2 : yPos - 2;
          if (decoration[i] === "accent") {
            if (dir === "up")
              yPos--;
            else
              yPos++;
          } else {
            switch (yPos) {
              case 2:
              case 4:
              case 6:
              case 8:
              case 10:
                if (dir === "up")
                  yPos--;
                else
                  yPos++;
                break;
            }
          }
          if (pitch > 9)
            yPos++;
          var deltaX = width / 2;
          if (glyphs.getSymbolAlign(symbol) !== "center") {
            deltaX -= glyphs.getSymbolWidth(symbol) / 2;
          }
          abselem.addFixedX(new RelativeElement(symbol, deltaX, glyphs.getSymbolWidth(symbol), yPos));
        }
        if (decoration[i] === "slide" && abselem.heads[0]) {
          var yPos2 = abselem.heads[0].pitch;
          yPos2 -= 2;
          var blank1 = new RelativeElement("", -roomtaken - 15, 0, yPos2 - 1);
          var blank2 = new RelativeElement("", -roomtaken - 5, 0, yPos2 + 1);
          abselem.addFixedX(blank1);
          abselem.addFixedX(blank2);
          voice.addOther(new TieElem({ anchor1: blank1, anchor2: blank2, fixedY: true }));
        }
      }
      if (yPos === void 0)
        yPos = pitch;
      return { above: yPos, below: abselem.bottom };
    };
    var volumeDecoration = function(voice, decoration, abselem, positioning) {
      for (var i = 0; i < decoration.length; i++) {
        switch (decoration[i]) {
          case "p":
          case "mp":
          case "pp":
          case "ppp":
          case "pppp":
          case "f":
          case "ff":
          case "fff":
          case "ffff":
          case "sfz":
          case "mf":
            var elem = new DynamicDecoration(abselem, decoration[i], positioning);
            voice.addOther(elem);
        }
      }
    };
    var compoundDecoration = function(decoration, pitch, width, abselem, dir) {
      function highestPitch() {
        if (abselem.heads.length === 0)
          return 10;
        var pitch2 = abselem.heads[0].pitch;
        for (var i2 = 1; i2 < abselem.heads.length; i2++)
          pitch2 = Math.max(pitch2, abselem.heads[i2].pitch);
        return pitch2;
      }
      function lowestPitch() {
        if (abselem.heads.length === 0)
          return 2;
        var pitch2 = abselem.heads[0].pitch;
        for (var i2 = 1; i2 < abselem.heads.length; i2++)
          pitch2 = Math.min(pitch2, abselem.heads[i2].pitch);
        return pitch2;
      }
      function compoundDecoration2(symbol, count) {
        var placement = dir === "down" ? lowestPitch() + 1 : highestPitch() + 9;
        if (dir !== "down" && count === 1)
          placement--;
        var deltaX = width / 2;
        deltaX += dir === "down" ? -5 : 3;
        for (var i2 = 0; i2 < count; i2++) {
          placement -= 1;
          abselem.addFixedX(new RelativeElement(symbol, deltaX, glyphs.getSymbolWidth(symbol), placement));
        }
      }
      for (var i = 0; i < decoration.length; i++) {
        switch (decoration[i]) {
          case "/":
            compoundDecoration2("flags.ugrace", 1);
            break;
          case "//":
            compoundDecoration2("flags.ugrace", 2);
            break;
          case "///":
            compoundDecoration2("flags.ugrace", 3);
            break;
          case "////":
            compoundDecoration2("flags.ugrace", 4);
            break;
        }
      }
    };
    var stackedDecoration = function(decoration, width, abselem, yPos, positioning, minTop, minBottom) {
      function incrementPlacement(placement, height) {
        if (placement === "above")
          yPos.above += height;
        else
          yPos.below -= height;
      }
      function getPlacement(placement) {
        var y;
        if (placement === "above") {
          y = yPos.above;
          if (y < minTop)
            y = minTop;
        } else {
          y = yPos.below;
          if (y > minBottom)
            y = minBottom;
        }
        return y;
      }
      function textDecoration(text, placement) {
        var y = getPlacement(placement);
        var textFudge = 2;
        var textHeight = 5;
        abselem.addFixedX(new RelativeElement(text, width / 2, 0, y + textFudge, { type: "decoration", klass: "ornament", thickness: 3 }));
        incrementPlacement(placement, textHeight);
      }
      function symbolDecoration(symbol, placement) {
        var deltaX = width / 2;
        if (glyphs.getSymbolAlign(symbol) !== "center") {
          deltaX -= glyphs.getSymbolWidth(symbol) / 2;
        }
        var height = glyphs.symbolHeightInPitches(symbol) + 1;
        var y = getPlacement(placement);
        y = placement === "above" ? y + height / 2 : y - height / 2;
        abselem.addFixedX(new RelativeElement(symbol, deltaX, glyphs.getSymbolWidth(symbol), y, { klass: "ornament", thickness: glyphs.symbolHeightInPitches(symbol) }));
        incrementPlacement(placement, height);
      }
      var symbolList = {
        "+": "scripts.stopped",
        "open": "scripts.open",
        "snap": "scripts.snap",
        "wedge": "scripts.wedge",
        "thumb": "scripts.thumb",
        "shortphrase": "scripts.shortphrase",
        "mediumphrase": "scripts.mediumphrase",
        "longphrase": "scripts.longphrase",
        "trill": "scripts.trill",
        "roll": "scripts.roll",
        "irishroll": "scripts.roll",
        "marcato": "scripts.umarcato",
        "dmarcato": "scripts.dmarcato",
        "umarcato": "scripts.umarcato",
        "turn": "scripts.turn",
        "uppermordent": "scripts.prall",
        "pralltriller": "scripts.prall",
        "mordent": "scripts.mordent",
        "lowermordent": "scripts.mordent",
        "downbow": "scripts.downbow",
        "upbow": "scripts.upbow",
        "fermata": "scripts.ufermata",
        "invertedfermata": "scripts.dfermata",
        "breath": ",",
        "coda": "scripts.coda",
        "segno": "scripts.segno"
      };
      var hasOne = false;
      for (var i = 0; i < decoration.length; i++) {
        switch (decoration[i]) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "D.C.":
          case "D.S.":
            textDecoration(decoration[i], positioning);
            hasOne = true;
            break;
          case "fine":
            textDecoration("FINE", positioning);
            hasOne = true;
            break;
          case "+":
          case "open":
          case "snap":
          case "wedge":
          case "thumb":
          case "shortphrase":
          case "mediumphrase":
          case "longphrase":
          case "trill":
          case "roll":
          case "irishroll":
          case "marcato":
          case "dmarcato":
          case "turn":
          case "uppermordent":
          case "pralltriller":
          case "mordent":
          case "lowermordent":
          case "downbow":
          case "upbow":
          case "fermata":
          case "breath":
          case "umarcato":
          case "coda":
          case "segno":
            symbolDecoration(symbolList[decoration[i]], positioning);
            hasOne = true;
            break;
          case "invertedfermata":
            symbolDecoration(symbolList[decoration[i]], "below");
            hasOne = true;
            break;
          case "mark":
            abselem.klass = "mark";
            break;
        }
      }
      return hasOne;
    };
    function leftDecoration(decoration, abselem, roomtaken) {
      for (var i = 0; i < decoration.length; i++) {
        switch (decoration[i]) {
          case "arpeggio":
            for (var j = abselem.abcelem.minpitch - 1; j <= abselem.abcelem.maxpitch; j += 2) {
              abselem.addExtra(new RelativeElement("scripts.arpeggio", -glyphs.getSymbolWidth("scripts.arpeggio") * 2 - roomtaken, 0, j + 2, { klass: "ornament", thickness: glyphs.symbolHeightInPitches("scripts.arpeggio") }));
            }
            break;
        }
      }
    }
    Decoration.prototype.dynamicDecoration = function(voice, decoration, abselem, positioning) {
      var diminuendo;
      var crescendo;
      for (var i = 0; i < decoration.length; i++) {
        switch (decoration[i]) {
          case "diminuendo(":
            this.startDiminuendoX = abselem;
            diminuendo = void 0;
            break;
          case "diminuendo)":
            diminuendo = { start: this.startDiminuendoX, stop: abselem };
            this.startDiminuendoX = void 0;
            break;
          case "crescendo(":
            this.startCrescendoX = abselem;
            crescendo = void 0;
            break;
          case "crescendo)":
            crescendo = { start: this.startCrescendoX, stop: abselem };
            this.startCrescendoX = void 0;
            break;
        }
      }
      if (diminuendo) {
        voice.addOther(new CrescendoElem(diminuendo.start, diminuendo.stop, ">", positioning));
      }
      if (crescendo) {
        voice.addOther(new CrescendoElem(crescendo.start, crescendo.stop, "<", positioning));
      }
    };
    Decoration.prototype.createDecoration = function(voice, decoration, pitch, width, abselem, roomtaken, dir, minPitch, positioning, hasVocals) {
      if (!positioning)
        positioning = { ornamentPosition: "above", volumePosition: hasVocals ? "above" : "below", dynamicPosition: hasVocals ? "above" : "below" };
      volumeDecoration(voice, decoration, abselem, positioning.volumePosition);
      this.dynamicDecoration(voice, decoration, abselem, positioning.dynamicPosition);
      compoundDecoration(decoration, pitch, width, abselem, dir);
      var yPos = closeDecoration(voice, decoration, pitch, width, abselem, roomtaken, dir, minPitch);
      yPos.above = Math.max(yPos.above, this.minTop);
      var hasOne = stackedDecoration(decoration, width, abselem, yPos, positioning.ornamentPosition, this.minTop, this.minBottom);
      if (hasOne) {
      }
      leftDecoration(decoration, abselem, roomtaken);
    };
    module.exports = Decoration;
  }
});

// node_modules/abcjs/src/write/abc_ending_element.js
var require_abc_ending_element = __commonJS({
  "node_modules/abcjs/src/write/abc_ending_element.js"(exports, module) {
    var EndingElem = function EndingElem2(text, anchor1, anchor2) {
      this.type = "EndingElem";
      this.text = text;
      this.anchor1 = anchor1;
      this.anchor2 = anchor2;
      this.endingHeightAbove = 5;
      this.pitch = void 0;
    };
    module.exports = EndingElem;
  }
});

// node_modules/abcjs/src/write/calcHeight.js
var require_calcHeight = __commonJS({
  "node_modules/abcjs/src/write/calcHeight.js"(exports, module) {
    var calcHeight = function(staffGroup) {
      var height = 0;
      for (var i = 0; i < staffGroup.voices.length; i++) {
        var staff = staffGroup.voices[i].staff;
        if (!staffGroup.voices[i].duplicate) {
          height += staff.top;
          height += -staff.bottom;
        }
      }
      return height;
    };
    module.exports = calcHeight;
  }
});

// node_modules/abcjs/src/write/abc_staff_group_element.js
var require_abc_staff_group_element = __commonJS({
  "node_modules/abcjs/src/write/abc_staff_group_element.js"(exports, module) {
    var calcHeight = require_calcHeight();
    var StaffGroupElement = function(getTextSize) {
      this.getTextSize = getTextSize;
      this.voices = [];
      this.staffs = [];
      this.brace = void 0;
      this.bracket = void 0;
    };
    StaffGroupElement.prototype.setLimit = function(member, voice) {
      if (!voice.specialY[member])
        return;
      if (!voice.staff.specialY[member])
        voice.staff.specialY[member] = voice.specialY[member];
      else
        voice.staff.specialY[member] = Math.max(voice.staff.specialY[member], voice.specialY[member]);
    };
    StaffGroupElement.prototype.addVoice = function(voice, staffnumber, stafflines) {
      var voiceNum = this.voices.length;
      this.voices[voiceNum] = voice;
      if (this.staffs[staffnumber])
        this.staffs[staffnumber].voices.push(voiceNum);
      else {
        this.staffs[this.staffs.length] = {
          top: 10,
          bottom: 2,
          lines: stafflines,
          voices: [voiceNum],
          specialY: {
            tempoHeightAbove: 0,
            partHeightAbove: 0,
            volumeHeightAbove: 0,
            dynamicHeightAbove: 0,
            endingHeightAbove: 0,
            chordHeightAbove: 0,
            lyricHeightAbove: 0,
            lyricHeightBelow: 0,
            chordHeightBelow: 0,
            volumeHeightBelow: 0,
            dynamicHeightBelow: 0
          }
        };
      }
      voice.staff = this.staffs[staffnumber];
    };
    StaffGroupElement.prototype.setHeight = function() {
      this.height = calcHeight(this);
    };
    StaffGroupElement.prototype.setWidth = function(width) {
      this.w = width;
      for (var i = 0; i < this.voices.length; i++) {
        this.voices[i].setWidth(width);
      }
    };
    StaffGroupElement.prototype.setStaffLimits = function(voice) {
      voice.staff.top = Math.max(voice.staff.top, voice.top);
      voice.staff.bottom = Math.min(voice.staff.bottom, voice.bottom);
      this.setLimit("tempoHeightAbove", voice);
      this.setLimit("partHeightAbove", voice);
      this.setLimit("volumeHeightAbove", voice);
      this.setLimit("dynamicHeightAbove", voice);
      this.setLimit("endingHeightAbove", voice);
      this.setLimit("chordHeightAbove", voice);
      this.setLimit("lyricHeightAbove", voice);
      this.setLimit("lyricHeightBelow", voice);
      this.setLimit("chordHeightBelow", voice);
      this.setLimit("volumeHeightBelow", voice);
      this.setLimit("dynamicHeightBelow", voice);
    };
    module.exports = StaffGroupElement;
  }
});

// node_modules/abcjs/src/write/abc_tempo_element.js
var require_abc_tempo_element = __commonJS({
  "node_modules/abcjs/src/write/abc_tempo_element.js"(exports, module) {
    var AbsoluteElement = require_abc_absolute_element();
    var RelativeElement = require_abc_relative_element();
    var TempoElement = function TempoElement2(tempo, tuneNumber, createNoteHead) {
      this.type = "TempoElement";
      this.tempo = tempo;
      this.tempo.type = "tempo";
      this.tuneNumber = tuneNumber;
      this.totalHeightInPitches = 6;
      this.tempoHeightAbove = this.totalHeightInPitches;
      this.pitch = void 0;
      if (this.tempo.duration && !this.tempo.suppressBpm) {
        this.note = this.createNote(createNoteHead, tempo, tuneNumber);
      }
    };
    TempoElement.prototype.setX = function(x) {
      this.x = x;
    };
    TempoElement.prototype.createNote = function(createNoteHead, tempo, tuneNumber) {
      var temposcale = 0.75;
      var duration = tempo.duration[0];
      var absElem = new AbsoluteElement(tempo, duration, 1, "tempo", tuneNumber);
      var dot;
      var flag;
      var note;
      if (duration <= 1 / 32) {
        note = "noteheads.quarter";
        flag = "flags.u32nd";
        dot = 0;
      } else if (duration <= 1 / 16) {
        note = "noteheads.quarter";
        flag = "flags.u16th";
        dot = 0;
      } else if (duration <= 3 / 32) {
        note = "noteheads.quarter";
        flag = "flags.u16nd";
        dot = 1;
      } else if (duration <= 1 / 8) {
        note = "noteheads.quarter";
        flag = "flags.u8th";
        dot = 0;
      } else if (duration <= 3 / 16) {
        note = "noteheads.quarter";
        flag = "flags.u8th";
        dot = 1;
      } else if (duration <= 1 / 4) {
        note = "noteheads.quarter";
        dot = 0;
      } else if (duration <= 3 / 8) {
        note = "noteheads.quarter";
        dot = 1;
      } else if (duration <= 1 / 2) {
        note = "noteheads.half";
        dot = 0;
      } else if (duration <= 3 / 4) {
        note = "noteheads.half";
        dot = 1;
      } else if (duration <= 1) {
        note = "noteheads.whole";
        dot = 0;
      } else if (duration <= 1.5) {
        note = "noteheads.whole";
        dot = 1;
      } else if (duration <= 2) {
        note = "noteheads.dbl";
        dot = 0;
      } else {
        note = "noteheads.dbl";
        dot = 1;
      }
      var ret = createNoteHead(absElem, note, { verticalPos: 0 }, { dir: "up", flag, dot, scale: temposcale });
      var tempoNote = ret.notehead;
      absElem.addHead(tempoNote);
      var stem;
      if (note !== "noteheads.whole" && note !== "noteheads.dbl") {
        var p1 = 1 / 3 * temposcale;
        var p2 = 5 * temposcale;
        var dx = tempoNote.dx + tempoNote.w;
        var width = -0.6;
        stem = new RelativeElement(null, dx, 0, p1, { "type": "stem", "pitch2": p2, linewidth: width });
        absElem.addRight(stem);
      }
      return absElem;
    };
    module.exports = TempoElement;
  }
});

// node_modules/abcjs/src/write/abc_triplet_element.js
var require_abc_triplet_element = __commonJS({
  "node_modules/abcjs/src/write/abc_triplet_element.js"(exports, module) {
    var TripletElem = function TripletElem2(number, anchor1, options) {
      this.type = "TripletElem";
      this.anchor1 = anchor1;
      this.number = number;
      this.durationClass = ("d" + Math.round(anchor1.parent.durationClass * 1e3) / 1e3).replace(/\./, "-");
      this.middleElems = [];
      this.flatBeams = options.flatBeams;
    };
    TripletElem.prototype.isClosed = function() {
      return !!this.anchor2;
    };
    TripletElem.prototype.middleNote = function(elem) {
      this.middleElems.push(elem);
    };
    TripletElem.prototype.setCloseAnchor = function(anchor2) {
      this.anchor2 = anchor2;
      if (!this.anchor1.parent.beam || this.anchor1.stemDir === "up")
        this.endingHeightAbove = 4;
    };
    module.exports = TripletElem;
  }
});

// node_modules/abcjs/src/write/format-jazz-chord.js
var require_format_jazz_chord = __commonJS({
  "node_modules/abcjs/src/write/format-jazz-chord.js"(exports, module) {
    function formatJazzChord(chordString) {
      var lines = chordString.split("\n");
      for (var i = 0; i < lines.length; i++) {
        var chord = lines[i];
        var reg = chord.match(/^([ABCDEFG][♯♭]?)?([^\/]+)?(\/[ABCDEFG][#b]?)?/);
        if (reg)
          lines[i] = (reg[1] ? reg[1] : "") + "" + (reg[2] ? reg[2] : "") + "" + (reg[3] ? reg[3] : "");
      }
      return lines.join("\n");
    }
    module.exports = formatJazzChord;
  }
});

// node_modules/abcjs/src/write/add-chord.js
var require_add_chord = __commonJS({
  "node_modules/abcjs/src/write/add-chord.js"(exports, module) {
    var RelativeElement = require_abc_relative_element();
    var spacing = require_abc_spacing();
    var formatJazzChord = require_format_jazz_chord();
    var addChord = function(getTextSize, abselem, elem, roomTaken, roomTakenRight, noteheadWidth, jazzchords) {
      for (var i = 0; i < elem.chord.length; i++) {
        var pos = elem.chord[i].position;
        var rel_position = elem.chord[i].rel_position;
        var chords = elem.chord[i].name.split("\n");
        for (var j = chords.length - 1; j >= 0; j--) {
          var chord = chords[j];
          var x = 0;
          var y;
          var font;
          var klass;
          if (pos === "left" || pos === "right" || pos === "below" || pos === "above" || !!rel_position) {
            font = "annotationfont";
            klass = "annotation";
          } else {
            font = "gchordfont";
            klass = "chord";
            if (jazzchords)
              chord = formatJazzChord(chord);
          }
          var attr = getTextSize.attr(font, klass);
          var dim = getTextSize.calc(chord, font, klass);
          var chordWidth = dim.width;
          var chordHeight = dim.height / spacing.STEP;
          switch (pos) {
            case "left":
              roomTaken += chordWidth + 7;
              x = -roomTaken;
              y = elem.averagepitch;
              abselem.addExtra(new RelativeElement(chord, x, chordWidth + 4, y, {
                type: "text",
                height: chordHeight,
                dim: attr,
                position: "left"
              }));
              break;
            case "right":
              roomTakenRight += 4;
              x = roomTakenRight;
              y = elem.averagepitch;
              abselem.addRight(new RelativeElement(chord, x, chordWidth + 4, y, {
                type: "text",
                height: chordHeight,
                dim: attr,
                position: "right"
              }));
              break;
            case "below":
              abselem.addRight(new RelativeElement(chord, 0, 0, void 0, {
                type: "text",
                position: "below",
                height: chordHeight,
                dim: attr,
                realWidth: chordWidth
              }));
              break;
            case "above":
              abselem.addRight(new RelativeElement(chord, 0, 0, void 0, {
                type: "text",
                position: "above",
                height: chordHeight,
                dim: attr,
                realWidth: chordWidth
              }));
              break;
            default:
              if (rel_position) {
                var relPositionY = rel_position.y + 3 * spacing.STEP;
                abselem.addRight(new RelativeElement(chord, x + rel_position.x, 0, elem.minpitch + relPositionY / spacing.STEP, {
                  position: "relative",
                  type: "text",
                  height: chordHeight,
                  dim: attr
                }));
              } else {
                var pos2 = "above";
                if (elem.positioning && elem.positioning.chordPosition)
                  pos2 = elem.positioning.chordPosition;
                if (pos2 !== "hidden") {
                  abselem.addCentered(new RelativeElement(chord, noteheadWidth / 2, chordWidth, void 0, {
                    type: "chord",
                    position: pos2,
                    height: chordHeight,
                    dim: attr,
                    realWidth: chordWidth
                  }));
                }
              }
          }
        }
      }
      return { roomTaken, roomTakenRight };
    };
    module.exports = addChord;
  }
});

// node_modules/abcjs/src/write/abc_abstract_engraver.js
var require_abc_abstract_engraver = __commonJS({
  "node_modules/abcjs/src/write/abc_abstract_engraver.js"(exports, module) {
    var AbsoluteElement = require_abc_absolute_element();
    var BeamElem = require_abc_beam_element();
    var BraceElem = require_abc_brace_element();
    var createClef = require_abc_create_clef();
    var createKeySignature = require_abc_create_key_signature();
    var createNoteHead = require_abc_create_note_head();
    var createTimeSignature = require_abc_create_time_signature();
    var Decoration = require_abc_decoration();
    var EndingElem = require_abc_ending_element();
    var glyphs = require_abc_glyphs();
    var RelativeElement = require_abc_relative_element();
    var spacing = require_abc_spacing();
    var StaffGroupElement = require_abc_staff_group_element();
    var TempoElement = require_abc_tempo_element();
    var TieElem = require_abc_tie_element();
    var TripletElem = require_abc_triplet_element();
    var VoiceElement = require_abc_voice_element();
    var addChord = require_add_chord();
    var pitchesToPerc = require_pitches_to_perc();
    var parseCommon = require_abc_common();
    var getDuration = function(elem) {
      var d = 0;
      if (elem.duration) {
        d = elem.duration;
      }
      return d;
    };
    var hint = false;
    var chartable = {
      rest: { 0: "rests.whole", 1: "rests.half", 2: "rests.quarter", 3: "rests.8th", 4: "rests.16th", 5: "rests.32nd", 6: "rests.64th", 7: "rests.128th", "multi": "rests.multimeasure" },
      note: { "-1": "noteheads.dbl", 0: "noteheads.whole", 1: "noteheads.half", 2: "noteheads.quarter", 3: "noteheads.quarter", 4: "noteheads.quarter", 5: "noteheads.quarter", 6: "noteheads.quarter", 7: "noteheads.quarter", "nostem": "noteheads.quarter" },
      rhythm: { "-1": "noteheads.slash.whole", 0: "noteheads.slash.whole", 1: "noteheads.slash.whole", 2: "noteheads.slash.quarter", 3: "noteheads.slash.quarter", 4: "noteheads.slash.quarter", 5: "noteheads.slash.quarter", 6: "noteheads.slash.quarter", 7: "noteheads.slash.quarter", nostem: "noteheads.slash.nostem" },
      x: { "-1": "noteheads.indeterminate", 0: "noteheads.indeterminate", 1: "noteheads.indeterminate", 2: "noteheads.indeterminate", 3: "noteheads.indeterminate", 4: "noteheads.indeterminate", 5: "noteheads.indeterminate", 6: "noteheads.indeterminate", 7: "noteheads.indeterminate", nostem: "noteheads.indeterminate" },
      harmonic: { "-1": "noteheads.harmonic.quarter", 0: "noteheads.harmonic.quarter", 1: "noteheads.harmonic.quarter", 2: "noteheads.harmonic.quarter", 3: "noteheads.harmonic.quarter", 4: "noteheads.harmonic.quarter", 5: "noteheads.harmonic.quarter", 6: "noteheads.harmonic.quarter", 7: "noteheads.harmonic.quarter", nostem: "noteheads.harmonic.quarter" },
      triangle: { "-1": "noteheads.triangle.quarter", 0: "noteheads.triangle.quarter", 1: "noteheads.triangle.quarter", 2: "noteheads.triangle.quarter", 3: "noteheads.triangle.quarter", 4: "noteheads.triangle.quarter", 5: "noteheads.triangle.quarter", 6: "noteheads.triangle.quarter", 7: "noteheads.triangle.quarter", nostem: "noteheads.triangle.quarter" },
      uflags: { 3: "flags.u8th", 4: "flags.u16th", 5: "flags.u32nd", 6: "flags.u64th" },
      dflags: { 3: "flags.d8th", 4: "flags.d16th", 5: "flags.d32nd", 6: "flags.d64th" }
    };
    var AbstractEngraver = function(getTextSize, tuneNumber, options) {
      this.decoration = new Decoration();
      this.getTextSize = getTextSize;
      this.tuneNumber = tuneNumber;
      this.isBagpipes = options.bagpipes;
      this.flatBeams = options.flatbeams;
      this.graceSlurs = options.graceSlurs;
      this.percmap = options.percmap;
      this.initialClef = options.initialClef;
      this.jazzchords = !!options.jazzchords;
      this.reset();
    };
    AbstractEngraver.prototype.reset = function() {
      this.slurs = {};
      this.ties = [];
      this.voiceScale = 1;
      this.slursbyvoice = {};
      this.tiesbyvoice = {};
      this.endingsbyvoice = {};
      this.scaleByVoice = {};
      this.tripletmultiplier = 1;
      this.abcline = void 0;
      this.accidentalSlot = void 0;
      this.accidentalshiftx = void 0;
      this.dotshiftx = void 0;
      this.hasVocals = false;
      this.minY = void 0;
      this.partstartelem = void 0;
      this.startlimitelem = void 0;
      this.stemdir = void 0;
    };
    AbstractEngraver.prototype.setStemHeight = function(heightInPixels) {
      this.stemHeight = Math.round(heightInPixels * 10 / spacing.STEP) / 10;
    };
    AbstractEngraver.prototype.getCurrentVoiceId = function(s, v) {
      return "s" + s + "v" + v;
    };
    AbstractEngraver.prototype.pushCrossLineElems = function(s, v) {
      this.slursbyvoice[this.getCurrentVoiceId(s, v)] = this.slurs;
      this.tiesbyvoice[this.getCurrentVoiceId(s, v)] = this.ties;
      this.endingsbyvoice[this.getCurrentVoiceId(s, v)] = this.partstartelem;
      this.scaleByVoice[this.getCurrentVoiceId(s, v)] = this.voiceScale;
    };
    AbstractEngraver.prototype.popCrossLineElems = function(s, v) {
      this.slurs = this.slursbyvoice[this.getCurrentVoiceId(s, v)] || {};
      this.ties = this.tiesbyvoice[this.getCurrentVoiceId(s, v)] || [];
      this.partstartelem = this.endingsbyvoice[this.getCurrentVoiceId(s, v)];
      this.voiceScale = this.scaleByVoice[this.getCurrentVoiceId(s, v)];
      if (this.voiceScale === void 0)
        this.voiceScale = 1;
    };
    AbstractEngraver.prototype.containsLyrics = function(staves) {
      for (var i = 0; i < staves.length; i++) {
        for (var j = 0; j < staves[i].voices.length; j++) {
          for (var k = 0; k < staves[i].voices[j].length; k++) {
            var el = staves[i].voices[j][k];
            if (el.lyric) {
              if (!el.positioning || el.positioning.vocalPosition === "below")
                this.hasVocals = true;
              return;
            }
          }
        }
      }
    };
    AbstractEngraver.prototype.createABCLine = function(staffs, tempo, l) {
      this.minY = 2;
      this.containsLyrics(staffs);
      var staffgroup = new StaffGroupElement(this.getTextSize);
      this.tempoSet = false;
      for (var s = 0; s < staffs.length; s++) {
        if (hint)
          this.restoreState();
        hint = false;
        this.createABCStaff(staffgroup, staffs[s], tempo, s, l);
      }
      return staffgroup;
    };
    AbstractEngraver.prototype.createABCStaff = function(staffgroup, abcstaff, tempo, s, l) {
      staffgroup.getTextSize.updateFonts(abcstaff);
      for (var v = 0; v < abcstaff.voices.length; v++) {
        var voice = new VoiceElement(v, abcstaff.voices.length);
        if (v === 0) {
          voice.barfrom = abcstaff.connectBarLines === "start" || abcstaff.connectBarLines === "continue";
          voice.barto = abcstaff.connectBarLines === "continue" || abcstaff.connectBarLines === "end";
        } else {
          voice.duplicate = true;
        }
        if (abcstaff.title && abcstaff.title[v]) {
          voice.header = abcstaff.title[v].replace(/\\n/g, "\n");
          voice.headerPosition = 6 + staffgroup.getTextSize.baselineToCenter(voice.header, "voicefont", "staff-extra voice-name", v, abcstaff.voices.length) / spacing.STEP;
        }
        if (abcstaff.clef && abcstaff.clef.type === "perc")
          voice.isPercussion = true;
        var clef = (!this.initialClef || l === 0) && createClef(abcstaff.clef, this.tuneNumber);
        if (clef) {
          if (v === 0 && abcstaff.barNumber) {
            this.addMeasureNumber(abcstaff.barNumber, clef);
          }
          voice.addChild(clef);
          this.startlimitelem = clef;
        }
        var keySig = createKeySignature(abcstaff.key, this.tuneNumber);
        if (keySig) {
          voice.addChild(keySig);
          this.startlimitelem = keySig;
        }
        if (abcstaff.meter) {
          if (abcstaff.meter.type === "specified") {
            this.measureLength = abcstaff.meter.value[0].num / abcstaff.meter.value[0].den;
          } else
            this.measureLength = 1;
          var ts = createTimeSignature(abcstaff.meter, this.tuneNumber);
          voice.addChild(ts);
          this.startlimitelem = ts;
        }
        if (voice.duplicate)
          voice.children = [];
        var staffLines = abcstaff.clef.stafflines || abcstaff.clef.stafflines === 0 ? abcstaff.clef.stafflines : 5;
        staffgroup.addVoice(voice, s, staffLines);
        var isSingleLineStaff = staffLines === 1;
        this.createABCVoice(abcstaff.voices[v], tempo, s, v, isSingleLineStaff, voice);
        staffgroup.setStaffLimits(voice);
        if (v === 0) {
          if (abcstaff.brace === "start" || !staffgroup.brace && abcstaff.brace) {
            if (!staffgroup.brace)
              staffgroup.brace = [];
            staffgroup.brace.push(new BraceElem(voice, "brace"));
          } else if (abcstaff.brace === "end" && staffgroup.brace) {
            staffgroup.brace[staffgroup.brace.length - 1].setBottomStaff(voice);
          } else if (abcstaff.brace === "continue" && staffgroup.brace) {
            staffgroup.brace[staffgroup.brace.length - 1].continuing(voice);
          }
          if (abcstaff.bracket === "start" || !staffgroup.bracket && abcstaff.bracket) {
            if (!staffgroup.bracket)
              staffgroup.bracket = [];
            staffgroup.bracket.push(new BraceElem(voice, "bracket"));
          } else if (abcstaff.bracket === "end" && staffgroup.bracket) {
            staffgroup.bracket[staffgroup.bracket.length - 1].setBottomStaff(voice);
          } else if (abcstaff.bracket === "continue" && staffgroup.bracket) {
            staffgroup.bracket[staffgroup.bracket.length - 1].continuing(voice);
          }
        }
      }
    };
    function getBeamGroup(abcline, pos) {
      var elem = abcline[pos];
      if (elem.el_type !== "note" || !elem.startBeam || elem.endBeam)
        return { count: 1, elem };
      var group = [];
      while (pos < abcline.length && abcline[pos].el_type === "note") {
        group.push(abcline[pos]);
        if (abcline[pos].endBeam)
          break;
        pos++;
      }
      return { count: group.length, elem: group };
    }
    AbstractEngraver.prototype.createABCVoice = function(abcline, tempo, s, v, isSingleLineStaff, voice) {
      this.popCrossLineElems(s, v);
      this.stemdir = this.isBagpipes ? "down" : null;
      this.abcline = abcline;
      if (this.partstartelem) {
        this.partstartelem = new EndingElem("", null, null);
        voice.addOther(this.partstartelem);
      }
      var voiceNumber = voice.voicetotal < 2 ? -1 : voice.voicenumber;
      for (var slur in this.slurs) {
        if (this.slurs.hasOwnProperty(slur)) {
          this.slurs[slur] = new TieElem({ force: this.slurs[slur].force, voiceNumber, stemDir: this.slurs[slur].stemDir, style: this.slurs[slur].dotted });
          if (hint)
            this.slurs[slur].setHint();
          voice.addOther(this.slurs[slur]);
        }
      }
      for (var i = 0; i < this.ties.length; i++) {
        this.ties[i] = new TieElem({ force: this.ties[i].force, stemDir: this.ties[i].stemDir, voiceNumber, style: this.ties[i].dotted });
        if (hint)
          this.ties[i].setHint();
        voice.addOther(this.ties[i]);
      }
      for (var j = 0; j < this.abcline.length; j++) {
        setAveragePitch(this.abcline[j]);
        this.minY = Math.min(this.abcline[j].minpitch, this.minY);
      }
      var isFirstStaff = s === 0;
      var pos = 0;
      while (pos < this.abcline.length) {
        var ret = getBeamGroup(this.abcline, pos);
        var abselems = this.createABCElement(isFirstStaff, isSingleLineStaff, voice, ret.elem);
        if (abselems) {
          for (i = 0; i < abselems.length; i++) {
            if (!this.tempoSet && tempo && !tempo.suppress) {
              this.tempoSet = true;
              var tempoElement = new AbsoluteElement(tempo, 0, 0, "tempo", this.tuneNumber, {});
              tempoElement.addFixedX(new TempoElement(tempo, this.tuneNumber, createNoteHead));
              voice.addChild(tempoElement);
            }
            voice.addChild(abselems[i]);
          }
        }
        pos += ret.count;
      }
      this.pushCrossLineElems(s, v);
    };
    AbstractEngraver.prototype.saveState = function() {
      this.tiesSave = parseCommon.cloneArray(this.ties);
      this.slursSave = parseCommon.cloneHashOfHash(this.slurs);
      this.slursbyvoiceSave = parseCommon.cloneHashOfHash(this.slursbyvoice);
      this.tiesbyvoiceSave = parseCommon.cloneHashOfArrayOfHash(this.tiesbyvoice);
    };
    AbstractEngraver.prototype.restoreState = function() {
      this.ties = parseCommon.cloneArray(this.tiesSave);
      this.slurs = parseCommon.cloneHashOfHash(this.slursSave);
      this.slursbyvoice = parseCommon.cloneHashOfHash(this.slursbyvoiceSave);
      this.tiesbyvoice = parseCommon.cloneHashOfArrayOfHash(this.tiesbyvoiceSave);
    };
    AbstractEngraver.prototype.createABCElement = function(isFirstStaff, isSingleLineStaff, voice, elem) {
      var elemset = [];
      switch (elem.el_type) {
        case void 0:
          elemset = this.createBeam(isSingleLineStaff, voice, elem);
          break;
        case "note":
          elemset[0] = this.createNote(elem, false, isSingleLineStaff, voice);
          if (this.triplet && this.triplet.isClosed()) {
            voice.addOther(this.triplet);
            this.triplet = null;
            this.tripletmultiplier = 1;
          }
          break;
        case "bar":
          elemset[0] = this.createBarLine(voice, elem, isFirstStaff);
          if (voice.duplicate && elemset.length > 0)
            elemset[0].invisible = true;
          break;
        case "meter":
          elemset[0] = createTimeSignature(elem, this.tuneNumber);
          this.startlimitelem = elemset[0];
          if (voice.duplicate && elemset.length > 0)
            elemset[0].invisible = true;
          break;
        case "clef":
          elemset[0] = createClef(elem, this.tuneNumber);
          if (!elemset[0])
            return null;
          if (voice.duplicate && elemset.length > 0)
            elemset[0].invisible = true;
          break;
        case "key":
          var absKey = createKeySignature(elem, this.tuneNumber);
          if (absKey) {
            elemset[0] = absKey;
            this.startlimitelem = elemset[0];
          }
          if (voice.duplicate && elemset.length > 0)
            elemset[0].invisible = true;
          break;
        case "stem":
          this.stemdir = elem.direction === "auto" ? void 0 : elem.direction;
          break;
        case "part":
          var abselem = new AbsoluteElement(elem, 0, 0, "part", this.tuneNumber);
          var dim = this.getTextSize.calc(elem.title, "partsfont", "part");
          abselem.addFixedX(new RelativeElement(elem.title, 0, 0, void 0, { type: "part", height: dim.height / spacing.STEP }));
          elemset[0] = abselem;
          break;
        case "tempo":
          var abselem3 = new AbsoluteElement(elem, 0, 0, "tempo", this.tuneNumber);
          abselem3.addFixedX(new TempoElement(elem, this.tuneNumber, createNoteHead));
          elemset[0] = abselem3;
          break;
        case "style":
          if (elem.head === "normal")
            delete this.style;
          else
            this.style = elem.head;
          break;
        case "hint":
          hint = true;
          this.saveState();
          break;
        case "midi":
          break;
        case "scale":
          this.voiceScale = elem.size;
          break;
        default:
          var abselem2 = new AbsoluteElement(elem, 0, 0, "unsupported", this.tuneNumber);
          abselem2.addFixed(new RelativeElement("element type " + elem.el_type, 0, 0, void 0, { type: "debug" }));
          elemset[0] = abselem2;
      }
      return elemset;
    };
    function setAveragePitch(elem) {
      if (elem.pitches) {
        sortPitch(elem);
        var sum = 0;
        for (var p = 0; p < elem.pitches.length; p++) {
          sum += elem.pitches[p].verticalPos;
        }
        elem.averagepitch = sum / elem.pitches.length;
        elem.minpitch = elem.pitches[0].verticalPos;
        elem.maxpitch = elem.pitches[elem.pitches.length - 1].verticalPos;
      }
    }
    AbstractEngraver.prototype.createBeam = function(isSingleLineStaff, voice, elems) {
      var abselemset = [];
      var beamelem = new BeamElem(this.stemHeight * this.voiceScale, this.stemdir, this.flatBeams, elems[0]);
      if (hint)
        beamelem.setHint();
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        var abselem = this.createNote(elem, true, isSingleLineStaff, voice);
        abselemset.push(abselem);
        beamelem.add(abselem);
        if (this.triplet && this.triplet.isClosed()) {
          voice.addOther(this.triplet);
          this.triplet = null;
          this.tripletmultiplier = 1;
        }
      }
      beamelem.calcDir();
      voice.addBeam(beamelem);
      return abselemset;
    };
    var sortPitch = function(elem) {
      var sorted;
      do {
        sorted = true;
        for (var p = 0; p < elem.pitches.length - 1; p++) {
          if (elem.pitches[p].pitch > elem.pitches[p + 1].pitch) {
            sorted = false;
            var tmp = elem.pitches[p];
            elem.pitches[p] = elem.pitches[p + 1];
            elem.pitches[p + 1] = tmp;
          }
        }
      } while (!sorted);
    };
    var ledgerLines = function(abselem, minPitch, maxPitch, isRest, symbolWidth, additionalLedgers, dir, dx, scale) {
      for (var i = maxPitch; i > 11; i--) {
        if (i % 2 === 0 && !isRest) {
          abselem.addFixed(new RelativeElement(null, dx, (symbolWidth + 4) * scale, i, { type: "ledger" }));
        }
      }
      for (i = minPitch; i < 1; i++) {
        if (i % 2 === 0 && !isRest) {
          abselem.addFixed(new RelativeElement(null, dx, (symbolWidth + 4) * scale, i, { type: "ledger" }));
        }
      }
      for (i = 0; i < additionalLedgers.length; i++) {
        var ofs = symbolWidth;
        if (dir === "down")
          ofs = -ofs;
        abselem.addFixed(new RelativeElement(null, ofs + dx, (symbolWidth + 4) * scale, additionalLedgers[i], { type: "ledger" }));
      }
    };
    AbstractEngraver.prototype.addGraceNotes = function(elem, voice, abselem, notehead, stemHeight, isBagpipes, roomtaken) {
      var gracescale = 3 / 5;
      var graceScaleStem = 3.5 / 5;
      stemHeight = Math.round(stemHeight * graceScaleStem);
      var gracebeam = null;
      var flag;
      if (elem.gracenotes.length > 1) {
        gracebeam = new BeamElem(stemHeight, "grace", isBagpipes);
        if (hint)
          gracebeam.setHint();
        gracebeam.mainNote = abselem;
      }
      var i;
      var graceoffsets = [];
      for (i = elem.gracenotes.length - 1; i >= 0; i--) {
        roomtaken += 10;
        graceoffsets[i] = roomtaken;
        if (elem.gracenotes[i].accidental) {
          roomtaken += 7;
        }
      }
      for (i = 0; i < elem.gracenotes.length; i++) {
        var gracepitch = elem.gracenotes[i].verticalPos;
        flag = gracebeam ? null : chartable.uflags[isBagpipes ? 5 : 3];
        var accidentalSlot = [];
        var ret = createNoteHead(abselem, "noteheads.quarter", elem.gracenotes[i], { dir: "up", headx: -graceoffsets[i], extrax: -graceoffsets[i], flag, scale: gracescale * this.voiceScale, accidentalSlot });
        ret.notehead.highestVert = ret.notehead.pitch + stemHeight;
        var grace = ret.notehead;
        this.addSlursAndTies(abselem, elem.gracenotes[i], grace, voice, "up", true);
        abselem.addExtra(grace);
        if (elem.gracenotes[i].acciaccatura) {
          var pos = elem.gracenotes[i].verticalPos + 7 * gracescale;
          var dAcciaccatura = gracebeam ? 5 : 6;
          abselem.addRight(new RelativeElement("flags.ugrace", -graceoffsets[i] + dAcciaccatura, 0, pos, { scalex: gracescale, scaley: gracescale }));
        }
        if (gracebeam) {
          var graceDuration = elem.gracenotes[i].duration / 2;
          if (isBagpipes)
            graceDuration /= 2;
          var pseudoabselem = {
            heads: [grace],
            abcelem: { averagepitch: gracepitch, minpitch: gracepitch, maxpitch: gracepitch, duration: graceDuration }
          };
          gracebeam.add(pseudoabselem);
        } else {
          var p1 = gracepitch + 1 / 3 * gracescale;
          var p2 = gracepitch + 7 * gracescale;
          var dx = grace.dx + grace.w;
          var width = -0.6;
          abselem.addExtra(new RelativeElement(null, dx, 0, p1, { "type": "stem", "pitch2": p2, linewidth: width }));
        }
        ledgerLines(abselem, gracepitch, gracepitch, false, glyphs.getSymbolWidth("noteheads.quarter"), [], true, grace.dx - 1, 0.6);
        var isInvisibleRest = elem.rest && (elem.rest.type === "spacer" || elem.rest.type === "invisible");
        if (i === 0 && !isBagpipes && this.graceSlurs && !isInvisibleRest) {
          voice.addOther(new TieElem({ anchor1: grace, anchor2: notehead, isGrace: true }));
        }
      }
      if (gracebeam) {
        gracebeam.calcDir();
        voice.addBeam(gracebeam);
      }
      return roomtaken;
    };
    function addRestToAbsElement(abselem, elem, duration, dot, isMultiVoice, stemdir, isSingleLineStaff, durlog, voiceScale) {
      var c;
      var restpitch = 7;
      var noteHead;
      var roomTaken;
      var roomTakenRight;
      if (isMultiVoice) {
        if (stemdir === "down")
          restpitch = 3;
        if (stemdir === "up")
          restpitch = 11;
      }
      if (isSingleLineStaff) {
        if (duration < 0.5)
          restpitch = 7;
        else if (duration < 1)
          restpitch = 7;
        else
          restpitch = 5;
      }
      switch (elem.rest.type) {
        case "whole":
          c = chartable.rest[0];
          elem.averagepitch = restpitch;
          elem.minpitch = restpitch;
          elem.maxpitch = restpitch;
          dot = 0;
          break;
        case "rest":
          if (elem.style === "rhythm")
            c = chartable.rhythm[-durlog];
          else
            c = chartable.rest[-durlog];
          elem.averagepitch = restpitch;
          elem.minpitch = restpitch;
          elem.maxpitch = restpitch;
          break;
        case "invisible":
        case "invisible-multimeasure":
        case "spacer":
          c = "";
          elem.averagepitch = restpitch;
          elem.minpitch = restpitch;
          elem.maxpitch = restpitch;
          break;
        case "multimeasure":
          c = chartable.rest["multi"];
          elem.averagepitch = restpitch;
          elem.minpitch = restpitch;
          elem.maxpitch = restpitch;
          dot = 0;
          var mmWidth = glyphs.getSymbolWidth(c);
          abselem.addHead(new RelativeElement(c, mmWidth, mmWidth * 2, 7));
          var numMeasures = new RelativeElement("" + elem.rest.text, mmWidth, mmWidth, 16, { type: "multimeasure-text" });
          abselem.addExtra(numMeasures);
      }
      if (elem.rest.type.indexOf("multimeasure") < 0 && elem.rest.type !== "invisible") {
        var ret = createNoteHead(abselem, c, { verticalPos: restpitch }, { dot, scale: voiceScale });
        noteHead = ret.notehead;
        if (noteHead) {
          abselem.addHead(noteHead);
          roomTaken = ret.accidentalshiftx;
          roomTakenRight = ret.dotshiftx;
        }
      }
      return { noteHead, roomTaken, roomTakenRight };
    }
    function addIfNotExist(arr, item) {
      for (var i = 0; i < arr.length; i++) {
        if (JSON.stringify(arr[i]) === JSON.stringify(item))
          return;
      }
      arr.push(item);
    }
    AbstractEngraver.prototype.addNoteToAbcElement = function(abselem, elem, dot, stemdir, style, zeroDuration, durlog, nostem, voice) {
      var dotshiftx = 0;
      var noteHead;
      var roomTaken = 0;
      var roomTakenRight = 0;
      var min;
      var i;
      var additionalLedgers = [];
      var accidentalSlot = [];
      var symbolWidth = 0;
      var dir = elem.averagepitch >= 6 ? "down" : "up";
      if (stemdir)
        dir = stemdir;
      style = elem.style ? elem.style : style;
      if (!style || style === "normal")
        style = "note";
      var noteSymbol;
      if (zeroDuration)
        noteSymbol = chartable[style].nostem;
      else
        noteSymbol = chartable[style][-durlog];
      if (!noteSymbol)
        console.log("noteSymbol:", style, durlog, zeroDuration);
      var p;
      for (p = dir === "down" ? elem.pitches.length - 2 : 1; dir === "down" ? p >= 0 : p < elem.pitches.length; p = dir === "down" ? p - 1 : p + 1) {
        var prev = elem.pitches[dir === "down" ? p + 1 : p - 1];
        var curr = elem.pitches[p];
        var delta = dir === "down" ? prev.pitch - curr.pitch : curr.pitch - prev.pitch;
        if (delta <= 1 && !prev.printer_shift) {
          curr.printer_shift = delta ? "different" : "same";
          if (curr.verticalPos > 11 || curr.verticalPos < 1) {
            additionalLedgers.push(curr.verticalPos - curr.verticalPos % 2);
          }
          if (dir === "down") {
            roomTaken = glyphs.getSymbolWidth(noteSymbol) + 2;
          } else {
            dotshiftx = glyphs.getSymbolWidth(noteSymbol) + 2;
          }
        }
      }
      var pp = elem.pitches.length;
      for (p = 0; p < elem.pitches.length; p++) {
        if (!nostem) {
          var flag;
          if (dir === "down" && p !== 0 || dir === "up" && p !== pp - 1) {
            flag = null;
          } else {
            flag = chartable[dir === "down" ? "dflags" : "uflags"][-durlog];
          }
        }
        var c;
        if (elem.pitches[p].style) {
          c = chartable[elem.pitches[p].style][-durlog];
        } else if (voice.isPercussion && this.percmap) {
          c = noteSymbol;
          var percHead = this.percmap[pitchesToPerc(elem.pitches[p])];
          if (percHead && percHead.noteHead) {
            if (chartable[percHead.noteHead])
              c = chartable[percHead.noteHead][-durlog];
          }
        } else
          c = noteSymbol;
        elem.pitches[p].highestVert = elem.pitches[p].verticalPos;
        var isTopWhenStemIsDown = (stemdir === "up" || dir === "up") && p === 0;
        var isBottomWhenStemIsUp = (stemdir === "down" || dir === "down") && p === pp - 1;
        if (isTopWhenStemIsDown || isBottomWhenStemIsUp) {
          if (elem.startSlur || pp === 1) {
            elem.pitches[p].highestVert = elem.pitches[pp - 1].verticalPos;
            if (getDuration(elem) < 1 && (stemdir === "up" || dir === "up"))
              elem.pitches[p].highestVert += 6;
          }
          if (elem.startSlur) {
            if (!elem.pitches[p].startSlur)
              elem.pitches[p].startSlur = [];
            for (i = 0; i < elem.startSlur.length; i++) {
              addIfNotExist(elem.pitches[p].startSlur, elem.startSlur[i]);
            }
          }
          if (elem.endSlur) {
            elem.pitches[p].highestVert = elem.pitches[pp - 1].verticalPos;
            if (getDuration(elem) < 1 && (stemdir === "up" || dir === "up"))
              elem.pitches[p].highestVert += 6;
            if (!elem.pitches[p].endSlur)
              elem.pitches[p].endSlur = [];
            for (i = 0; i < elem.endSlur.length; i++) {
              addIfNotExist(elem.pitches[p].endSlur, elem.endSlur[i]);
            }
          }
        }
        var hasStem = !nostem && durlog <= -1;
        var ret = createNoteHead(abselem, c, elem.pitches[p], { dir, extrax: -roomTaken, flag, dot, dotshiftx, scale: this.voiceScale, accidentalSlot, shouldExtendStem: !stemdir, printAccidentals: !voice.isPercussion });
        symbolWidth = Math.max(glyphs.getSymbolWidth(c), symbolWidth);
        abselem.extraw -= ret.extraLeft;
        noteHead = ret.notehead;
        if (noteHead) {
          this.addSlursAndTies(abselem, elem.pitches[p], noteHead, voice, hasStem ? dir : null, false);
          if (elem.gracenotes && elem.gracenotes.length > 0)
            noteHead.bottom = noteHead.bottom - 1;
          abselem.addHead(noteHead);
        }
        roomTaken += ret.accidentalshiftx;
        roomTakenRight = Math.max(roomTakenRight, ret.dotshiftx);
      }
      if (hasStem) {
        var stemHeight = Math.round(70 * this.voiceScale) / 10;
        var p1 = dir === "down" ? elem.minpitch - stemHeight : elem.minpitch + 1 / 3;
        if (p1 > 6 && !stemdir)
          p1 = 6;
        var p2 = dir === "down" ? elem.maxpitch - 1 / 3 : elem.maxpitch + stemHeight;
        if (p2 < 6 && !stemdir)
          p2 = 6;
        var dx = dir === "down" || abselem.heads.length === 0 ? 0 : abselem.heads[0].w;
        var width = dir === "down" ? 1 : -1;
        if (noteHead && noteHead.c === "noteheads.slash.quarter") {
          if (dir === "down")
            p2 -= 1;
          else
            p1 += 1;
        }
        abselem.addRight(new RelativeElement(null, dx, 0, p1, { "type": "stem", "pitch2": p2, linewidth: width, bottom: p1 - 1 }));
        min = Math.min(p1, p2);
      }
      return { noteHead, roomTaken, roomTakenRight, min, additionalLedgers, dir, symbolWidth };
    };
    AbstractEngraver.prototype.addLyric = function(abselem, elem) {
      var lyricStr = "";
      parseCommon.each(elem.lyric, function(ly) {
        var div = ly.divider === " " ? "" : ly.divider;
        lyricStr += ly.syllable + div + "\n";
      });
      var lyricDim = this.getTextSize.calc(lyricStr, "vocalfont", "lyric");
      var position = elem.positioning ? elem.positioning.vocalPosition : "below";
      abselem.addCentered(new RelativeElement(lyricStr, 0, lyricDim.width, void 0, { type: "lyric", position, height: lyricDim.height / spacing.STEP, dim: this.getTextSize.attr("vocalfont", "lyric") }));
    };
    AbstractEngraver.prototype.createNote = function(elem, nostem, isSingleLineStaff, voice) {
      var notehead = null;
      var roomtaken = 0;
      var roomtakenright = 0;
      var symbolWidth = 0;
      var additionalLedgers = [];
      var dir;
      var duration = getDuration(elem);
      var zeroDuration = false;
      if (duration === 0) {
        zeroDuration = true;
        duration = 0.25;
        nostem = true;
      }
      var durlog = Math.floor(Math.log(duration) / Math.log(2));
      var dot = 0;
      for (var tot = Math.pow(2, durlog), inc = tot / 2; tot < duration; dot++, tot += inc, inc /= 2)
        ;
      if (elem.startTriplet) {
        this.tripletmultiplier = elem.tripletMultiplier;
      }
      var durationForSpacing = duration * this.tripletmultiplier;
      if (elem.rest && elem.rest.type === "multimeasure")
        durationForSpacing = 1;
      if (elem.rest && elem.rest.type === "invisible-multimeasure")
        durationForSpacing = this.measureLength * elem.rest.text;
      var absType = elem.rest ? "rest" : "note";
      var abselem = new AbsoluteElement(elem, durationForSpacing, 1, absType, this.tuneNumber, { durationClassOveride: elem.duration * this.tripletmultiplier });
      if (hint)
        abselem.setHint();
      if (elem.rest) {
        if (this.measureLength === duration && elem.rest.type !== "invisible" && elem.rest.type !== "spacer" && elem.rest.type.indexOf("multimeasure") < 0)
          elem.rest.type = "whole";
        var ret1 = addRestToAbsElement(abselem, elem, duration, dot, voice.voicetotal > 1, this.stemdir, isSingleLineStaff, durlog, this.voiceScale);
        notehead = ret1.noteHead;
        roomtaken = ret1.roomTaken;
        roomtakenright = ret1.roomTakenRight;
      } else {
        var ret2 = this.addNoteToAbcElement(abselem, elem, dot, this.stemdir, this.style, zeroDuration, durlog, nostem, voice);
        if (ret2.min !== void 0)
          this.minY = Math.min(ret2.min, this.minY);
        notehead = ret2.noteHead;
        roomtaken = ret2.roomTaken;
        roomtakenright = ret2.roomTakenRight;
        additionalLedgers = ret2.additionalLedgers;
        dir = ret2.dir;
        symbolWidth = ret2.symbolWidth;
      }
      if (elem.lyric !== void 0) {
        this.addLyric(abselem, elem);
      }
      if (elem.gracenotes !== void 0) {
        roomtaken += this.addGraceNotes(elem, voice, abselem, notehead, this.stemHeight * this.voiceScale, this.isBagpipes, roomtaken);
      }
      if (elem.decoration) {
        this.decoration.createDecoration(voice, elem.decoration, abselem.top, notehead ? notehead.w : 0, abselem, roomtaken, dir, abselem.bottom, elem.positioning, this.hasVocals);
      }
      if (elem.barNumber) {
        abselem.addFixed(new RelativeElement(elem.barNumber, -10, 0, 0, { type: "barNumber" }));
      }
      ledgerLines(abselem, elem.minpitch, elem.maxpitch, elem.rest, symbolWidth, additionalLedgers, dir, -2, 1);
      if (elem.chord !== void 0) {
        var ret3 = addChord(this.getTextSize, abselem, elem, roomtaken, roomtakenright, symbolWidth, this.jazzchords);
        roomtaken = ret3.roomTaken;
        roomtakenright = ret3.roomTakenRight;
      }
      if (elem.startTriplet) {
        this.triplet = new TripletElem(elem.startTriplet, notehead, { flatBeams: this.flatBeams });
      }
      if (elem.endTriplet && this.triplet) {
        this.triplet.setCloseAnchor(notehead);
      }
      if (this.triplet && !elem.startTriplet && !elem.endTriplet && !(elem.rest && elem.rest.type === "spacer")) {
        this.triplet.middleNote(notehead);
      }
      return abselem;
    };
    AbstractEngraver.prototype.addSlursAndTies = function(abselem, pitchelem, notehead, voice, dir, isGrace) {
      if (pitchelem.endTie) {
        if (this.ties.length > 0) {
          var found = false;
          for (var j = 0; j < this.ties.length; j++) {
            if (this.ties[j].anchor1 && this.ties[j].anchor1.pitch === notehead.pitch) {
              this.ties[j].setEndAnchor(notehead);
              this.ties.splice(j, 1);
              found = true;
              break;
            }
          }
          if (!found) {
            this.ties[0].setEndAnchor(notehead);
            this.ties.splice(0, 1);
          }
        }
      }
      var voiceNumber = voice.voicetotal < 2 ? -1 : voice.voicenumber;
      if (pitchelem.startTie) {
        var tie = new TieElem({ anchor1: notehead, force: this.stemdir === "down" || this.stemdir === "up", stemDir: this.stemdir, isGrace, voiceNumber, style: pitchelem.startTie.style });
        if (hint)
          tie.setHint();
        this.ties[this.ties.length] = tie;
        voice.addOther(tie);
        abselem.startTie = true;
      }
      var slur;
      var slurid;
      if (pitchelem.endSlur) {
        for (var i = 0; i < pitchelem.endSlur.length; i++) {
          slurid = pitchelem.endSlur[i];
          if (this.slurs[slurid]) {
            slur = this.slurs[slurid];
            slur.setEndAnchor(notehead);
            delete this.slurs[slurid];
          } else {
            slur = new TieElem({ anchor2: notehead, stemDir: this.stemdir, voiceNumber });
            if (hint)
              slur.setHint();
            voice.addOther(slur);
          }
          if (this.startlimitelem) {
            slur.setStartX(this.startlimitelem);
          }
        }
      } else if (!isGrace) {
        for (var s in this.slurs) {
          if (this.slurs.hasOwnProperty(s)) {
            this.slurs[s].addInternalNote(notehead);
          }
        }
      }
      if (pitchelem.startSlur) {
        for (i = 0; i < pitchelem.startSlur.length; i++) {
          slurid = pitchelem.startSlur[i].label;
          slur = new TieElem({ anchor1: notehead, stemDir: this.stemdir, voiceNumber, style: pitchelem.startSlur[i].style });
          if (hint)
            slur.setHint();
          this.slurs[slurid] = slur;
          voice.addOther(slur);
        }
      }
    };
    AbstractEngraver.prototype.addMeasureNumber = function(number, abselem) {
      var measureNumDim = this.getTextSize.calc(number, "measurefont", "bar-number");
      var dx = measureNumDim.width > 18 && abselem.abcelem.type === "treble" ? -7 : 0;
      abselem.addFixed(new RelativeElement(number, dx, measureNumDim.width, 11 + measureNumDim.height / spacing.STEP, { type: "barNumber", dim: this.getTextSize.attr("measurefont", "bar-number") }));
    };
    AbstractEngraver.prototype.createBarLine = function(voice, elem, isFirstStaff) {
      var abselem = new AbsoluteElement(elem, 0, 10, "bar", this.tuneNumber);
      var anchor = null;
      var dx = 0;
      if (elem.barNumber) {
        this.addMeasureNumber(elem.barNumber, abselem);
      }
      var firstdots = elem.type === "bar_right_repeat" || elem.type === "bar_dbl_repeat";
      var firstthin = elem.type !== "bar_left_repeat" && elem.type !== "bar_thick_thin" && elem.type !== "bar_invisible";
      var thick = elem.type === "bar_right_repeat" || elem.type === "bar_dbl_repeat" || elem.type === "bar_left_repeat" || elem.type === "bar_thin_thick" || elem.type === "bar_thick_thin";
      var secondthin = elem.type === "bar_left_repeat" || elem.type === "bar_thick_thin" || elem.type === "bar_thin_thin" || elem.type === "bar_dbl_repeat";
      var seconddots = elem.type === "bar_left_repeat" || elem.type === "bar_dbl_repeat";
      if (firstdots || seconddots) {
        for (var slur in this.slurs) {
          if (this.slurs.hasOwnProperty(slur)) {
            this.slurs[slur].setEndX(abselem);
          }
        }
        this.startlimitelem = abselem;
      }
      if (firstdots) {
        abselem.addRight(new RelativeElement("dots.dot", dx, 1, 7));
        abselem.addRight(new RelativeElement("dots.dot", dx, 1, 5));
        dx += 6;
      }
      if (firstthin) {
        anchor = new RelativeElement(null, dx, 1, 2, { "type": "bar", "pitch2": 10, linewidth: 0.6 });
        abselem.addRight(anchor);
      }
      if (elem.type === "bar_invisible") {
        anchor = new RelativeElement(null, dx, 1, 2, { "type": "none", "pitch2": 10, linewidth: 0.6 });
        abselem.addRight(anchor);
      }
      if (elem.decoration) {
        this.decoration.createDecoration(voice, elem.decoration, 12, thick ? 3 : 1, abselem, 0, "down", 2, elem.positioning, this.hasVocals);
      }
      if (thick) {
        dx += 4;
        anchor = new RelativeElement(null, dx, 4, 2, { "type": "bar", "pitch2": 10, linewidth: 4 });
        abselem.addRight(anchor);
        dx += 5;
      }
      if (this.partstartelem && elem.endEnding) {
        this.partstartelem.anchor2 = anchor;
        this.partstartelem = null;
      }
      if (secondthin) {
        dx += 3;
        anchor = new RelativeElement(null, dx, 1, 2, { "type": "bar", "pitch2": 10, linewidth: 0.6 });
        abselem.addRight(anchor);
      }
      if (seconddots) {
        dx += 3;
        abselem.addRight(new RelativeElement("dots.dot", dx, 1, 7));
        abselem.addRight(new RelativeElement("dots.dot", dx, 1, 5));
      }
      if (elem.startEnding && isFirstStaff) {
        var textWidth = this.getTextSize.calc(elem.startEnding, "repeatfont", "").width;
        abselem.minspacing += textWidth + 10;
        this.partstartelem = new EndingElem(elem.startEnding, anchor, null);
        voice.addOther(this.partstartelem);
      }
      abselem.extraw -= 5;
      return abselem;
    };
    module.exports = AbstractEngraver;
  }
});

// node_modules/abcjs/src/write/svg.js
var require_svg = __commonJS({
  "node_modules/abcjs/src/write/svg.js"(exports, module) {
    var svgNS = "http://www.w3.org/2000/svg";
    function Svg(wrapper) {
      this.svg = createSvg();
      this.currentGroup = [];
      wrapper.appendChild(this.svg);
    }
    Svg.prototype.clear = function() {
      if (this.svg) {
        var wrapper = this.svg.parentNode;
        this.svg = createSvg();
        this.currentGroup = [];
        if (wrapper) {
          wrapper.innerHTML = "";
          wrapper.appendChild(this.svg);
        }
      }
    };
    Svg.prototype.setTitle = function(title) {
      var titleEl = document.createElement("title");
      var titleNode = document.createTextNode(title);
      titleEl.appendChild(titleNode);
      this.svg.insertBefore(titleEl, this.svg.firstChild);
    };
    Svg.prototype.setResponsiveWidth = function(w, h) {
      this.svg.setAttribute("viewBox", "0 0 " + w + " " + h);
      this.svg.setAttribute("preserveAspectRatio", "xMinYMin meet");
      this.svg.removeAttribute("height");
      this.svg.removeAttribute("width");
      this.svg.style["display"] = "inline-block";
      this.svg.style["position"] = "absolute";
      this.svg.style["top"] = "0";
      this.svg.style["left"] = "0";
      if (this.svg.parentNode) {
        var cls = this.svg.parentNode.getAttribute("class");
        if (!cls)
          this.svg.parentNode.setAttribute("class", "abcjs-container");
        else if (cls.indexOf("abcjs-container") < 0)
          this.svg.parentNode.setAttribute("class", cls + " abcjs-container");
        this.svg.parentNode.style["display"] = "inline-block";
        this.svg.parentNode.style["position"] = "relative";
        this.svg.parentNode.style["width"] = "100%";
        var padding = h / w * 100;
        this.svg.parentNode.style["padding-bottom"] = padding + "%";
        this.svg.parentNode.style["vertical-align"] = "middle";
        this.svg.parentNode.style["overflow"] = "hidden";
      }
    };
    Svg.prototype.setSize = function(w, h) {
      this.svg.setAttribute("width", w);
      this.svg.setAttribute("height", h);
    };
    Svg.prototype.setAttribute = function(attr, value) {
      this.svg.setAttribute(attr, value);
    };
    Svg.prototype.setScale = function(scale) {
      if (scale !== 1) {
        this.svg.style.transform = "scale(" + scale + "," + scale + ")";
        this.svg.style["-ms-transform"] = "scale(" + scale + "," + scale + ")";
        this.svg.style["-webkit-transform"] = "scale(" + scale + "," + scale + ")";
        this.svg.style["transform-origin"] = "0 0";
        this.svg.style["-ms-transform-origin-x"] = "0";
        this.svg.style["-ms-transform-origin-y"] = "0";
        this.svg.style["-webkit-transform-origin-x"] = "0";
        this.svg.style["-webkit-transform-origin-y"] = "0";
      } else {
        this.svg.style.transform = "";
        this.svg.style["-ms-transform"] = "";
        this.svg.style["-webkit-transform"] = "";
      }
    };
    Svg.prototype.insertStyles = function(styles) {
      var el = document.createElementNS(svgNS, "style");
      el.textContent = styles;
      this.svg.insertBefore(el, this.svg.firstChild);
    };
    Svg.prototype.setParentStyles = function(attr) {
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          if (this.svg.parentNode)
            this.svg.parentNode.style[key] = attr[key];
        }
      }
      if (this.dummySvg) {
        var body = document.querySelector("body");
        body.removeChild(this.dummySvg);
        this.dummySvg = null;
      }
    };
    function constructHLine(x1, y1, x2) {
      var len = x2 - x1;
      return "M " + x1 + " " + y1 + " l " + len + " " + 0 + " l " + 0 + " " + 1 + "  l " + -len + " " + 0 + "  z ";
    }
    function constructVLine(x1, y1, y2) {
      var len = y2 - y1;
      return "M " + x1 + " " + y1 + " l " + 0 + " " + len + " l " + 1 + " " + 0 + "  l " + 0 + " " + -len + "  z ";
    }
    Svg.prototype.rect = function(attr) {
      var lines = [];
      var x1 = attr.x;
      var y1 = attr.y;
      var x2 = attr.x + attr.width;
      var y2 = attr.y + attr.height;
      lines.push(constructHLine(x1, y1, x2));
      lines.push(constructHLine(x1, y2, x2));
      lines.push(constructVLine(x2, y1, y2));
      lines.push(constructVLine(x1, y2, y1));
      return this.path({ path: lines.join(" "), stroke: "none", "data-name": attr["data-name"] });
    };
    Svg.prototype.dottedLine = function(attr) {
      var el = document.createElementNS(svgNS, "line");
      el.setAttribute("x1", attr.x1);
      el.setAttribute("x2", attr.x2);
      el.setAttribute("y1", attr.y1);
      el.setAttribute("y2", attr.y2);
      el.setAttribute("stroke", attr.stroke);
      el.setAttribute("stroke-dasharray", "5,5");
      this.svg.insertBefore(el, this.svg.firstChild);
    };
    Svg.prototype.rectBeneath = function(attr) {
      var el = document.createElementNS(svgNS, "rect");
      el.setAttribute("x", attr.x);
      el.setAttribute("width", attr.width);
      el.setAttribute("y", attr.y);
      el.setAttribute("height", attr.height);
      if (attr.stroke)
        el.setAttribute("stroke", attr.stroke);
      if (attr["stroke-opacity"])
        el.setAttribute("stroke-opacity", attr["stroke-opacity"]);
      if (attr.fill)
        el.setAttribute("fill", attr.fill);
      if (attr["fill-opacity"])
        el.setAttribute("fill-opacity", attr["fill-opacity"]);
      this.svg.insertBefore(el, this.svg.firstChild);
    };
    Svg.prototype.text = function(text, attr, target) {
      var el = document.createElementNS(svgNS, "text");
      el.setAttribute("stroke", "none");
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          el.setAttribute(key, attr[key]);
        }
      }
      var lines = ("" + text).split("\n");
      for (var i = 0; i < lines.length; i++) {
        var line = document.createElementNS(svgNS, "tspan");
        line.setAttribute("x", attr.x ? attr.x : 0);
        if (i !== 0)
          line.setAttribute("dy", "1.2em");
        if (lines[i].indexOf("") !== -1) {
          var parts = lines[i].split("");
          line.textContent = parts[0];
          if (parts[1]) {
            var ts2 = document.createElementNS(svgNS, "tspan");
            ts2.setAttribute("dy", "-0.3em");
            ts2.setAttribute("style", "font-size:0.7em");
            ts2.textContent = parts[1];
            line.appendChild(ts2);
          }
          if (parts[2]) {
            var dist = parts[1] ? "0.4em" : "0.1em";
            var ts3 = document.createElementNS(svgNS, "tspan");
            ts3.setAttribute("dy", dist);
            ts3.setAttribute("style", "font-size:0.7em");
            ts3.textContent = parts[2];
            line.appendChild(ts3);
          }
        } else
          line.textContent = lines[i];
        el.appendChild(line);
      }
      if (target)
        target.appendChild(el);
      else
        this.append(el);
      return el;
    };
    Svg.prototype.guessWidth = function(text, attr) {
      var svg = this.createDummySvg();
      var el = this.text(text, attr, svg);
      var size;
      try {
        size = el.getBBox();
        if (isNaN(size.height) || !size.height)
          size = { width: attr["font-size"] / 2, height: attr["font-size"] + 2 };
        else
          size = { width: size.width, height: size.height };
      } catch (ex) {
        size = { width: attr["font-size"] / 2, height: attr["font-size"] + 2 };
      }
      svg.removeChild(el);
      return size;
    };
    Svg.prototype.createDummySvg = function() {
      if (!this.dummySvg) {
        this.dummySvg = createSvg();
        var styles = [
          "display: block !important;",
          "height: 1px;",
          "width: 1px;",
          "position: absolute;"
        ];
        this.dummySvg.setAttribute("style", styles.join(""));
        var body = document.querySelector("body");
        body.appendChild(this.dummySvg);
      }
      return this.dummySvg;
    };
    var sizeCache = {};
    Svg.prototype.getTextSize = function(text, attr, el) {
      if (typeof text === "number")
        text = "" + text;
      if (!text || text.match(/^\s+$/))
        return { width: 0, height: 0 };
      var key;
      if (text.length < 20) {
        key = text + JSON.stringify(attr);
        if (sizeCache[key])
          return sizeCache[key];
      }
      var removeLater = !el;
      if (!el)
        el = this.text(text, attr);
      var size;
      try {
        size = el.getBBox();
        if (isNaN(size.height) || !size.height)
          size = this.guessWidth(text, attr);
        else
          size = { width: size.width, height: size.height };
      } catch (ex) {
        size = this.guessWidth(text, attr);
      }
      if (removeLater) {
        if (this.currentGroup.length > 0)
          this.currentGroup[0].removeChild(el);
        else
          this.svg.removeChild(el);
      }
      if (key)
        sizeCache[key] = size;
      return size;
    };
    Svg.prototype.openGroup = function(options) {
      options = options ? options : {};
      var el = document.createElementNS(svgNS, "g");
      if (options.klass)
        el.setAttribute("class", options.klass);
      if (options.fill)
        el.setAttribute("fill", options.fill);
      if (options.stroke)
        el.setAttribute("stroke", options.stroke);
      if (options["data-name"])
        el.setAttribute("data-name", options["data-name"]);
      if (options.prepend)
        this.prepend(el);
      else
        this.append(el);
      this.currentGroup.unshift(el);
      return el;
    };
    Svg.prototype.closeGroup = function() {
      var g = this.currentGroup.shift();
      if (g && g.children.length === 0) {
        this.svg.removeChild(g);
        return null;
      }
      return g;
    };
    Svg.prototype.path = function(attr) {
      var el = document.createElementNS(svgNS, "path");
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          if (key === "path")
            el.setAttributeNS(null, "d", attr.path);
          else if (key === "klass")
            el.setAttributeNS(null, "class", attr[key]);
          else if (attr[key] !== void 0)
            el.setAttributeNS(null, key, attr[key]);
        }
      }
      this.append(el);
      return el;
    };
    Svg.prototype.pathToBack = function(attr) {
      var el = document.createElementNS(svgNS, "path");
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          if (key === "path")
            el.setAttributeNS(null, "d", attr.path);
          else if (key === "klass")
            el.setAttributeNS(null, "class", attr[key]);
          else
            el.setAttributeNS(null, key, attr[key]);
        }
      }
      this.prepend(el);
      return el;
    };
    Svg.prototype.append = function(el) {
      if (this.currentGroup.length > 0)
        this.currentGroup[0].appendChild(el);
      else
        this.svg.appendChild(el);
    };
    Svg.prototype.prepend = function(el) {
      if (this.currentGroup.length > 0)
        this.currentGroup[0].appendChild(el);
      else
        this.svg.insertBefore(el, this.svg.firstChild);
    };
    Svg.prototype.setAttributeOnElement = function(el, attr) {
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          el.setAttributeNS(null, key, attr[key]);
        }
      }
    };
    Svg.prototype.moveElementToChild = function(parent, child) {
      parent.appendChild(child);
    };
    function createSvg() {
      var svg = document.createElementNS(svgNS, "svg");
      svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
      svg.setAttribute("role", "img");
      svg.setAttribute("fill", "currentColor");
      svg.setAttribute("stroke", "currentColor");
      return svg;
    }
    module.exports = Svg;
  }
});

// node_modules/abcjs/src/write/abc_renderer.js
var require_abc_renderer = __commonJS({
  "node_modules/abcjs/src/write/abc_renderer.js"(exports, module) {
    var spacing = require_abc_spacing();
    var Svg = require_svg();
    var Renderer = function(paper) {
      this.paper = new Svg(paper);
      this.controller = null;
      this.space = 3 * spacing.SPACE;
      this.padding = {};
      this.reset();
    };
    Renderer.prototype.reset = function() {
      this.paper.clear();
      this.y = 0;
      this.abctune = null;
      this.path = null;
      this.isPrint = false;
      this.initVerticalSpace();
    };
    Renderer.prototype.newTune = function(abcTune) {
      this.abctune = abcTune;
      this.setVerticalSpace(abcTune.formatting);
      this.isPrint = abcTune.media === "print";
      this.setPadding(abcTune);
    };
    Renderer.prototype.setPaddingOverride = function(params) {
      this.paddingOverride = {
        top: params.paddingtop,
        bottom: params.paddingbottom,
        right: params.paddingright,
        left: params.paddingleft
      };
    };
    Renderer.prototype.setPadding = function(abctune) {
      function setPaddingVariable(self, paddingKey, formattingKey, printDefault, screenDefault) {
        if (abctune.formatting[formattingKey] !== void 0)
          self.padding[paddingKey] = abctune.formatting[formattingKey];
        else if (self.paddingOverride[paddingKey] !== void 0)
          self.padding[paddingKey] = self.paddingOverride[paddingKey];
        else if (self.isPrint)
          self.padding[paddingKey] = printDefault;
        else
          self.padding[paddingKey] = screenDefault;
      }
      setPaddingVariable(this, "top", "topmargin", 38, 15);
      setPaddingVariable(this, "bottom", "botmargin", 38, 15);
      setPaddingVariable(this, "left", "leftmargin", 68, 15);
      setPaddingVariable(this, "right", "rightmargin", 68, 15);
    };
    Renderer.prototype.adjustNonScaledItems = function(scale) {
      this.padding.top /= scale;
      this.padding.bottom /= scale;
      this.padding.left /= scale;
      this.padding.right /= scale;
      this.abctune.formatting.headerfont.size /= scale;
      this.abctune.formatting.footerfont.size /= scale;
    };
    Renderer.prototype.initVerticalSpace = function() {
      this.spacing = {
        composer: 7.56,
        graceBefore: 8.67,
        graceInside: 10.67,
        graceAfter: 16,
        info: 0,
        lineSkipFactor: 1.1,
        music: 7.56,
        paragraphSkipFactor: 0.4,
        parts: 11.33,
        slurHeight: 1,
        staffSeparation: 61.33,
        stemHeight: 26.67 + 10,
        subtitle: 3.78,
        systemStaffSeparation: 48,
        text: 18.9,
        title: 7.56,
        top: 30.24,
        vocal: 0,
        words: 0
      };
    };
    Renderer.prototype.setVerticalSpace = function(formatting) {
      if (formatting.staffsep !== void 0)
        this.spacing.staffSeparation = formatting.staffsep * 4 / 3;
      if (formatting.composerspace !== void 0)
        this.spacing.composer = formatting.composerspace * 4 / 3;
      if (formatting.partsspace !== void 0)
        this.spacing.parts = formatting.partsspace * 4 / 3;
      if (formatting.textspace !== void 0)
        this.spacing.text = formatting.textspace * 4 / 3;
      if (formatting.musicspace !== void 0)
        this.spacing.music = formatting.musicspace * 4 / 3;
      if (formatting.titlespace !== void 0)
        this.spacing.title = formatting.titlespace * 4 / 3;
      if (formatting.sysstaffsep !== void 0)
        this.spacing.systemStaffSeparation = formatting.sysstaffsep * 4 / 3;
      if (formatting.subtitlespace !== void 0)
        this.spacing.subtitle = formatting.subtitlespace * 4 / 3;
      if (formatting.topspace !== void 0)
        this.spacing.top = formatting.topspace * 4 / 3;
      if (formatting.vocalspace !== void 0)
        this.spacing.vocal = formatting.vocalspace * 4 / 3;
      if (formatting.wordsspace !== void 0)
        this.spacing.words = formatting.wordsspace * 4 / 3;
    };
    Renderer.prototype.calcY = function(ofs) {
      return this.y - ofs * spacing.STEP;
    };
    Renderer.prototype.moveY = function(em, numLines) {
      if (numLines === void 0)
        numLines = 1;
      this.y += em * numLines;
    };
    Renderer.prototype.absolutemoveY = function(y) {
      this.y = y;
    };
    module.exports = Renderer;
  }
});

// node_modules/abcjs/src/write/free-text.js
var require_free_text = __commonJS({
  "node_modules/abcjs/src/write/free-text.js"(exports, module) {
    function FreeText(info, vskip, getFontAndAttr, paddingLeft, width, getTextSize) {
      var text = info.text;
      this.rows = [];
      var size;
      if (vskip)
        this.rows.push({ move: vskip });
      var hash = getFontAndAttr.calc("textfont", "defined-text");
      if (text === "") {
        this.rows.push({ move: hash.attr["font-size"] * 2 });
      } else if (typeof text === "string") {
        this.rows.push({ move: hash.attr["font-size"] / 2 });
        this.rows.push({ left: paddingLeft, text, font: "textfont", klass: "defined-text", anchor: "start", startChar: info.startChar, endChar: info.endChar, absElemType: "freeText", name: "free-text" });
        size = getTextSize.calc(text, "textfont", "defined-text");
        this.rows.push({ move: size.height });
      } else if (text) {
        var maxHeight = 0;
        var leftSide = paddingLeft;
        var currentFont = "textfont";
        for (var i = 0; i < text.length; i++) {
          if (text[i].font) {
            currentFont = text[i].font;
          } else
            currentFont = "textfont";
          this.rows.push({ left: leftSide, text: text[i].text, font: currentFont, klass: "defined-text", anchor: "start", startChar: info.startChar, endChar: info.endChar, absElemType: "freeText", name: "free-text" });
          size = getTextSize.calc(text[i].text, getFontAndAttr.calc(currentFont, "defined-text").font, "defined-text");
          leftSide += size.width + size.height / 2;
          maxHeight = Math.max(maxHeight, size.height);
        }
        this.rows.push({ move: maxHeight });
      } else {
        if (info.length === 1) {
          var x = width / 2;
          this.rows.push({ left: x, text: info[0].text, font: "textfont", klass: "defined-text", anchor: "middle", startChar: info.startChar, endChar: info.endChar, absElemType: "freeText", name: "free-text" });
          size = getTextSize.calc(info[0].text, "textfont", "defined-text");
          this.rows.push({ move: size.height });
        }
      }
    }
    module.exports = FreeText;
  }
});

// node_modules/abcjs/src/write/separator.js
var require_separator = __commonJS({
  "node_modules/abcjs/src/write/separator.js"(exports, module) {
    function Separator(spaceAbove, lineLength, spaceBelow) {
      this.rows = [];
      if (spaceAbove)
        this.rows.push({ move: spaceAbove });
      this.rows.push({ separator: lineLength, absElemType: "separator" });
      if (spaceBelow)
        this.rows.push({ move: spaceBelow });
    }
    module.exports = Separator;
  }
});

// node_modules/abcjs/src/write/subtitle.js
var require_subtitle = __commonJS({
  "node_modules/abcjs/src/write/subtitle.js"(exports, module) {
    function Subtitle(spaceAbove, formatting, info, center, paddingLeft, getTextSize) {
      this.rows = [];
      if (spaceAbove)
        this.rows.push({ move: spaceAbove });
      var tAnchor = formatting.titleleft ? "start" : "middle";
      var tLeft = formatting.titleleft ? paddingLeft : center;
      this.rows.push({ left: tLeft, text: info.text, font: "subtitlefont", klass: "text subtitle", anchor: tAnchor, startChar: info.startChar, endChar: info.endChar, absElemType: "subtitle", name: "subtitle" });
      var size = getTextSize.calc(info.text, "subtitlefont", "text subtitle");
      this.rows.push({ move: size.height });
    }
    module.exports = Subtitle;
  }
});

// node_modules/abcjs/src/write/add-text-if.js
var require_add_text_if = __commonJS({
  "node_modules/abcjs/src/write/add-text-if.js"(exports, module) {
    function addTextIf(rows, params, getTextSize) {
      if (!params.text)
        return;
      if (!params.marginLeft)
        params.marginLeft = 0;
      if (!params.klass)
        params.klass = "";
      if (!params.anchor)
        params.anchor = "start";
      if (!params.info)
        params.info = { startChar: -2, endChar: -2 };
      if (params.marginTop)
        rows.push({ move: params.marginTop });
      var attr = { left: params.marginLeft, text: params.text, font: params.font, anchor: params.anchor, startChar: params.info.startChar, endChar: params.info.endChar };
      if (params.absElemType)
        attr.absElemType = params.absElemType;
      if (!params.inGroup)
        attr.klass = params.klass;
      if (params.name)
        attr.name = params.name;
      rows.push(attr);
      var size = getTextSize.calc("A", params.font, params.klass);
      var numLines = params.text.split("\n").length;
      if (params.text[params.text.length - 1] === "\n")
        numLines--;
      if (!params.noMove) {
        var h = size.height * 1.1 * numLines;
        rows.push({ move: Math.round(h) });
        if (params.marginBottom)
          rows.push({ move: params.marginBottom });
      }
    }
    module.exports = addTextIf;
  }
});

// node_modules/abcjs/src/write/top-text.js
var require_top_text = __commonJS({
  "node_modules/abcjs/src/write/top-text.js"(exports, module) {
    var addTextIf = require_add_text_if();
    function TopText(metaText, metaTextInfo, formatting, lines, width, isPrint, paddingLeft, spacing, getTextSize) {
      this.rows = [];
      if (metaText.header && isPrint) {
        var headerTextHeight = getTextSize.calc("X", "headerfont", "abcjs-header abcjs-meta-top").height;
        addTextIf(this.rows, { marginLeft: paddingLeft, text: metaText.header.left, font: "headerfont", klass: "header meta-top", marginTop: -headerTextHeight, info: metaTextInfo.header, name: "header" }, getTextSize);
        addTextIf(this.rows, { marginLeft: paddingLeft + width / 2, text: metaText.header.center, font: "headerfont", klass: "header meta-top", marginTop: -headerTextHeight, anchor: "middle", info: metaTextInfo.header, name: "header" }, getTextSize);
        addTextIf(this.rows, { marginLeft: paddingLeft + width, text: metaText.header.right, font: "headerfont", klass: "header meta-top", marginTop: -headerTextHeight, anchor: "end", info: metaTextInfo.header, name: "header" }, getTextSize);
      }
      if (isPrint)
        this.rows.push({ move: spacing.top });
      var tAnchor = formatting.titleleft ? "start" : "middle";
      var tLeft = formatting.titleleft ? paddingLeft : paddingLeft + width / 2;
      if (metaText.title) {
        addTextIf(this.rows, { marginLeft: tLeft, text: metaText.title, font: "titlefont", klass: "title meta-top", marginTop: spacing.title, anchor: tAnchor, absElemType: "title", info: metaTextInfo.title, name: "title" }, getTextSize);
      }
      if (lines.length) {
        var index = 0;
        while (index < lines.length && lines[index].subtitle) {
          addTextIf(this.rows, { marginLeft: tLeft, text: lines[index].subtitle.text, font: "subtitlefont", klass: "text meta-top subtitle", marginTop: spacing.subtitle, anchor: tAnchor, absElemType: "subtitle", info: lines[index].subtitle, name: "subtitle" }, getTextSize);
          index++;
        }
      }
      if (metaText.rhythm || metaText.origin || metaText.composer) {
        this.rows.push({ move: spacing.composer });
        if (metaText.rhythm && metaText.rhythm.length > 0) {
          var noMove = !!(metaText.composer || metaText.origin);
          addTextIf(this.rows, { marginLeft: paddingLeft, text: metaText.rhythm, font: "infofont", klass: "meta-top rhythm", absElemType: "rhythm", noMove: true, info: metaTextInfo.rhythm, name: "rhythm" }, getTextSize);
        }
        var composerLine = "";
        if (metaText.composer)
          composerLine += metaText.composer;
        if (metaText.origin)
          composerLine += " (" + metaText.origin + ")";
        if (composerLine.length > 0) {
          addTextIf(this.rows, { marginLeft: paddingLeft + width, text: composerLine, font: "composerfont", klass: "meta-top composer", anchor: "end", absElemType: "composer", info: metaTextInfo.composer, name: "composer" }, getTextSize);
        }
      }
      if (metaText.author && metaText.author.length > 0) {
        addTextIf(this.rows, { marginLeft: paddingLeft + width, text: metaText.author, font: "composerfont", klass: "meta-top author", anchor: "end", absElemType: "author", info: metaTextInfo.author, name: "author" }, getTextSize);
      }
      if (metaText.partOrder && metaText.partOrder.length > 0) {
        addTextIf(this.rows, { marginLeft: paddingLeft, text: metaText.partOrder, font: "partsfont", klass: "meta-top part-order", absElemType: "partOrder", info: metaTextInfo.partOrder, name: "part-order" }, getTextSize);
      }
    }
    module.exports = TopText;
  }
});

// node_modules/abcjs/src/write/bottom-text.js
var require_bottom_text = __commonJS({
  "node_modules/abcjs/src/write/bottom-text.js"(exports, module) {
    var addTextIf = require_add_text_if();
    function BottomText(metaText, width, isPrint, paddingLeft, spacing, getTextSize) {
      this.rows = [];
      if (metaText.unalignedWords && metaText.unalignedWords.length > 0)
        this.unalignedWords(metaText.unalignedWords, paddingLeft, spacing, getTextSize);
      this.extraText(metaText, paddingLeft, spacing, getTextSize);
      if (metaText.footer && isPrint)
        this.footer(metaText.footer, width, paddingLeft, getTextSize);
    }
    BottomText.prototype.unalignedWords = function(unalignedWords, paddingLeft, spacing, getTextSize) {
      var indent = 50;
      var klass = "meta-bottom unaligned-words";
      var defFont = "wordsfont";
      this.rows.push({ startGroup: "unalignedWords", klass: "abcjs-meta-bottom abcjs-unaligned-words", name: "words" });
      var space = getTextSize.calc("i", defFont, klass);
      this.rows.push({ move: spacing.words });
      for (var j = 0; j < unalignedWords.length; j++) {
        if (unalignedWords[j] === "")
          this.rows.push({ move: space.height });
        else if (typeof unalignedWords[j] === "string") {
          addTextIf(this.rows, { marginLeft: paddingLeft + indent, text: unalignedWords[j], font: defFont, klass, inGroup: true, name: "words" }, getTextSize);
        } else {
          var largestY = 0;
          var offsetX = 0;
          for (var k = 0; k < unalignedWords[j].length; k++) {
            var thisWord = unalignedWords[j][k];
            var font = thisWord.font ? thisWord.font : defFont;
            this.rows.push({
              left: paddingLeft + indent + offsetX,
              text: thisWord.text,
              font,
              anchor: "start"
            });
            var size = getTextSize.calc(thisWord.text, defFont, klass);
            largestY = Math.max(largestY, size.height);
            offsetX += size.width;
            if (thisWord.text[thisWord.text.length - 1] === " ") {
              offsetX += space.width;
            }
          }
          this.rows.push({ move: largestY });
        }
      }
      this.rows.push({ move: space.height * 2 });
      this.rows.push({ endGroup: "unalignedWords", absElemType: "unalignedWords", startChar: -1, endChar: -1, name: "unalignedWords" });
    };
    BottomText.prototype.extraText = function(metaText, marginLeft, spacing, getTextSize) {
      var extraText = "";
      if (metaText.book)
        extraText += "Book: " + metaText.book + "\n";
      if (metaText.source)
        extraText += "Source: " + metaText.source + "\n";
      if (metaText.discography)
        extraText += "Discography: " + metaText.discography + "\n";
      if (metaText.notes)
        extraText += "Notes: " + metaText.notes + "\n";
      if (metaText.transcription)
        extraText += "Transcription: " + metaText.transcription + "\n";
      if (metaText.history)
        extraText += "History: " + metaText.history + "\n";
      if (metaText["abc-copyright"])
        extraText += "Copyright: " + metaText["abc-copyright"] + "\n";
      if (metaText["abc-creator"])
        extraText += "Creator: " + metaText["abc-creator"] + "\n";
      if (metaText["abc-edited-by"])
        extraText += "Edited By: " + metaText["abc-edited-by"] + "\n";
      if (extraText.length > 0) {
        addTextIf(this.rows, { marginLeft, text: extraText, font: "historyfont", klass: "meta-bottom extra-text", marginTop: spacing.info, absElemType: "extraText", name: "description" }, getTextSize);
      }
    };
    BottomText.prototype.footer = function(footer, width, paddingLeft, getTextSize) {
      var klass = "header meta-bottom";
      var font = "footerfont";
      this.rows.push({ startGroup: "footer", klass });
      addTextIf(this.rows, { marginLeft: paddingLeft, text: footer.left, font, klass, name: "footer" }, getTextSize);
      addTextIf(this.rows, { marginLeft: paddingLeft + width / 2, text: footer.center, font, klass, anchor: "middle", name: "footer" }, getTextSize);
      addTextIf(this.rows, { marginLeft: paddingLeft + width, text: footer.right, font, klass, anchor: "end", name: "footer" }, getTextSize);
    };
    module.exports = BottomText;
  }
});

// node_modules/abcjs/src/write/selection.js
var require_selection = __commonJS({
  "node_modules/abcjs/src/write/selection.js"(exports, module) {
    var spacing = require_abc_spacing();
    function setupSelection(engraver) {
      engraver.rangeHighlight = rangeHighlight;
      if (engraver.dragging) {
        for (var h = 0; h < engraver.selectables.length; h++) {
          var hist = engraver.selectables[h];
          if (hist.svgEl.getAttribute("selectable") === "true") {
            hist.svgEl.setAttribute("tabindex", 0);
            hist.svgEl.setAttribute("data-index", h);
            hist.svgEl.addEventListener("keydown", keyboardDown.bind(engraver));
            hist.svgEl.addEventListener("keyup", keyboardSelection.bind(engraver));
            hist.svgEl.addEventListener("focus", elementFocused.bind(engraver));
          }
        }
      }
      engraver.renderer.paper.svg.addEventListener("mousedown", mouseDown.bind(engraver));
      engraver.renderer.paper.svg.addEventListener("mousemove", mouseMove.bind(engraver));
      engraver.renderer.paper.svg.addEventListener("mouseup", mouseUp.bind(engraver));
    }
    function getCoord(ev, svg) {
      var scaleX = 1;
      var scaleY = 1;
      if (svg.viewBox.baseVal) {
        if (svg.viewBox.baseVal.width !== 0)
          scaleX = svg.viewBox.baseVal.width / svg.clientWidth;
        if (svg.viewBox.baseVal.height !== 0)
          scaleY = svg.viewBox.baseVal.height / svg.clientHeight;
      }
      var svgClicked = ev.target.tagName === "svg";
      var x;
      var y;
      if (svgClicked) {
        x = ev.offsetX;
        y = ev.offsetY;
      } else {
        x = ev.layerX;
        y = ev.layerY;
      }
      x = x * scaleX;
      y = y * scaleY;
      return [x, y];
    }
    function elementFocused(ev) {
      if (this.dragMechanism === "keyboard" && this.dragYStep !== 0 && this.dragTarget)
        notifySelect.bind(this)(this.dragTarget, this.dragYStep, this.selectables.length, this.dragIndex, ev);
      this.dragYStep = 0;
    }
    function keyboardDown(ev) {
      switch (ev.keyCode) {
        case 38:
        case 40:
          ev.preventDefault();
      }
    }
    function keyboardSelection(ev) {
      var handled = false;
      var index = ev.target.dataset.index;
      switch (ev.keyCode) {
        case 13:
        case 32:
          handled = true;
          this.dragTarget = this.selectables[index];
          this.dragIndex = index;
          this.dragMechanism = "keyboard";
          mouseUp.bind(this)(ev);
          break;
        case 38:
          handled = true;
          this.dragTarget = this.selectables[index];
          this.dragIndex = index;
          if (this.dragTarget.isDraggable) {
            if (this.dragging && this.dragTarget.isDraggable)
              this.dragTarget.absEl.highlight(void 0, this.dragColor);
            this.dragYStep--;
            this.dragTarget.svgEl.setAttribute("transform", "translate(0," + this.dragYStep * spacing.STEP + ")");
          }
          break;
        case 40:
          handled = true;
          this.dragTarget = this.selectables[index];
          this.dragIndex = index;
          this.dragMechanism = "keyboard";
          if (this.dragTarget.isDraggable) {
            if (this.dragging && this.dragTarget.isDraggable)
              this.dragTarget.absEl.highlight(void 0, this.dragColor);
            this.dragYStep++;
            this.dragTarget.svgEl.setAttribute("transform", "translate(0," + this.dragYStep * spacing.STEP + ")");
          }
          break;
        case 9:
          if (this.dragYStep !== 0) {
            mouseUp.bind(this)(ev);
          }
          break;
        default:
          break;
      }
      if (handled)
        ev.preventDefault();
    }
    function findElementInHistory(selectables, el) {
      for (var i = 0; i < selectables.length; i++) {
        if (el === selectables[i].svgEl)
          return i;
      }
      return -1;
    }
    function findElementByCoord(self, x, y) {
      var minDistance = 9999999;
      var closestIndex = -1;
      for (var i = 0; i < self.selectables.length && minDistance > 0; i++) {
        var el = self.selectables[i];
        self.getDim(el);
        if (el.dim.left < x && el.dim.right > x && el.dim.top < y && el.dim.bottom > y) {
          closestIndex = i;
          minDistance = 0;
        } else if (el.dim.top < y && el.dim.bottom > y) {
          var horiz = Math.min(Math.abs(el.dim.left - x), Math.abs(el.dim.right - x));
          if (horiz < minDistance) {
            minDistance = horiz;
            closestIndex = i;
          }
        } else if (el.dim.left < x && el.dim.right > x) {
          var vert = Math.min(Math.abs(el.dim.top - y), Math.abs(el.dim.bottom - y));
          if (vert < minDistance) {
            minDistance = vert;
            closestIndex = i;
          }
        } else {
          var dx = Math.abs(x - el.dim.left) > Math.abs(x - el.dim.right) ? Math.abs(x - el.dim.right) : Math.abs(x - el.dim.left);
          var dy = Math.abs(y - el.dim.top) > Math.abs(y - el.dim.bottom) ? Math.abs(y - el.dim.bottom) : Math.abs(y - el.dim.top);
          var hypotenuse = Math.sqrt(dx * dx + dy * dy);
          if (hypotenuse < minDistance) {
            minDistance = hypotenuse;
            closestIndex = i;
          }
        }
      }
      return closestIndex >= 0 && minDistance <= 12 ? closestIndex : -1;
    }
    function getBestMatchCoordinates(dim, ev, scale) {
      if (dim.x <= ev.offsetX && dim.x + dim.width >= ev.offsetX && dim.y <= ev.offsetY && dim.y + dim.height >= ev.offsetY)
        return [ev.offsetX, ev.offsetY];
      var epsilon = Math.abs(ev.layerY / scale - ev.offsetY);
      if (epsilon < 3)
        return [ev.offsetX, ev.offsetY];
      else
        return [ev.layerX, ev.layerY];
    }
    function getTarget(target) {
      if (target.tagName === "svg")
        return target;
      var found = target.getAttribute("selectable");
      while (!found) {
        target = target.parentElement;
        if (target.tagName === "svg")
          found = true;
        else
          found = target.getAttribute("selectable");
      }
      return target;
    }
    function getMousePosition(self, ev) {
      var x;
      var y;
      var box;
      var clickedOn = findElementInHistory(self.selectables, getTarget(ev.target));
      if (clickedOn >= 0) {
        box = getBestMatchCoordinates(self.selectables[clickedOn].svgEl.getBBox(), ev, self.scale);
        x = box[0];
        y = box[1];
      } else {
        box = getCoord(ev, self.renderer.paper.svg);
        x = box[0];
        y = box[1];
        clickedOn = findElementByCoord(self, x, y);
      }
      return { x, y, clickedOn };
    }
    function mouseDown(ev) {
      var positioning = getMousePosition(this, ev);
      if (positioning.clickedOn >= 0 && ev.button === 0) {
        this.dragTarget = this.selectables[positioning.clickedOn];
        this.dragIndex = positioning.clickedOn;
        this.dragMechanism = "mouse";
        this.dragMouseStart = { x: positioning.x, y: positioning.y };
        if (this.dragging && this.dragTarget.isDraggable) {
          addGlobalClass(this.renderer.paper, "abcjs-dragging-in-progress");
          this.dragTarget.absEl.highlight(void 0, this.dragColor);
        }
      }
    }
    function mouseMove(ev) {
      if (!this.dragTarget || !this.dragging || !this.dragTarget.isDraggable || this.dragMechanism !== "mouse")
        return;
      var positioning = getMousePosition(this, ev);
      var yDist = Math.round((positioning.y - this.dragMouseStart.y) / spacing.STEP);
      if (yDist !== this.dragYStep) {
        this.dragYStep = yDist;
        this.dragTarget.svgEl.setAttribute("transform", "translate(0," + yDist * spacing.STEP + ")");
      }
    }
    function mouseUp(ev) {
      if (!this.dragTarget)
        return;
      clearSelection.bind(this)();
      if (this.dragTarget.absEl && this.dragTarget.absEl.highlight) {
        this.selected = [this.dragTarget.absEl];
        this.dragTarget.absEl.highlight(void 0, this.selectionColor);
      }
      notifySelect.bind(this)(this.dragTarget, this.dragYStep, this.selectables.length, this.dragIndex, ev);
      if (this.dragTarget.svgEl && this.dragTarget.svgEl.focus) {
        this.dragTarget.svgEl.focus();
        this.dragTarget = null;
        this.dragIndex = -1;
      }
      removeGlobalClass(this.renderer.svg, "abcjs-dragging-in-progress");
    }
    function setSelection(dragIndex) {
      if (dragIndex >= 0 && dragIndex < this.selectables.length) {
        this.dragTarget = this.selectables[dragIndex];
        this.dragIndex = dragIndex;
        this.dragMechanism = "keyboard";
        mouseUp.bind(this)({ target: this.dragTarget.svgEl });
      }
    }
    function notifySelect(target, dragStep, dragMax, dragIndex, ev) {
      var classes = [];
      if (target.absEl.elemset) {
        var classObj = {};
        for (var j = 0; j < target.absEl.elemset.length; j++) {
          var es = target.absEl.elemset[j];
          if (es) {
            var klass = es.getAttribute("class").split(" ");
            for (var k = 0; k < klass.length; k++)
              classObj[klass[k]] = true;
          }
        }
        for (var kk = 0; kk < Object.keys(classObj).length; kk++)
          classes.push(Object.keys(classObj)[kk]);
      }
      var analysis = {};
      for (var ii = 0; ii < classes.length; ii++) {
        findNumber(classes[ii], "abcjs-v", analysis, "voice");
        findNumber(classes[ii], "abcjs-l", analysis, "line");
        findNumber(classes[ii], "abcjs-m", analysis, "measure");
      }
      if (target.staffPos)
        analysis.staffPos = target.staffPos;
      var closest = ev.target;
      while (!closest.dataset.name && closest.tagName.toLowerCase() !== "svg")
        closest = closest.parentNode;
      var parent = ev.target;
      while (!parent.dataset.index && parent.tagName.toLowerCase() !== "svg")
        parent = parent.parentNode;
      analysis.name = parent.dataset.name;
      analysis.clickedName = closest.dataset.name;
      analysis.parentClasses = parent.classList;
      analysis.clickedClasses = closest.classList;
      analysis.selectableElement = target.svgEl;
      for (var i = 0; i < this.listeners.length; i++) {
        this.listeners[i](target.absEl.abcelem, target.absEl.tuneNumber, classes.join(" "), analysis, { step: dragStep, max: dragMax, index: dragIndex, setSelection: setSelection.bind(this) }, ev);
      }
    }
    function findNumber(klass, match, target, name) {
      if (klass.indexOf(match) === 0) {
        var value = klass.replace(match, "");
        var num = parseInt(value, 10);
        if ("" + num === value)
          target[name] = num;
      }
    }
    function clearSelection() {
      for (var i = 0; i < this.selected.length; i++) {
        this.selected[i].unhighlight(void 0, this.renderer.foregroundColor);
      }
      this.selected = [];
    }
    function rangeHighlight(start, end) {
      clearSelection.bind(this)();
      for (var line = 0; line < this.staffgroups.length; line++) {
        var voices = this.staffgroups[line].voices;
        for (var voice = 0; voice < voices.length; voice++) {
          var elems = voices[voice].children;
          for (var elem = 0; elem < elems.length; elem++) {
            var elStart = elems[elem].abcelem.startChar;
            var elEnd = elems[elem].abcelem.endChar;
            if (end > elStart && start < elEnd || end === start && end === elEnd) {
              this.selected[this.selected.length] = elems[elem];
              elems[elem].highlight(void 0, this.selectionColor);
            }
          }
        }
      }
    }
    function getClassSet(el) {
      var oldClass = el.getAttribute("class");
      if (!oldClass)
        oldClass = "";
      var klasses = oldClass.split(" ");
      var obj = {};
      for (var i = 0; i < klasses.length; i++)
        obj[klasses[i]] = true;
      return obj;
    }
    function setClassSet(el, klassSet) {
      var klasses = [];
      for (var key in klassSet) {
        if (klassSet.hasOwnProperty(key))
          klasses.push(key);
      }
      el.setAttribute("class", klasses.join(" "));
    }
    function addGlobalClass(svg, klass) {
      if (svg) {
        var obj = getClassSet(svg.svg);
        obj[klass] = true;
        setClassSet(svg.svg, obj);
      }
    }
    function removeGlobalClass(svg, klass) {
      if (svg) {
        var obj = getClassSet(svg.svg);
        delete obj[klass];
        setClassSet(svg.svg, obj);
      }
    }
    module.exports = setupSelection;
  }
});

// node_modules/abcjs/src/write/layout/getBarYAt.js
var require_getBarYAt = __commonJS({
  "node_modules/abcjs/src/write/layout/getBarYAt.js"(exports, module) {
    function getBarYAt(startx, starty, endx, endy, x) {
      return starty + (endy - starty) / (endx - startx) * (x - startx);
    }
    module.exports = getBarYAt;
  }
});

// node_modules/abcjs/src/write/layout/beam.js
var require_beam = __commonJS({
  "node_modules/abcjs/src/write/layout/beam.js"(exports, module) {
    var RelativeElement = require_abc_relative_element();
    var spacing = require_abc_spacing();
    var getBarYAt = require_getBarYAt();
    var layoutBeam = function(beam) {
      if (beam.elems.length === 0 || beam.allrests)
        return;
      var dy = calcDy(beam.stemsUp, beam.isgrace);
      var firstElement = beam.elems[0];
      var lastElement = beam.elems[beam.elems.length - 1];
      var minStemHeight = 0;
      var referencePitch = beam.stemsUp ? firstElement.abcelem.maxpitch : firstElement.abcelem.minpitch;
      minStemHeight = minStem(firstElement, beam.stemsUp, referencePitch, minStemHeight);
      minStemHeight = minStem(lastElement, beam.stemsUp, referencePitch, minStemHeight);
      minStemHeight = Math.max(beam.stemHeight, minStemHeight + 3);
      var yPos = calcYPos(beam.average, beam.elems.length, minStemHeight, beam.stemsUp, firstElement.abcelem.averagepitch, lastElement.abcelem.averagepitch, beam.isflat, beam.min, beam.max, beam.isgrace);
      var xPos = calcXPos(beam.stemsUp, firstElement, lastElement);
      beam.addBeam({ startX: xPos[0], endX: xPos[1], startY: yPos[0], endY: yPos[1], dy });
      var beams = createAdditionalBeams(beam.elems, beam.stemsUp, beam.beams[0], beam.isgrace, dy);
      for (var i = 0; i < beams.length; i++)
        beam.addBeam(beams[i]);
      createStems(beam.elems, beam.stemsUp, beam.beams[0], dy, beam.mainNote);
    };
    var getDurlog = function(duration) {
      if (duration === void 0) {
        return 0;
      }
      return Math.floor(Math.log(duration) / Math.log(2));
    };
    function minStem(element, stemsUp, referencePitch, minStemHeight) {
      if (!element.children)
        return minStemHeight;
      for (var i = 0; i < element.children.length; i++) {
        var elem = element.children[i];
        if (stemsUp && elem.top !== void 0 && elem.c === "flags.ugrace")
          minStemHeight = Math.max(minStemHeight, elem.top - referencePitch);
        else if (!stemsUp && elem.bottom !== void 0 && elem.c === "flags.ugrace")
          minStemHeight = Math.max(minStemHeight, referencePitch - elem.bottom + 7);
      }
      return minStemHeight;
    }
    function calcSlant(leftAveragePitch, rightAveragePitch, numStems, isFlat) {
      if (isFlat)
        return 0;
      var slant = leftAveragePitch - rightAveragePitch;
      var maxSlant = numStems / 2;
      if (slant > maxSlant)
        slant = maxSlant;
      if (slant < -maxSlant)
        slant = -maxSlant;
      return slant;
    }
    function calcDy(asc, isGrace) {
      var dy = asc ? spacing.STEP : -spacing.STEP;
      if (isGrace)
        dy = dy * 0.4;
      return dy;
    }
    function calcXPos(asc, firstElement, lastElement) {
      var starthead = firstElement.heads[asc ? 0 : firstElement.heads.length - 1];
      var endhead = lastElement.heads[asc ? 0 : lastElement.heads.length - 1];
      var startX = starthead.x;
      if (asc)
        startX += starthead.w - 0.6;
      var endX = endhead.x;
      endX += asc ? endhead.w : 0.6;
      return [startX, endX];
    }
    function calcYPos(average, numElements, stemHeight, asc, firstAveragePitch, lastAveragePitch, isFlat, minPitch, maxPitch, isGrace) {
      var barpos = stemHeight - 2;
      var barminpos = stemHeight - 2;
      var pos = Math.round(asc ? Math.max(average + barpos, maxPitch + barminpos) : Math.min(average - barpos, minPitch - barminpos));
      var slant = calcSlant(firstAveragePitch, lastAveragePitch, numElements, isFlat);
      var startY = pos + Math.floor(slant / 2);
      var endY = pos + Math.floor(-slant / 2);
      if (!isGrace) {
        if (asc && pos < 6) {
          startY = 6;
          endY = 6;
        } else if (!asc && pos > 6) {
          startY = 6;
          endY = 6;
        }
      }
      return [startY, endY];
    }
    function createStems(elems, asc, beam, dy, mainNote) {
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (elem.abcelem.rest)
          continue;
        var isGrace = elem.addExtra ? false : true;
        var parent = isGrace ? mainNote : elem;
        var furthestHead = elem.heads[asc ? 0 : elem.heads.length - 1];
        var ovalDelta = 1 / 5;
        var pitch = furthestHead.pitch + (asc ? ovalDelta : -ovalDelta);
        var dx = asc ? furthestHead.w : 0;
        if (!isGrace)
          dx += furthestHead.dx;
        var x = furthestHead.x + dx;
        var bary = getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, x);
        var lineWidth = asc ? -0.6 : 0.6;
        if (!asc)
          bary -= dy / 2 / spacing.STEP;
        if (isGrace)
          dx += elem.heads[0].dx;
        if (furthestHead.c === "noteheads.slash.quarter") {
          if (asc)
            pitch += 1;
          else
            pitch -= 1;
        }
        var stem = new RelativeElement(null, dx, 0, pitch, {
          "type": "stem",
          "pitch2": bary,
          linewidth: lineWidth
        });
        stem.setX(parent.x);
        parent.addRight(stem);
      }
    }
    function createAdditionalBeams(elems, asc, beam, isGrace, dy) {
      var beams = [];
      var auxBeams = [];
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (elem.abcelem.rest)
          continue;
        var furthestHead = elem.heads[asc ? 0 : elem.heads.length - 1];
        var x = furthestHead.x + (asc ? furthestHead.w : 0);
        var bary = getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, x);
        var sy = asc ? -1.5 : 1.5;
        if (isGrace)
          sy = sy * 2 / 3;
        var duration = elem.abcelem.duration;
        if (duration === 0)
          duration = 0.25;
        for (var durlog = getDurlog(duration); durlog < -3; durlog++) {
          var index = -4 - durlog;
          if (auxBeams[index]) {
            auxBeams[index].single = false;
          } else {
            auxBeams[index] = {
              x: x + (asc ? -0.6 : 0),
              y: bary + sy * (index + 1),
              durlog,
              single: true
            };
          }
          if (i > 0 && elem.abcelem.beambr && elem.abcelem.beambr <= index + 1) {
            if (!auxBeams[index].split)
              auxBeams[index].split = [auxBeams[index].x];
            var xPos = calcXPos(asc, elems[i - 1], elem);
            if (auxBeams[index].split[auxBeams[index].split.length - 1] >= xPos[0]) {
              xPos[0] += elem.w;
            }
            auxBeams[index].split.push(xPos[0]);
            auxBeams[index].split.push(xPos[1]);
          }
        }
        for (var j = auxBeams.length - 1; j >= 0; j--) {
          if (i === elems.length - 1 || getDurlog(elems[i + 1].abcelem.duration) > -j - 4) {
            var auxBeamEndX = x;
            var auxBeamEndY = bary + sy * (j + 1);
            if (auxBeams[j].single) {
              auxBeamEndX = i === 0 ? x + 5 : x - 5;
              auxBeamEndY = getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, auxBeamEndX) + sy * (j + 1);
            }
            var b = { startX: auxBeams[j].x, endX: auxBeamEndX, startY: auxBeams[j].y, endY: auxBeamEndY, dy };
            if (auxBeams[j].split !== void 0) {
              var split = auxBeams[j].split;
              if (b.endX <= split[split.length - 1]) {
                split[split.length - 1] -= elem.w;
              }
              split.push(b.endX);
              b.split = auxBeams[j].split;
            }
            beams.push(b);
            auxBeams = auxBeams.slice(0, j);
          }
        }
      }
      return beams;
    }
    module.exports = layoutBeam;
  }
});

// node_modules/abcjs/src/write/layout/triplet.js
var require_triplet = __commonJS({
  "node_modules/abcjs/src/write/layout/triplet.js"(exports, module) {
    var getBarYAt = require_getBarYAt();
    function layoutTriplet(element) {
      if (element.anchor1 && element.anchor2) {
        element.hasBeam = !!element.anchor1.parent.beam && element.anchor1.parent.beam === element.anchor2.parent.beam;
        var beam = element.anchor1.parent.beam;
        if (element.hasBeam && (beam.elems[0] !== element.anchor1.parent || beam.elems[beam.elems.length - 1] !== element.anchor2.parent))
          element.hasBeam = false;
        if (element.hasBeam) {
          var left = isAbove(beam) ? element.anchor1.x + element.anchor1.w : element.anchor1.x;
          element.yTextPos = heightAtMidpoint(left, element.anchor2.x, beam);
          element.yTextPos += isAbove(beam) ? 3 : -2;
          element.xTextPos = xAtMidpoint(left, element.anchor2.x);
          element.top = element.yTextPos + 1;
          element.bottom = element.yTextPos - 2;
          if (isAbove(beam))
            element.endingHeightAbove = 4;
        } else {
          element.startNote = Math.max(element.anchor1.parent.top, 9) + 4;
          element.endNote = Math.max(element.anchor2.parent.top, 9) + 4;
          if (element.anchor1.parent.type === "rest" && element.anchor2.parent.type !== "rest")
            element.startNote = element.endNote;
          else if (element.anchor2.parent.type === "rest" && element.anchor1.parent.type !== "rest")
            element.endNote = element.startNote;
          var max = 0;
          for (var i = 0; i < element.middleElems.length; i++) {
            max = Math.max(max, element.middleElems[i].top);
          }
          max += 4;
          if (max > element.startNote || max > element.endNote) {
            element.startNote = max;
            element.endNote = max;
          }
          if (element.flatBeams) {
            element.startNote = Math.max(element.startNote, element.endNote);
            element.endNote = Math.max(element.startNote, element.endNote);
          }
          element.yTextPos = element.startNote + (element.endNote - element.startNote) / 2;
          element.xTextPos = element.anchor1.x + (element.anchor2.x + element.anchor2.w - element.anchor1.x) / 2;
          element.top = element.yTextPos + 1;
        }
      }
      delete element.middleElems;
      delete element.flatBeams;
    }
    function isAbove(beam) {
      return beam.stemsUp;
    }
    function heightAtMidpoint(startX, endX, beam) {
      if (beam.beams.length === 0)
        return 0;
      beam = beam.beams[0];
      var midPoint = startX + (endX - startX) / 2;
      return getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, midPoint);
    }
    function xAtMidpoint(startX, endX) {
      return startX + (endX - startX) / 2;
    }
    module.exports = layoutTriplet;
  }
});

// node_modules/abcjs/src/write/layout/voice.js
var require_voice = __commonJS({
  "node_modules/abcjs/src/write/layout/voice.js"(exports, module) {
    var layoutBeam = require_beam();
    var getBarYAt = require_getBarYAt();
    var layoutTriplet = require_triplet();
    var layoutVoice = function(voice) {
      for (var i = 0; i < voice.beams.length; i++) {
        if (voice.beams[i].type === "BeamElem") {
          layoutBeam(voice.beams[i]);
          moveDecorations(voice.beams[i]);
          for (var j = 0; j < voice.beams[i].elems.length; j++) {
            voice.adjustRange(voice.beams[i].elems[j]);
          }
        }
      }
      voice.staff.specialY.chordLines = setLaneForChord(voice.children);
      for (i = 0; i < voice.otherchildren.length; i++) {
        var child = voice.otherchildren[i];
        if (child.type === "TripletElem") {
          layoutTriplet(child);
          voice.adjustRange(child);
        }
      }
      voice.staff.top = Math.max(voice.staff.top, voice.top);
      voice.staff.bottom = Math.min(voice.staff.bottom, voice.bottom);
    };
    function moveDecorations(beam) {
      var padding = 1.5;
      for (var ch = 0; ch < beam.elems.length; ch++) {
        var child = beam.elems[ch];
        if (child.top) {
          var top = yAtNote(child, beam);
          for (var i = 0; i < child.children.length; i++) {
            var el = child.children[i];
            if (el.klass === "ornament") {
              if (el.bottom - padding < top) {
                var distance = top - el.bottom + padding;
                el.bottom += distance;
                el.top += distance;
                el.pitch += distance;
                top = child.top = el.top;
              }
            }
          }
        }
      }
    }
    function placeInLane(rightMost, relElem) {
      var xCoords = relElem.getChordDim();
      if (xCoords) {
        for (var i = 0; i < rightMost.length; i++) {
          var fits = rightMost[i] < xCoords.left;
          if (fits) {
            if (i > 0)
              relElem.putChordInLane(i);
            rightMost[i] = xCoords.right;
            return;
          }
        }
        rightMost.push(xCoords.right);
        relElem.putChordInLane(rightMost.length - 1);
      }
    }
    function setLaneForChord(absElems) {
      var rightMostAbove = [0];
      var rightMostBelow = [0];
      var i;
      var j;
      var relElem;
      for (i = 0; i < absElems.length; i++) {
        for (j = 0; j < absElems[i].children.length; j++) {
          relElem = absElems[i].children[j];
          if (relElem.chordHeightAbove) {
            placeInLane(rightMostAbove, relElem);
          }
        }
        for (j = absElems[i].children.length - 1; j >= 0; j--) {
          relElem = absElems[i].children[j];
          if (relElem.chordHeightBelow) {
            placeInLane(rightMostBelow, relElem);
          }
        }
      }
      if (rightMostAbove.length > 1 || rightMostBelow.length > 1)
        setLane(absElems, rightMostAbove.length, rightMostBelow.length);
      return { above: rightMostAbove.length, below: rightMostBelow.length };
    }
    function numAnnotationsBelow(absElem) {
      var count = 0;
      for (var j = 0; j < absElem.children.length; j++) {
        var relElem = absElem.children[j];
        if (relElem.chordHeightBelow)
          count++;
      }
      return count;
    }
    function setLane(absElems, numLanesAbove, numLanesBelow) {
      for (var i = 0; i < absElems.length; i++) {
        var below = numAnnotationsBelow(absElems[i]);
        for (var j = 0; j < absElems[i].children.length; j++) {
          var relElem = absElems[i].children[j];
          if (relElem.chordHeightAbove) {
            relElem.invertLane(numLanesAbove);
          }
        }
      }
    }
    function yAtNote(element, beam) {
      beam = beam.beams[0];
      return getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, element.x);
    }
    module.exports = layoutVoice;
  }
});

// node_modules/abcjs/src/write/layout/setUpperAndLowerElements.js
var require_setUpperAndLowerElements = __commonJS({
  "node_modules/abcjs/src/write/layout/setUpperAndLowerElements.js"(exports, module) {
    var spacing = require_abc_spacing();
    var setUpperAndLowerElements = function(renderer, staffGroup) {
      var lastStaffBottom;
      for (var i = 0; i < staffGroup.staffs.length; i++) {
        var staff = staffGroup.staffs[i];
        var positionY = {
          tempoHeightAbove: 0,
          partHeightAbove: 0,
          volumeHeightAbove: 0,
          dynamicHeightAbove: 0,
          endingHeightAbove: 0,
          chordHeightAbove: 0,
          lyricHeightAbove: 0,
          lyricHeightBelow: 0,
          chordHeightBelow: 0,
          volumeHeightBelow: 0,
          dynamicHeightBelow: 0
        };
        if (renderer.showDebug && renderer.showDebug.indexOf("box") >= 0) {
          staff.originalTop = staff.top;
          staff.originalBottom = staff.bottom;
        }
        incTop(staff, positionY, "lyricHeightAbove");
        incTop(staff, positionY, "chordHeightAbove", staff.specialY.chordLines.above);
        if (staff.specialY.endingHeightAbove) {
          if (staff.specialY.chordHeightAbove)
            staff.top += 2;
          else
            staff.top += staff.specialY.endingHeightAbove + margin;
          positionY.endingHeightAbove = staff.top;
        }
        if (staff.specialY.dynamicHeightAbove && staff.specialY.volumeHeightAbove) {
          staff.top += Math.max(staff.specialY.dynamicHeightAbove, staff.specialY.volumeHeightAbove) + margin;
          positionY.dynamicHeightAbove = staff.top;
          positionY.volumeHeightAbove = staff.top;
        } else {
          incTop(staff, positionY, "dynamicHeightAbove");
          incTop(staff, positionY, "volumeHeightAbove");
        }
        incTop(staff, positionY, "partHeightAbove");
        incTop(staff, positionY, "tempoHeightAbove");
        if (staff.specialY.lyricHeightBelow) {
          staff.specialY.lyricHeightBelow += renderer.spacing.vocal / spacing.STEP;
          positionY.lyricHeightBelow = staff.bottom;
          staff.bottom -= staff.specialY.lyricHeightBelow + margin;
        }
        if (staff.specialY.chordHeightBelow) {
          positionY.chordHeightBelow = staff.bottom;
          var hgt = staff.specialY.chordHeightBelow;
          if (staff.specialY.chordLines.below)
            hgt *= staff.specialY.chordLines.below;
          staff.bottom -= hgt + margin;
        }
        if (staff.specialY.volumeHeightBelow && staff.specialY.dynamicHeightBelow) {
          positionY.volumeHeightBelow = staff.bottom;
          positionY.dynamicHeightBelow = staff.bottom;
          staff.bottom -= Math.max(staff.specialY.volumeHeightBelow, staff.specialY.dynamicHeightBelow) + margin;
        } else if (staff.specialY.volumeHeightBelow) {
          positionY.volumeHeightBelow = staff.bottom;
          staff.bottom -= staff.specialY.volumeHeightBelow + margin;
        } else if (staff.specialY.dynamicHeightBelow) {
          positionY.dynamicHeightBelow = staff.bottom;
          staff.bottom -= staff.specialY.dynamicHeightBelow + margin;
        }
        if (renderer.showDebug && renderer.showDebug.indexOf("box") >= 0)
          staff.positionY = positionY;
        for (var j = 0; j < staff.voices.length; j++) {
          var voice = staffGroup.voices[staff.voices[j]];
          setUpperAndLowerVoiceElements(positionY, voice, renderer.spacing);
        }
        if (lastStaffBottom !== void 0) {
          var thisStaffTop = staff.top - 10;
          var forcedSpacingBetween = lastStaffBottom + thisStaffTop;
          var minSpacingInPitches = renderer.spacing.systemStaffSeparation / spacing.STEP;
          var addedSpace = minSpacingInPitches - forcedSpacingBetween;
          if (addedSpace > 0)
            staff.top += addedSpace;
        }
        lastStaffBottom = 2 - staff.bottom;
      }
    };
    var margin = 1;
    function incTop(staff, positionY, item, count) {
      if (staff.specialY[item]) {
        var height = staff.specialY[item];
        if (count)
          height *= count;
        staff.top += height + margin;
        positionY[item] = staff.top;
      }
    }
    function setUpperAndLowerVoiceElements(positionY, voice, spacing2) {
      var i;
      var abselem;
      for (i = 0; i < voice.children.length; i++) {
        abselem = voice.children[i];
        setUpperAndLowerAbsoluteElements(positionY, abselem, spacing2);
      }
      for (i = 0; i < voice.otherchildren.length; i++) {
        abselem = voice.otherchildren[i];
        switch (abselem.type) {
          case "CrescendoElem":
            setUpperAndLowerCrescendoElements(positionY, abselem);
            break;
          case "DynamicDecoration":
            setUpperAndLowerDynamicElements(positionY, abselem);
            break;
          case "EndingElem":
            setUpperAndLowerEndingElements(positionY, abselem);
            break;
        }
      }
    }
    function setUpperAndLowerAbsoluteElements(specialYResolved, element, spacing2) {
      for (var i = 0; i < element.children.length; i++) {
        var child = element.children[i];
        for (var key in element.specialY) {
          if (element.specialY.hasOwnProperty(key)) {
            if (child[key]) {
              child.pitch = specialYResolved[key];
              if (child.top === void 0) {
                if (child.type === "TempoElement") {
                  setUpperAndLowerTempoElement(specialYResolved, child);
                } else {
                  setUpperAndLowerRelativeElements(specialYResolved, child, spacing2);
                }
                element.pushTop(child.top);
                element.pushBottom(child.bottom);
              }
            }
          }
        }
      }
    }
    function setUpperAndLowerCrescendoElements(positionY, element) {
      if (element.dynamicHeightAbove)
        element.pitch = positionY.dynamicHeightAbove;
      else
        element.pitch = positionY.dynamicHeightBelow;
    }
    function setUpperAndLowerDynamicElements(positionY, element) {
      if (element.volumeHeightAbove)
        element.pitch = positionY.volumeHeightAbove;
      else
        element.pitch = positionY.volumeHeightBelow;
    }
    function setUpperAndLowerEndingElements(positionY, element) {
      element.pitch = positionY.endingHeightAbove - 2;
    }
    function setUpperAndLowerTempoElement(positionY, element) {
      element.pitch = positionY.tempoHeightAbove;
      element.top = positionY.tempoHeightAbove;
      element.bottom = positionY.tempoHeightAbove;
      if (element.note) {
        var tempoPitch = element.pitch - element.totalHeightInPitches + 1;
        element.note.top = tempoPitch;
        element.note.bottom = tempoPitch;
        for (var i = 0; i < element.note.children.length; i++) {
          var child = element.note.children[i];
          child.top += tempoPitch;
          child.bottom += tempoPitch;
          child.pitch += tempoPitch;
          if (child.pitch2 !== void 0)
            child.pitch2 += tempoPitch;
        }
      }
    }
    function setUpperAndLowerRelativeElements(positionY, element, renderSpacing) {
      switch (element.type) {
        case "part":
          element.top = positionY.partHeightAbove + element.height;
          element.bottom = positionY.partHeightAbove;
          break;
        case "text":
        case "chord":
          if (element.chordHeightAbove) {
            element.top = positionY.chordHeightAbove;
            element.bottom = positionY.chordHeightAbove;
          } else {
            element.top = positionY.chordHeightBelow;
            element.bottom = positionY.chordHeightBelow;
          }
          break;
        case "lyric":
          if (element.lyricHeightAbove) {
            element.top = positionY.lyricHeightAbove;
            element.bottom = positionY.lyricHeightAbove;
          } else {
            element.top = positionY.lyricHeightBelow + renderSpacing.vocal / spacing.STEP;
            element.bottom = positionY.lyricHeightBelow + renderSpacing.vocal / spacing.STEP;
            element.pitch -= renderSpacing.vocal / spacing.STEP;
          }
          break;
        case "debug":
          element.top = positionY.chordHeightAbove;
          element.bottom = positionY.chordHeightAbove;
          break;
      }
      if (element.pitch === void 0 || element.top === void 0)
        console.error("RelativeElement position not set.", element.type, element.pitch, element.top, positionY);
    }
    module.exports = setUpperAndLowerElements;
  }
});

// node_modules/abcjs/src/write/layout/VoiceElements.js
var require_VoiceElements = __commonJS({
  "node_modules/abcjs/src/write/layout/VoiceElements.js"(exports, module) {
    var VoiceElement = function VoiceElements() {
    };
    VoiceElement.beginLayout = function(startx, voice) {
      voice.i = 0;
      voice.durationindex = 0;
      voice.startx = startx;
      voice.minx = startx;
      voice.nextx = startx;
      voice.spacingduration = 0;
    };
    VoiceElement.layoutEnded = function(voice) {
      return voice.i >= voice.children.length;
    };
    VoiceElement.getNextX = function(voice) {
      return Math.max(voice.minx, voice.nextx);
    };
    VoiceElement.getSpacingUnits = function(voice) {
      return Math.sqrt(voice.spacingduration * 8);
    };
    VoiceElement.layoutOneItem = function(x, spacing, voice, minPadding, firstVoice) {
      var child = voice.children[voice.i];
      if (!child)
        return 0;
      var er = x - voice.minx;
      var pad = voice.durationindex + child.duration > 0 ? minPadding : 0;
      if (child.abcelem.el_type === "note" && !child.abcelem.rest && voice.voicenumber !== 0 && firstVoice) {
        var firstChild = firstVoice.children[firstVoice.i];
        var overlaps = firstChild && (child.abcelem.maxpitch <= firstChild.abcelem.maxpitch + 1 && child.abcelem.maxpitch >= firstChild.abcelem.minpitch - 1 || child.abcelem.minpitch <= firstChild.abcelem.maxpitch + 1 && child.abcelem.minpitch >= firstChild.abcelem.minpitch - 1);
        if (overlaps && child.abcelem.minpitch === firstChild.abcelem.minpitch && child.abcelem.maxpitch === firstChild.abcelem.maxpitch && firstChild.heads && firstChild.heads.length > 0 && child.heads && child.heads.length > 0 && firstChild.heads[0].c === child.heads[0].c)
          overlaps = false;
        if (overlaps) {
          var firstChildNoteWidth = firstChild.heads && firstChild.heads.length > 0 ? firstChild.heads[0].realWidth : firstChild.fixed.w;
          if (!child.adjustedWidth)
            child.adjustedWidth = firstChildNoteWidth + child.w;
          child.w = child.adjustedWidth;
          for (var j = 0; j < child.children.length; j++) {
            var relativeChild = child.children[j];
            if (relativeChild.name.indexOf("accidental") < 0) {
              if (!relativeChild.adjustedWidth)
                relativeChild.adjustedWidth = relativeChild.dx + firstChildNoteWidth;
              relativeChild.dx = relativeChild.adjustedWidth;
            }
          }
        }
      }
      var extraWidth = getExtraWidth(child, pad);
      if (er < extraWidth) {
        if (voice.i === 0 || child.type !== "bar" || voice.children[voice.i - 1].type !== "part" && voice.children[voice.i - 1].type !== "tempo")
          x += extraWidth - er;
      }
      child.setX(x);
      voice.spacingduration = child.duration;
      voice.minx = x + getMinWidth(child);
      if (voice.i !== voice.children.length - 1)
        voice.minx += child.minspacing;
      this.updateNextX(x, spacing, voice);
      return x;
    };
    VoiceElement.shiftRight = function(dx, voice) {
      var child = voice.children[voice.i];
      if (!child)
        return;
      child.setX(child.x + dx);
      voice.minx += dx;
      voice.nextx += dx;
    };
    VoiceElement.updateNextX = function(x, spacing, voice) {
      voice.nextx = x + spacing * Math.sqrt(voice.spacingduration * 8);
    };
    VoiceElement.updateIndices = function(voice) {
      if (!this.layoutEnded(voice)) {
        voice.durationindex += voice.children[voice.i].duration;
        if (voice.children[voice.i].type === "bar")
          voice.durationindex = Math.round(voice.durationindex * 64) / 64;
        voice.i++;
      }
    };
    function getExtraWidth(child, minPadding) {
      var padding = 0;
      if (child.type === "note" || child.type === "bar")
        padding = minPadding;
      return -child.extraw + padding;
    }
    function getMinWidth(child) {
      return child.w;
    }
    module.exports = VoiceElement;
  }
});

// node_modules/abcjs/src/write/layout/staffGroup.js
var require_staffGroup = __commonJS({
  "node_modules/abcjs/src/write/layout/staffGroup.js"(exports, module) {
    var layoutVoiceElements = require_VoiceElements();
    function checkLastBarX(voices) {
      var maxX = 0;
      for (var i = 0; i < voices.length; i++) {
        var curVoice = voices[i];
        if (curVoice.children.length > 0) {
          var lastChild = curVoice.children.length - 1;
          var maxChild = curVoice.children[lastChild];
          if (maxChild.abcelem.el_type === "bar") {
            var barX = maxChild.children[0].x;
            if (barX > maxX) {
              maxX = barX;
            } else {
              maxChild.children[0].x = maxX;
            }
          }
        }
      }
    }
    var layoutStaffGroup = function(spacing, renderer, debug, staffGroup, leftEdge) {
      var epsilon = 1e-7;
      var spacingunits = 0;
      var minspace = 1e3;
      var x = leftEdge;
      staffGroup.startx = x;
      var i;
      var currentduration = 0;
      if (debug)
        console.log("init layout", spacing);
      for (i = 0; i < staffGroup.voices.length; i++) {
        layoutVoiceElements.beginLayout(x, staffGroup.voices[i]);
      }
      var spacingunit = 0;
      while (!finished(staffGroup.voices)) {
        currentduration = null;
        for (i = 0; i < staffGroup.voices.length; i++) {
          if (!layoutVoiceElements.layoutEnded(staffGroup.voices[i]) && (!currentduration || getDurationIndex(staffGroup.voices[i]) < currentduration))
            currentduration = getDurationIndex(staffGroup.voices[i]);
        }
        var currentvoices = [];
        var othervoices = [];
        for (i = 0; i < staffGroup.voices.length; i++) {
          var durationIndex = getDurationIndex(staffGroup.voices[i]);
          if (durationIndex - currentduration > epsilon) {
            othervoices.push(staffGroup.voices[i]);
          } else {
            currentvoices.push(staffGroup.voices[i]);
          }
        }
        spacingunit = 0;
        var spacingduration = 0;
        for (i = 0; i < currentvoices.length; i++) {
          if (layoutVoiceElements.getNextX(currentvoices[i]) > x) {
            x = layoutVoiceElements.getNextX(currentvoices[i]);
            spacingunit = layoutVoiceElements.getSpacingUnits(currentvoices[i]);
            spacingduration = currentvoices[i].spacingduration;
          }
        }
        spacingunits += spacingunit;
        minspace = Math.min(minspace, spacingunit);
        if (debug)
          console.log("currentduration: ", currentduration, spacingunits, minspace);
        var lastTopVoice = void 0;
        for (i = 0; i < currentvoices.length; i++) {
          var v = currentvoices[i];
          if (v.voicenumber === 0)
            lastTopVoice = i;
          var topVoice = lastTopVoice !== void 0 && currentvoices[lastTopVoice].voicenumber !== v.voicenumber ? currentvoices[lastTopVoice] : void 0;
          if (!isSameStaff(v, topVoice))
            topVoice = void 0;
          var voicechildx = layoutVoiceElements.layoutOneItem(x, spacing, v, renderer.minPadding, topVoice);
          var dx = voicechildx - x;
          if (dx > 0) {
            x = voicechildx;
            for (var j = 0; j < i; j++) {
              layoutVoiceElements.shiftRight(dx, currentvoices[j]);
            }
          }
        }
        for (i = 0; i < othervoices.length; i++) {
          othervoices[i].spacingduration -= spacingduration;
          layoutVoiceElements.updateNextX(x, spacing, othervoices[i]);
        }
        for (i = 0; i < currentvoices.length; i++) {
          var voice = currentvoices[i];
          layoutVoiceElements.updateIndices(voice);
        }
      }
      for (i = 0; i < staffGroup.voices.length; i++) {
        if (layoutVoiceElements.getNextX(staffGroup.voices[i]) > x) {
          x = layoutVoiceElements.getNextX(staffGroup.voices[i]);
          spacingunit = layoutVoiceElements.getSpacingUnits(staffGroup.voices[i]);
        }
      }
      checkLastBarX(staffGroup.voices);
      spacingunits += spacingunit;
      staffGroup.setWidth(x);
      return { spacingUnits: spacingunits, minSpace: minspace };
    };
    function finished(voices) {
      for (var i = 0; i < voices.length; i++) {
        if (!layoutVoiceElements.layoutEnded(voices[i]))
          return false;
      }
      return true;
    }
    function getDurationIndex(element) {
      return element.durationindex - (element.children[element.i] && element.children[element.i].duration > 0 ? 0 : 5e-7);
    }
    function isSameStaff(voice1, voice2) {
      if (!voice1 || !voice1.staff || !voice1.staff.voices || voice1.staff.voices.length === 0)
        return false;
      if (!voice2 || !voice2.staff || !voice2.staff.voices || voice2.staff.voices.length === 0)
        return false;
      return voice1.staff.voices[0] === voice2.staff.voices[0];
    }
    module.exports = layoutStaffGroup;
  }
});

// node_modules/abcjs/src/write/layout/get-left-edge-of-staff.js
var require_get_left_edge_of_staff = __commonJS({
  "node_modules/abcjs/src/write/layout/get-left-edge-of-staff.js"(exports, module) {
    function getLeftEdgeOfStaff(renderer, getTextSize, voices, brace, bracket) {
      var x = renderer.padding.left;
      var voiceheaderw = 0;
      var i;
      var size;
      for (i = 0; i < voices.length; i++) {
        if (voices[i].header) {
          size = getTextSize.calc(voices[i].header, "voicefont", "");
          voiceheaderw = Math.max(voiceheaderw, size.width);
        }
      }
      voiceheaderw = addBraceSize(voiceheaderw, brace, getTextSize);
      voiceheaderw = addBraceSize(voiceheaderw, bracket, getTextSize);
      if (voiceheaderw) {
        var sizeW = getTextSize.calc("A", "voicefont", "");
        voiceheaderw += sizeW.width;
      }
      x += voiceheaderw;
      var ofs = 0;
      ofs = setBraceLocation(brace, x, ofs);
      ofs = setBraceLocation(bracket, x, ofs);
      return x + ofs;
    }
    function addBraceSize(voiceheaderw, brace, getTextSize) {
      if (brace) {
        for (var i = 0; i < brace.length; i++) {
          if (brace[i].header) {
            var size = getTextSize.calc(brace[i].header, "voicefont", "");
            voiceheaderw = Math.max(voiceheaderw, size.width);
          }
        }
      }
      return voiceheaderw;
    }
    function setBraceLocation(brace, x, ofs) {
      if (brace) {
        for (var i = 0; i < brace.length; i++) {
          setLocation(x, brace[i]);
          ofs = Math.max(ofs, brace[i].getWidth());
        }
      }
      return ofs;
    }
    function setLocation(x, element) {
      element.x = x;
    }
    module.exports = getLeftEdgeOfStaff;
  }
});

// node_modules/abcjs/src/write/layout/layout.js
var require_layout = __commonJS({
  "node_modules/abcjs/src/write/layout/layout.js"(exports, module) {
    var layoutVoice = require_voice();
    var setUpperAndLowerElements = require_setUpperAndLowerElements();
    var layoutStaffGroup = require_staffGroup();
    var getLeftEdgeOfStaff = require_get_left_edge_of_staff();
    var layout = function(renderer, abctune, width, space) {
      var i;
      var abcLine;
      var maxWidth = width;
      for (i = 0; i < abctune.lines.length; i++) {
        abcLine = abctune.lines[i];
        if (abcLine.staff) {
          setXSpacing(renderer, width, space, abcLine.staffGroup, abctune.formatting, i === abctune.lines.length - 1, false);
          if (abcLine.staffGroup.w > maxWidth)
            maxWidth = abcLine.staffGroup.w;
        }
      }
      for (i = 0; i < abctune.lines.length; i++) {
        abcLine = abctune.lines[i];
        if (abcLine.staffGroup && abcLine.staffGroup.voices) {
          for (var j = 0; j < abcLine.staffGroup.voices.length; j++)
            layoutVoice(abcLine.staffGroup.voices[j]);
          setUpperAndLowerElements(renderer, abcLine.staffGroup);
        }
      }
      for (i = 0; i < abctune.lines.length; i++) {
        abcLine = abctune.lines[i];
        if (abcLine.staffGroup) {
          abcLine.staffGroup.setHeight();
        }
      }
      return maxWidth;
    };
    var setXSpacing = function(renderer, width, space, staffGroup, formatting, isLastLine, debug) {
      var leftEdge = getLeftEdgeOfStaff(renderer, staffGroup.getTextSize, staffGroup.voices, staffGroup.brace, staffGroup.bracket);
      var newspace = space;
      for (var it = 0; it < 8; it++) {
        var ret = layoutStaffGroup(newspace, renderer, debug, staffGroup, leftEdge);
        newspace = calcHorizontalSpacing(isLastLine, formatting.stretchlast, width + renderer.padding.left, staffGroup.w, newspace, ret.spacingUnits, ret.minSpace, renderer.padding.left + renderer.padding.right);
        if (debug)
          console.log("setXSpace", it, staffGroup.w, newspace, staffGroup.minspace);
        if (newspace === null)
          break;
      }
      centerWholeRests(staffGroup.voices);
    };
    function calcHorizontalSpacing(isLastLine, stretchLast, targetWidth, lineWidth, spacing, spacingUnits, minSpace, padding) {
      if (isLastLine) {
        if (stretchLast === void 0) {
          if (lineWidth / targetWidth < 0.66)
            return null;
        } else {
          var lack = 1 - (lineWidth + padding) / targetWidth;
          var stretch = lack < stretchLast;
          if (!stretch)
            return null;
        }
      }
      if (Math.abs(targetWidth - lineWidth) < 2)
        return null;
      var relSpace = spacingUnits * spacing;
      var constSpace = lineWidth - relSpace;
      if (spacingUnits > 0) {
        spacing = (targetWidth - constSpace) / spacingUnits;
        if (spacing * minSpace > 50) {
          spacing = 50 / minSpace;
        }
        return spacing;
      }
      return null;
    }
    function centerWholeRests(voices) {
      for (var i = 0; i < voices.length; i++) {
        var voice = voices[i];
        for (var j = 1; j < voice.children.length - 1; j++) {
          var absElem = voice.children[j];
          if (absElem.abcelem.rest && (absElem.abcelem.rest.type === "whole" || absElem.abcelem.rest.type === "multimeasure")) {
            var before = voice.children[j - 1];
            var after = voice.children[j + 1];
            absElem.center(before, after);
          }
        }
      }
    }
    module.exports = layout;
  }
});

// node_modules/abcjs/src/write/classes.js
var require_classes = __commonJS({
  "node_modules/abcjs/src/write/classes.js"(exports, module) {
    var Classes = function Classes2(options) {
      this.shouldAddClasses = options.shouldAddClasses;
      this.reset();
    };
    Classes.prototype.reset = function() {
      this.lineNumber = null;
      this.voiceNumber = null;
      this.measureNumber = null;
      this.measureTotalPerLine = [];
      this.noteNumber = null;
    };
    Classes.prototype.incrLine = function() {
      if (this.lineNumber === null)
        this.lineNumber = 0;
      else
        this.lineNumber++;
      this.voiceNumber = null;
      this.measureNumber = null;
      this.noteNumber = null;
    };
    Classes.prototype.incrVoice = function() {
      if (this.voiceNumber === null)
        this.voiceNumber = 0;
      else
        this.voiceNumber++;
      this.measureNumber = null;
      this.noteNumber = null;
    };
    Classes.prototype.isInMeasure = function() {
      return this.measureNumber !== null;
    };
    Classes.prototype.newMeasure = function() {
      if (this.measureNumber)
        this.measureTotalPerLine[this.lineNumber] = this.measureNumber;
      this.measureNumber = null;
      this.noteNumber = null;
    };
    Classes.prototype.startMeasure = function() {
      this.measureNumber = 0;
      this.noteNumber = 0;
    };
    Classes.prototype.incrMeasure = function() {
      this.measureNumber++;
      this.noteNumber = 0;
    };
    Classes.prototype.incrNote = function() {
      this.noteNumber++;
    };
    Classes.prototype.measureTotal = function() {
      var total = 0;
      for (var i = 0; i < this.lineNumber; i++)
        total += this.measureTotalPerLine[i] ? this.measureTotalPerLine[i] : 0;
      if (this.measureNumber)
        total += this.measureNumber;
      return total;
    };
    Classes.prototype.getCurrent = function(c) {
      return {
        line: this.lineNumber,
        measure: this.measureNumber,
        measureTotal: this.measureTotal(),
        voice: this.voiceNumber,
        note: this.noteNumber
      };
    };
    Classes.prototype.generate = function(c) {
      if (!this.shouldAddClasses)
        return "";
      var ret = [];
      if (c && c.length > 0)
        ret.push(c);
      if (this.lineNumber !== null)
        ret.push("l" + this.lineNumber);
      if (this.measureNumber !== null)
        ret.push("m" + this.measureNumber);
      if (this.measureNumber !== null)
        ret.push("mm" + this.measureTotal());
      if (this.voiceNumber !== null)
        ret.push("v" + this.voiceNumber);
      if (c && (c.indexOf("note") >= 0 || c.indexOf("rest") >= 0 || c.indexOf("lyric") >= 0) && this.noteNumber !== null)
        ret.push("n" + this.noteNumber);
      if (ret.length > 0) {
        ret = ret.join(" ");
        ret = ret.split(" ");
        for (var i = 0; i < ret.length; i++) {
          if (ret[i].indexOf("abcjs-") !== 0 && ret[i].length > 0)
            ret[i] = "abcjs-" + ret[i];
        }
      }
      return ret.join(" ");
    };
    module.exports = Classes;
  }
});

// node_modules/abcjs/src/write/get-font-and-attr.js
var require_get_font_and_attr = __commonJS({
  "node_modules/abcjs/src/write/get-font-and-attr.js"(exports, module) {
    var GetFontAndAttr = function GetFontAndAttr2(formatting, classes) {
      this.formatting = formatting;
      this.classes = classes;
    };
    GetFontAndAttr.prototype.updateFonts = function(fontOverrides) {
      if (fontOverrides.gchordfont)
        this.formatting.gchordfont = fontOverrides.gchordfont;
      if (fontOverrides.tripletfont)
        this.formatting.tripletfont = fontOverrides.tripletfont;
      if (fontOverrides.annotationfont)
        this.formatting.annotationfont = fontOverrides.annotationfont;
      if (fontOverrides.vocalfont)
        this.formatting.vocalfont = fontOverrides.vocalfont;
    };
    GetFontAndAttr.prototype.calc = function(type, klass) {
      var font;
      if (typeof type === "string") {
        font = this.formatting[type];
        if (font)
          font = { face: font.face, size: Math.round(font.size * 4 / 3), decoration: font.decoration, style: font.style, weight: font.weight, box: font.box };
        else
          font = { face: "Arial", size: Math.round(12 * 4 / 3), decoration: "underline", style: "normal", weight: "normal" };
      } else
        font = { face: type.face, size: Math.round(type.size * 4 / 3), decoration: type.decoration, style: type.style, weight: type.weight, box: type.box };
      var paddingPercent = this.formatting.fontboxpadding ? this.formatting.fontboxpadding : 0.1;
      font.padding = font.size * paddingPercent;
      var attr = {
        "font-size": font.size,
        "font-style": font.style,
        "font-family": font.face,
        "font-weight": font.weight,
        "text-decoration": font.decoration,
        "class": this.classes.generate(klass)
      };
      return { font, attr };
    };
    module.exports = GetFontAndAttr;
  }
});

// node_modules/abcjs/src/write/get-text-size.js
var require_get_text_size = __commonJS({
  "node_modules/abcjs/src/write/get-text-size.js"(exports, module) {
    var GetTextSize = function GetTextSize2(getFontAndAttr, svg) {
      this.getFontAndAttr = getFontAndAttr;
      this.svg = svg;
    };
    GetTextSize.prototype.updateFonts = function(fontOverrides) {
      this.getFontAndAttr.updateFonts(fontOverrides);
    };
    GetTextSize.prototype.attr = function(type, klass) {
      return this.getFontAndAttr.calc(type, klass);
    };
    GetTextSize.prototype.calc = function(text, type, klass, el) {
      var hash;
      if (typeof type === "string")
        hash = this.attr(type, klass);
      else {
        hash = {
          font: {
            face: type.face,
            size: type.size,
            decoration: type.decoration,
            style: type.style,
            weight: type.weight
          },
          attr: {
            "font-size": type.size,
            "font-style": type.style,
            "font-family": type.face,
            "font-weight": type.weight,
            "text-decoration": type.decoration,
            "class": this.getFontAndAttr.classes.generate(klass)
          }
        };
      }
      var size = this.svg.getTextSize(text, hash.attr, el);
      if (hash.font.box) {
        return { height: size.height + hash.font.padding * 4, width: size.width + hash.font.padding * 4 };
      }
      return size;
    };
    GetTextSize.prototype.baselineToCenter = function(text, type, klass, index, total) {
      var height = this.calc(text, type, klass).height;
      var fontHeight = this.attr(type, klass).font.size;
      return height * 0.5 + (total - index - 2) * fontHeight;
    };
    module.exports = GetTextSize;
  }
});

// node_modules/abcjs/src/write/draw/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/abcjs/src/write/draw/sprintf.js"(exports, module) {
    var sprintf = function() {
      var i = 0, a, f = arguments[i++], o = [], m, p, c, x;
      while (f) {
        if (m = /^[^\x25]+/.exec(f))
          o.push(m[0]);
        else if (m = /^\x25{2}/.exec(f))
          o.push("%");
        else if (m = /^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(f)) {
          if ((a = arguments[m[1] || i++]) == null || a == void 0)
            throw "Too few arguments.";
          if (/[^s]/.test(m[7]) && typeof a != "number")
            throw "Expecting number but found " + typeof a;
          switch (m[7]) {
            case "b":
              a = a.toString(2);
              break;
            case "c":
              a = String.fromCharCode(a);
              break;
            case "d":
              a = parseInt(a);
              break;
            case "e":
              a = m[6] ? a.toExponential(m[6]) : a.toExponential();
              break;
            case "f":
              a = m[6] ? parseFloat(a).toFixed(m[6]) : parseFloat(a);
              break;
            case "o":
              a = a.toString(8);
              break;
            case "s":
              a = (a = String(a)) && m[6] ? a.substring(0, m[6]) : a;
              break;
            case "u":
              a = Math.abs(a);
              break;
            case "x":
              a = a.toString(16);
              break;
            case "X":
              a = a.toString(16).toUpperCase();
              break;
          }
          a = /[def]/.test(m[7]) && m[2] && a > 0 ? "+" + a : a;
          c = m[3] ? m[3] == "0" ? "0" : m[3].charAt(1) : " ";
          x = m[5] - String(a).length;
          p = m[5] ? str_repeat(c, x) : "";
          o.push(m[4] ? a + p : p + a);
        } else
          throw "Huh ?!";
        f = f.substring(m[0].length);
      }
      return o.join("");
    };
    module.exports = sprintf;
  }
});

// node_modules/abcjs/src/write/draw/round-number.js
var require_round_number = __commonJS({
  "node_modules/abcjs/src/write/draw/round-number.js"(exports, module) {
    function roundNumber(x) {
      return parseFloat(x.toFixed(2));
    }
    module.exports = roundNumber;
  }
});

// node_modules/abcjs/src/write/draw/text.js
var require_text2 = __commonJS({
  "node_modules/abcjs/src/write/draw/text.js"(exports, module) {
    var roundNumber = require_round_number();
    function renderText(renderer, params, alreadyInGroup) {
      var y = params.y;
      if (params.lane) {
        var laneMargin = params.dim.font.size * 0.25;
        y += (params.dim.font.size + laneMargin) * params.lane;
      }
      var hash;
      if (params.dim) {
        hash = params.dim;
        hash.attr.class = params.klass;
      } else
        hash = renderer.controller.getFontAndAttr.calc(params.type, params.klass);
      if (params.anchor)
        hash.attr["text-anchor"] = params.anchor;
      hash.attr.x = params.x;
      hash.attr.y = y;
      if (!params.centerVertically)
        hash.attr.y += hash.font.size;
      if (params.type === "debugfont") {
        console.log("Debug msg: " + params.text);
        hash.attr.stroke = "#ff0000";
      }
      if (params.cursor) {
        hash.attr.cursor = params.cursor;
      }
      var text = params.text.replace(/\n\n/g, "\n \n");
      text = text.replace(/^\n/, "\xA0\n");
      if (hash.font.box) {
        if (!alreadyInGroup)
          renderer.paper.openGroup({ klass: hash.attr["class"], fill: renderer.foregroundColor, "data-name": params.name });
        if (hash.attr["text-anchor"] === "end") {
          hash.attr.x -= hash.font.padding;
        } else if (hash.attr["text-anchor"] === "start") {
          hash.attr.x += hash.font.padding;
        }
        hash.attr.y += hash.font.padding;
        delete hash.attr["class"];
      }
      if (params.noClass)
        delete hash.attr["class"];
      hash.attr.x = roundNumber(hash.attr.x);
      hash.attr.y = roundNumber(hash.attr.y);
      if (params.name)
        hash.attr["data-name"] = params.name;
      var elem = renderer.paper.text(text, hash.attr);
      if (hash.font.box) {
        var size = elem.getBBox();
        var delta = 0;
        if (hash.attr["text-anchor"] === "middle") {
          delta = size.width / 2 + hash.font.padding;
        } else if (hash.attr["text-anchor"] === "end") {
          delta = size.width + hash.font.padding * 2;
        }
        var deltaY = 0;
        if (params.centerVertically) {
          deltaY = size.height - hash.font.padding;
        }
        renderer.paper.rect({ "data-name": "box", x: Math.round(params.x - delta), y: Math.round(y - deltaY), width: Math.round(size.width + hash.font.padding * 2), height: Math.round(size.height + hash.font.padding * 2) });
        if (!alreadyInGroup)
          elem = renderer.paper.closeGroup();
      }
      return elem;
    }
    module.exports = renderText;
  }
});

// node_modules/abcjs/src/write/draw/brace.js
var require_brace = __commonJS({
  "node_modules/abcjs/src/write/draw/brace.js"(exports, module) {
    var sprintf = require_sprintf();
    var spacing = require_abc_spacing();
    var renderText = require_text2();
    function drawBrace(renderer, params, selectables) {
      var startY = params.startVoice.staff.absoluteY - spacing.STEP * 10;
      if (params.endVoice && params.endVoice.staff)
        params.endY = params.endVoice.staff.absoluteY - spacing.STEP * 2;
      else if (params.lastContinuedVoice && params.lastContinuedVoice.staff)
        params.endY = params.lastContinuedVoice.staff.absoluteY - spacing.STEP * 2;
      else
        params.endY = params.startVoice.staff.absoluteY - spacing.STEP * 2;
      return draw(renderer, params.x, startY, params.endY, params.type, params.header, selectables);
    }
    function straightPath(renderer, xLeft, yTop, yBottom, type) {
      xLeft += spacing.STEP;
      var xLineWidth = spacing.STEP * 0.75;
      var yOverlap = spacing.STEP * 0.75;
      var height = yBottom - yTop;
      var pathString = sprintf("M %f %f l %f %f l %f %f l %f %f z", xLeft, yTop - yOverlap, 0, height + yOverlap * 2, xLineWidth, 0, 0, -(height + yOverlap * 2));
      var wCurve = spacing.STEP * 2;
      var hCurve = spacing.STEP;
      pathString += sprintf("M %f %f q %f %f %f %f q %f %f %f %f z", xLeft + xLineWidth, yTop - yOverlap, wCurve * 0.6, hCurve * 0.2, wCurve, -hCurve, -wCurve * 0.1, hCurve * 0.3, -wCurve, hCurve + spacing.STEP);
      pathString += sprintf("M %f %f q %f %f %f %f q %f %f %f %f z", xLeft + xLineWidth, yTop + yOverlap + height, wCurve * 0.6, -hCurve * 0.2, wCurve, hCurve, -wCurve * 0.1, -hCurve * 0.3, -wCurve, -hCurve - spacing.STEP);
      return renderer.paper.path({ path: pathString, stroke: renderer.foregroundColor, fill: renderer.foregroundColor, "class": renderer.controller.classes.generate(type), "data-name": type });
    }
    function curvyPath(renderer, xLeft, yTop, yBottom, type) {
      var yHeight = yBottom - yTop;
      var pathString = curve(xLeft, yTop, [7.5, -8, 21, 0, 18.5, -10.5, 7.5], [0, yHeight / 5.5, yHeight / 3.14, yHeight / 2, yHeight / 2.93, yHeight / 4.88, 0]);
      pathString += curve(xLeft, yTop, [0, 17.5, -7.5, 6.6, -5, 20, 0], [yHeight / 2, yHeight / 1.46, yHeight / 1.22, yHeight, yHeight / 1.19, yHeight / 1.42, yHeight / 2]);
      return renderer.paper.path({ path: pathString, stroke: renderer.foregroundColor, fill: renderer.foregroundColor, "class": renderer.controller.classes.generate(type), "data-name": type });
    }
    function curve(xLeft, yTop, xCurve, yCurve) {
      return sprintf("M %f %f C %f %f %f %f %f %f C %f %f %f %f %f %f z", xLeft + xCurve[0], yTop + yCurve[0], xLeft + xCurve[1], yTop + yCurve[1], xLeft + xCurve[2], yTop + yCurve[2], xLeft + xCurve[3], yTop + yCurve[3], xLeft + xCurve[4], yTop + yCurve[4], xLeft + xCurve[5], yTop + yCurve[5], xLeft + xCurve[6], yTop + yCurve[6]);
    }
    var draw = function(renderer, xLeft, yTop, yBottom, type, header, selectables) {
      var ret;
      if (header) {
        renderer.paper.openGroup({ klass: renderer.controller.classes.generate("staff-extra voice-name"), "data-name": type });
        var position = yTop + (yBottom - yTop) / 2;
        position = position - renderer.controller.getTextSize.baselineToCenter(header, "voicefont", "staff-extra voice-name", 0, 1);
        renderText(renderer, {
          x: renderer.padding.left,
          y: position,
          text: header,
          type: "voicefont",
          klass: "staff-extra voice-name",
          anchor: "start",
          centerVertically: true
        });
      }
      if (type === "brace")
        ret = curvyPath(renderer, xLeft, yTop, yBottom, type);
      else if (type === "bracket")
        ret = straightPath(renderer, xLeft, yTop, yBottom, type);
      if (header) {
        ret = renderer.paper.closeGroup();
      }
      selectables.wrapSvgEl({ el_type: type, startChar: -1, endChar: -1 }, ret);
      return ret;
    };
    module.exports = drawBrace;
  }
});

// node_modules/abcjs/src/write/draw/print-path.js
var require_print_path = __commonJS({
  "node_modules/abcjs/src/write/draw/print-path.js"(exports, module) {
    function printPath(renderer, attrs, params) {
      var ret = renderer.paper.path(attrs);
      return ret;
    }
    module.exports = printPath;
  }
});

// node_modules/abcjs/src/write/draw/crescendo.js
var require_crescendo = __commonJS({
  "node_modules/abcjs/src/write/draw/crescendo.js"(exports, module) {
    var sprintf = require_sprintf();
    var printPath = require_print_path();
    var roundNumber = require_round_number();
    function drawCrescendo(renderer, params, selectables) {
      if (params.pitch === void 0)
        window.console.error("Crescendo Element y-coordinate not set.");
      var y = renderer.calcY(params.pitch) + 4;
      var height = 8;
      var left = params.anchor1 ? params.anchor1.x : 0;
      var right = params.anchor2 ? params.anchor2.x : 800;
      var el;
      if (params.dir === "<") {
        el = drawLine(renderer, y + height / 2, y, y + height / 2, y + height, left, right);
      } else {
        el = drawLine(renderer, y, y + height / 2, y + height, y + height / 2, left, right);
      }
      selectables.wrapSvgEl({ el_type: "dynamicDecoration", startChar: -1, endChar: -1 }, el);
      return [el];
    }
    var drawLine = function(renderer, y1, y2, y3, y4, left, right) {
      y1 = roundNumber(y1);
      y2 = roundNumber(y2);
      y3 = roundNumber(y3);
      y4 = roundNumber(y4);
      left = roundNumber(left);
      right = roundNumber(right);
      var pathString = sprintf("M %f %f L %f %f M %f %f L %f %f", left, y1, right, y2, left, y3, right, y4);
      return printPath(renderer, { path: pathString, highlight: "stroke", stroke: renderer.foregroundColor, "class": renderer.controller.classes.generate("dynamics decoration"), "data-name": "dynamics" });
    };
    module.exports = drawCrescendo;
  }
});

// node_modules/abcjs/src/write/draw/group-elements.js
var require_group_elements = __commonJS({
  "node_modules/abcjs/src/write/draw/group-elements.js"(exports, module) {
    var roundNumber = require_round_number();
    function Group() {
      this.ingroup = false;
    }
    Group.prototype.beginGroup = function(paper, controller) {
      this.paper = paper;
      this.controller = controller;
      this.path = [];
      this.lastM = [0, 0];
      this.ingroup = true;
      this.paper.openGroup();
    };
    Group.prototype.isInGroup = function() {
      return this.ingroup;
    };
    Group.prototype.addPath = function(path) {
      path = path || [];
      if (path.length === 0)
        return;
      path[0][0] = "m";
      path[0][1] = roundNumber(path[0][1] - this.lastM[0]);
      path[0][2] = roundNumber(path[0][2] - this.lastM[1]);
      this.lastM[0] += path[0][1];
      this.lastM[1] += path[0][2];
      this.path.push(path[0]);
      for (var i = 1, ii = path.length; i < ii; i++) {
        if (path[i][0] === "m") {
          this.lastM[0] += path[i][1];
          this.lastM[1] += path[i][2];
        }
        this.path.push(path[i]);
      }
    };
    Group.prototype.endGroup = function(klass, name) {
      this.ingroup = false;
      var path = "";
      for (var i = 0; i < this.path.length; i++)
        path += this.path[i].join(" ");
      this.path = [];
      var ret = this.paper.closeGroup();
      if (ret) {
        ret.setAttribute("class", this.controller.classes.generate(klass));
        ret.setAttribute("fill", this.controller.renderer.foregroundColor);
        ret.setAttribute("stroke", "none");
        ret.setAttribute("data-name", name);
      }
      return ret;
    };
    var elementGroup = new Group();
    module.exports = elementGroup;
  }
});

// node_modules/abcjs/src/write/draw/print-symbol.js
var require_print_symbol = __commonJS({
  "node_modules/abcjs/src/write/draw/print-symbol.js"(exports, module) {
    var renderText = require_text2();
    var glyphs = require_abc_glyphs();
    var elementGroup = require_group_elements();
    function printSymbol(renderer, x, offset, symbol, options) {
      var el;
      var ycorr;
      if (!symbol)
        return null;
      if (symbol.length > 1 && symbol.indexOf(".") < 0) {
        var groupClass = elementGroup.isInGroup() ? "" : options.klass;
        renderer.paper.openGroup({ "data-name": options.name, klass: groupClass });
        var dx = 0;
        for (var i = 0; i < symbol.length; i++) {
          var s = symbol.charAt(i);
          ycorr = glyphs.getYCorr(s);
          el = glyphs.printSymbol(x + dx, renderer.calcY(offset + ycorr), s, renderer.paper, { stroke: options.stroke, fill: options.fill });
          if (el) {
            if (i < symbol.length - 1)
              dx += kernSymbols(s, symbol.charAt(i + 1), glyphs.getSymbolWidth(s));
          } else {
            renderText(renderer, { x, y: renderer.y, text: "no symbol:" + symbol, type: "debugfont", klass: "debug-msg", anchor: "start" }, false);
          }
        }
        var g = renderer.paper.closeGroup();
        return g;
      } else {
        ycorr = glyphs.getYCorr(symbol);
        if (elementGroup.isInGroup()) {
          el = glyphs.printSymbol(x, renderer.calcY(offset + ycorr), symbol, renderer.paper, { "data-name": options.name });
        } else {
          el = glyphs.printSymbol(x, renderer.calcY(offset + ycorr), symbol, renderer.paper, { klass: options.klass, stroke: options.stroke, fill: options.fill, "data-name": options.name });
        }
        if (el) {
          return el;
        }
        renderText(renderer, { x, y: renderer.y, text: "no symbol:" + symbol, type: "debugfont", klass: "debug-msg", anchor: "start" }, false);
        return null;
      }
    }
    function kernSymbols(lastSymbol, thisSymbol, lastSymbolWidth) {
      var width = lastSymbolWidth;
      if (lastSymbol === "f" && thisSymbol === "f")
        width = width * 2 / 3;
      if (lastSymbol === "p" && thisSymbol === "p")
        width = width * 5 / 6;
      if (lastSymbol === "f" && thisSymbol === "z")
        width = width * 5 / 8;
      return width;
    }
    module.exports = printSymbol;
  }
});

// node_modules/abcjs/src/write/draw/dynamics.js
var require_dynamics = __commonJS({
  "node_modules/abcjs/src/write/draw/dynamics.js"(exports, module) {
    var printSymbol = require_print_symbol();
    function drawDynamics(renderer, params, selectables) {
      if (params.pitch === void 0)
        window.console.error("Dynamic Element y-coordinate not set.");
      var scalex = 1;
      var scaley = 1;
      var el = printSymbol(renderer, params.anchor.x, params.pitch, params.dec, {
        scalex,
        scaley,
        klass: renderer.controller.classes.generate("decoration dynamics"),
        fill: renderer.foregroundColor,
        stroke: "none",
        name: "dynamics"
      });
      selectables.wrapSvgEl({ el_type: "dynamicDecoration", startChar: -1, endChar: -1, decoration: params.dec }, el);
      return [el];
    }
    module.exports = drawDynamics;
  }
});

// node_modules/abcjs/src/write/draw/triplet.js
var require_triplet2 = __commonJS({
  "node_modules/abcjs/src/write/draw/triplet.js"(exports, module) {
    var sprintf = require_sprintf();
    var renderText = require_text2();
    var printPath = require_print_path();
    var roundNumber = require_round_number();
    function drawTriplet(renderer, params, selectables) {
      renderer.paper.openGroup({ klass: renderer.controller.classes.generate("triplet " + params.durationClass), "data-name": "triplet" });
      if (!params.hasBeam) {
        drawBracket(renderer, params.anchor1.x, params.startNote, params.anchor2.x + params.anchor2.w, params.endNote);
      }
      renderText(renderer, { x: params.xTextPos, y: renderer.calcY(params.yTextPos - 1), text: "" + params.number, type: "tripletfont", anchor: "middle", centerVertically: true, noClass: true, name: "" + params.number }, true);
      var g = renderer.paper.closeGroup();
      selectables.wrapSvgEl({ el_type: "triplet", startChar: -1, endChar: -1 }, g);
      return g;
    }
    function drawLine(l, t, r, b) {
      return sprintf("M %f %f L %f %f", roundNumber(l), roundNumber(t), roundNumber(r), roundNumber(b));
    }
    function drawBracket(renderer, x1, y1, x2, y2) {
      y1 = renderer.calcY(y1);
      y2 = renderer.calcY(y2);
      var bracketHeight = 5;
      var pathString = "";
      pathString += drawLine(x1, y1, x1, y1 + bracketHeight);
      pathString += drawLine(x2, y2, x2, y2 + bracketHeight);
      var midX = x1 + (x2 - x1) / 2;
      var gapWidth = 8;
      var slope = (y2 - y1) / (x2 - x1);
      var leftEndX = midX - gapWidth;
      var leftEndY = y1 + (leftEndX - x1) * slope;
      pathString += drawLine(x1, y1, leftEndX, leftEndY);
      var rightStartX = midX + gapWidth;
      var rightStartY = y1 + (rightStartX - x1) * slope;
      pathString += drawLine(rightStartX, rightStartY, x2, y2);
      printPath(renderer, { path: pathString, stroke: renderer.foregroundColor, "data-name": "triplet-bracket" });
    }
    module.exports = drawTriplet;
  }
});

// node_modules/abcjs/src/write/draw/ending.js
var require_ending = __commonJS({
  "node_modules/abcjs/src/write/draw/ending.js"(exports, module) {
    var sprintf = require_sprintf();
    var renderText = require_text2();
    var printPath = require_print_path();
    var roundNumber = require_round_number();
    function drawEnding(renderer, params, linestartx, lineendx, selectables) {
      if (params.pitch === void 0)
        window.console.error("Ending Element y-coordinate not set.");
      var y = roundNumber(renderer.calcY(params.pitch));
      var height = 20;
      var pathString = "";
      if (params.anchor1) {
        linestartx = roundNumber(params.anchor1.x + params.anchor1.w);
        pathString += sprintf("M %f %f L %f %f ", linestartx, y, linestartx, roundNumber(y + height));
      }
      if (params.anchor2) {
        lineendx = roundNumber(params.anchor2.x);
        pathString += sprintf("M %f %f L %f %f ", lineendx, y, lineendx, roundNumber(y + height));
      }
      pathString += sprintf("M %f %f L %f %f ", linestartx, y, lineendx, y);
      renderer.paper.openGroup({ klass: renderer.controller.classes.generate("ending"), "data-name": "ending" });
      printPath(renderer, { path: pathString, stroke: renderer.foregroundColor, fill: renderer.foregroundColor, "data-name": "line" });
      if (params.anchor1)
        renderText(renderer, {
          x: roundNumber(linestartx + 5),
          y: roundNumber(renderer.calcY(params.pitch - 0.5)),
          text: params.text,
          type: "repeatfont",
          klass: "ending",
          anchor: "start",
          noClass: true,
          name: params.text
        });
      var g = renderer.paper.closeGroup();
      selectables.wrapSvgEl({ el_type: "ending", startChar: -1, endChar: -1 }, g);
      return [g];
    }
    module.exports = drawEnding;
  }
});

// node_modules/abcjs/src/write/draw/tie.js
var require_tie = __commonJS({
  "node_modules/abcjs/src/write/draw/tie.js"(exports, module) {
    var sprintf = require_sprintf();
    var roundNumber = require_round_number();
    function drawTie(renderer, params, linestartx, lineendx, selectables) {
      layout(params, linestartx, lineendx);
      var klass = "";
      if (params.anchor1) {
        klass += "abcjs-start-m" + params.anchor1.parent.counters.measure + "-n" + params.anchor1.parent.counters.note;
      } else
        klass += "abcjs-start-edge";
      if (params.anchor2) {
        klass += " abcjs-end-m" + params.anchor2.parent.counters.measure + "-n" + params.anchor2.parent.counters.note;
      } else
        klass += " abcjs-end-edge";
      if (params.hint)
        klass = "abcjs-hint";
      var fudgeY = params.fixedY ? 1.5 : 0;
      var el = drawArc(renderer, params.startX, params.endX, params.startY + fudgeY, params.endY + fudgeY, params.above, klass, params.isTie, params.dotted);
      selectables.wrapSvgEl({ el_type: "slur", startChar: -1, endChar: -1 }, el);
      return [el];
    }
    var layout = function(params, lineStartX, lineEndX) {
      if (!params.anchor1 || !params.anchor2)
        params.isTie = true;
      else if (params.anchor1.pitch === params.anchor2.pitch && params.internalNotes.length === 0)
        params.isTie = true;
      else
        params.isTie = false;
      if (params.isTie) {
        params.calcTieDirection();
        params.calcX(lineStartX, lineEndX);
        params.calcTieY();
      } else {
        params.calcSlurDirection();
        params.calcX(lineStartX, lineEndX);
        params.calcSlurY();
      }
      params.avoidCollisionAbove();
    };
    var drawArc = function(renderer, x1, x2, pitch1, pitch2, above, klass, isTie, dotted) {
      var spacing = isTie ? 1.2 : 1.5;
      x1 = roundNumber(x1 + 6);
      x2 = roundNumber(x2 + 4);
      pitch1 = pitch1 + (above ? spacing : -spacing);
      pitch2 = pitch2 + (above ? spacing : -spacing);
      var y1 = roundNumber(renderer.calcY(pitch1));
      var y2 = roundNumber(renderer.calcY(pitch2));
      var dx = x2 - x1;
      var dy = y2 - y1;
      var norm = Math.sqrt(dx * dx + dy * dy);
      var ux = dx / norm;
      var uy = dy / norm;
      var flatten = norm / 3.5;
      var maxFlatten = isTie ? 10 : 25;
      var curve = (above ? -1 : 1) * Math.min(maxFlatten, Math.max(4, flatten));
      var controlx1 = roundNumber(x1 + flatten * ux - curve * uy);
      var controly1 = roundNumber(y1 + flatten * uy + curve * ux);
      var controlx2 = roundNumber(x2 - flatten * ux - curve * uy);
      var controly2 = roundNumber(y2 - flatten * uy + curve * ux);
      var thickness = 2;
      if (klass)
        klass += " slur";
      else
        klass = "slur";
      klass += isTie ? " tie" : " legato";
      var ret;
      if (dotted) {
        klass += " dotted";
        var pathString2 = sprintf("M %f %f C %f %f %f %f %f %f", x1, y1, controlx1, controly1, controlx2, controly2, x2, y2);
        ret = renderer.paper.path({ path: pathString2, stroke: renderer.foregroundColor, fill: "none", "stroke-dasharray": "5 5", "class": renderer.controller.classes.generate(klass), "data-name": isTie ? "tie" : "slur" });
      } else {
        var pathString = sprintf("M %f %f C %f %f %f %f %f %f C %f %f %f %f %f %f z", x1, y1, controlx1, controly1, controlx2, controly2, x2, y2, roundNumber(controlx2 - thickness * uy), roundNumber(controly2 + thickness * ux), roundNumber(controlx1 - thickness * uy), roundNumber(controly1 + thickness * ux), x1, y1);
        ret = renderer.paper.path({ path: pathString, stroke: "none", fill: renderer.foregroundColor, "class": renderer.controller.classes.generate(klass), "data-name": isTie ? "tie" : "slur" });
      }
      return ret;
    };
    module.exports = drawTie;
  }
});

// node_modules/abcjs/src/write/draw/beam.js
var require_beam2 = __commonJS({
  "node_modules/abcjs/src/write/draw/beam.js"(exports, module) {
    var printPath = require_print_path();
    var roundNumber = require_round_number();
    function drawBeam(renderer, params) {
      if (params.beams.length === 0)
        return;
      var pathString = "";
      for (var i = 0; i < params.beams.length; i++) {
        var beam = params.beams[i];
        if (beam.split) {
          var slope = getSlope(renderer, beam.startX, beam.startY, beam.endX, beam.endY);
          var xes = [];
          for (var j = 0; j < beam.split.length; j += 2) {
            xes.push([beam.split[j], beam.split[j + 1]]);
          }
          for (j = 0; j < xes.length; j++) {
            var y1 = getY(beam.startX, beam.startY, slope, xes[j][0]);
            var y2 = getY(beam.startX, beam.startY, slope, xes[j][1]);
            pathString += draw(renderer, xes[j][0], y1, xes[j][1], y2, beam.dy);
          }
        } else
          pathString += draw(renderer, beam.startX, beam.startY, beam.endX, beam.endY, beam.dy);
      }
      var durationClass = ("abcjs-d" + params.duration).replace(/\./g, "-");
      var klasses = renderer.controller.classes.generate("beam-elem " + durationClass);
      var el = printPath(renderer, {
        path: pathString,
        stroke: "none",
        fill: renderer.foregroundColor,
        "class": klasses
      });
      return [el];
    }
    function draw(renderer, startX, startY, endX, endY, dy) {
      startY = roundNumber(renderer.calcY(startY));
      endY = roundNumber(renderer.calcY(endY));
      startX = roundNumber(startX);
      endX = roundNumber(endX);
      var startY2 = roundNumber(startY + dy);
      var endY2 = roundNumber(endY + dy);
      return "M" + startX + " " + startY + " L" + endX + " " + endY + "L" + endX + " " + endY2 + " L" + startX + " " + startY2 + "z";
    }
    function getSlope(renderer, startX, startY, endX, endY) {
      return (endY - startY) / (endX - startX);
    }
    function getY(startX, startY, slope, currentX) {
      var x = currentX - startX;
      return startY + x * slope;
    }
    module.exports = drawBeam;
  }
});

// node_modules/abcjs/src/write/draw/print-stem.js
var require_print_stem = __commonJS({
  "node_modules/abcjs/src/write/draw/print-stem.js"(exports, module) {
    var elementGroup = require_group_elements();
    var roundNumber = require_round_number();
    function printStem(renderer, x, dx, y1, y2, klass, name) {
      if (dx < 0 || y1 < y2) {
        var tmp = roundNumber(y2);
        y2 = roundNumber(y1);
        y1 = tmp;
      } else {
        y1 = roundNumber(y1);
        y2 = roundNumber(y2);
      }
      x = roundNumber(x);
      var x2 = roundNumber(x + dx);
      var pathArray = [["M", x, y1], ["L", x, y2], ["L", x2, y2], ["L", x2, y1], ["z"]];
      var attr = { path: "" };
      for (var i = 0; i < pathArray.length; i++)
        attr.path += pathArray[i].join(" ");
      if (klass)
        attr["class"] = klass;
      if (name)
        attr["data-name"] = name;
      if (!elementGroup.isInGroup()) {
        attr.stroke = "none";
        attr.fill = renderer.foregroundColor;
      }
      return renderer.paper.pathToBack(attr);
    }
    module.exports = printStem;
  }
});

// node_modules/abcjs/src/write/draw/print-line.js
var require_print_line = __commonJS({
  "node_modules/abcjs/src/write/draw/print-line.js"(exports, module) {
    var sprintf = require_sprintf();
    var roundNumber = require_round_number();
    function printLine(renderer, x1, x2, y, klass, name, dy) {
      if (!dy)
        dy = 0.35;
      var fill = renderer.foregroundColor;
      x1 = roundNumber(x1);
      x2 = roundNumber(x2);
      var y1 = roundNumber(y - dy);
      var y2 = roundNumber(y + dy);
      var pathString = sprintf("M %f %f L %f %f L %f %f L %f %f z", x1, y1, x2, y1, x2, y2, x1, y2);
      var options = { path: pathString, stroke: "none", fill };
      if (name)
        options["data-name"] = name;
      if (klass)
        options["class"] = klass;
      var ret = renderer.paper.pathToBack(options);
      return ret;
    }
    module.exports = printLine;
  }
});

// node_modules/abcjs/src/write/draw/staff-line.js
var require_staff_line = __commonJS({
  "node_modules/abcjs/src/write/draw/staff-line.js"(exports, module) {
    var printLine = require_print_line();
    function printStaffLine(renderer, x1, x2, pitch, klass, name, dy) {
      var y = renderer.calcY(pitch);
      return printLine(renderer, x1, x2, y, klass, name, dy);
    }
    module.exports = printStaffLine;
  }
});

// node_modules/abcjs/src/write/draw/relative.js
var require_relative = __commonJS({
  "node_modules/abcjs/src/write/draw/relative.js"(exports, module) {
    var renderText = require_text2();
    var printStem = require_print_stem();
    var printStaffLine = require_staff_line();
    var printSymbol = require_print_symbol();
    function drawRelativeElement(renderer, params, bartop) {
      if (params.pitch === void 0)
        window.console.error(params.type + " Relative Element y-coordinate not set.");
      var y = renderer.calcY(params.pitch);
      switch (params.type) {
        case "symbol":
          if (params.c === null)
            return null;
          var klass = "symbol";
          if (params.klass)
            klass += " " + params.klass;
          params.graphelem = printSymbol(renderer, params.x, params.pitch, params.c, {
            scalex: params.scalex,
            scaley: params.scaley,
            klass: renderer.controller.classes.generate(klass),
            name: params.name
          });
          break;
        case "debug":
          params.graphelem = renderText(renderer, { x: params.x, y: renderer.calcY(15), text: "" + params.c, type: "debugfont", klass: renderer.controller.classes.generate("debug-msg"), anchor: "start", centerVertically: false, dim: params.dim }, false);
          break;
        case "tabNumber":
          var hAnchor = "middle";
          var tabFont = "tabnumberfont";
          var tabClass = "tab-number";
          if (params.isGrace) {
            tabFont = "tabgracefont";
            y += 2.5;
            tabClass = "tab-grace";
          }
          params.graphelem = renderText(renderer, { x: params.x, y, text: "" + params.c, type: tabFont, klass: renderer.controller.classes.generate(tabClass), anchor: hAnchor, centerVertically: false, dim: params.dim, cursor: "default" }, false);
          break;
        case "barNumber":
          params.graphelem = renderText(renderer, { x: params.x, y, text: "" + params.c, type: "measurefont", klass: renderer.controller.classes.generate("bar-number"), anchor: "middle", dim: params.dim, name: "bar-number" }, true);
          break;
        case "lyric":
          params.graphelem = renderText(renderer, { x: params.x, y, text: params.c, type: "vocalfont", klass: renderer.controller.classes.generate("lyric"), anchor: "middle", dim: params.dim, name: "lyric" }, false);
          break;
        case "chord":
          params.graphelem = renderText(renderer, { x: params.x, y, text: params.c, type: "gchordfont", klass: renderer.controller.classes.generate("chord"), anchor: "middle", dim: params.dim, lane: params.getLane(), name: "chord" }, false);
          break;
        case "decoration":
          params.graphelem = renderText(renderer, { x: params.x, y: y + 6, text: params.c, type: "annotationfont", klass: renderer.controller.classes.generate("annotation"), anchor: "middle", centerVertically: true, dim: params.dim }, false);
          break;
        case "text":
          params.graphelem = renderText(renderer, { x: params.x, y, text: params.c, type: "annotationfont", klass: renderer.controller.classes.generate("annotation"), anchor: "start", centerVertically: params.centerVertically, dim: params.dim, lane: params.getLane(), name: "annotation" }, false);
          break;
        case "multimeasure-text":
          params.graphelem = renderText(renderer, { x: params.x + params.w / 2, y, text: params.c, type: "tempofont", klass: renderer.controller.classes.generate("rest"), anchor: "middle", centerVertically: false, dim: params.dim }, false);
          break;
        case "part":
          params.graphelem = renderText(renderer, { x: params.x, y, text: params.c, type: "partsfont", klass: renderer.controller.classes.generate("part"), anchor: "start", dim: params.dim, name: params.c }, true);
          break;
        case "bar":
          params.graphelem = printStem(renderer, params.x, params.linewidth, y, bartop ? bartop : renderer.calcY(params.pitch2), null, "bar");
          break;
        case "stem":
          params.graphelem = printStem(renderer, params.x, params.linewidth, y, renderer.calcY(params.pitch2), "abcjs-stem", "stem");
          break;
        case "ledger":
          params.graphelem = printStaffLine(renderer, params.x, params.x + params.w, params.pitch, "abcjs-ledger", "ledger");
          break;
      }
      if (params.scalex !== 1 && params.graphelem) {
        scaleExistingElem(renderer.paper, params.graphelem, params.scalex, params.scaley, params.x, y);
      }
      return params.graphelem;
    }
    function scaleExistingElem(paper, elem, scaleX, scaleY, x, y) {
      paper.setAttributeOnElement(elem, { style: "transform:scale(" + scaleX + "," + scaleY + ");transform-origin:" + x + "px " + y + "px;" });
    }
    module.exports = drawRelativeElement;
  }
});

// node_modules/abcjs/src/write/draw/tempo.js
var require_tempo = __commonJS({
  "node_modules/abcjs/src/write/draw/tempo.js"(exports, module) {
    var drawRelativeElement = require_relative();
    var renderText = require_text2();
    function drawTempo(renderer, params) {
      var x = params.x;
      if (params.pitch === void 0)
        window.console.error("Tempo Element y-coordinate not set.");
      params.tempo.el_type = "tempo";
      var descenderHeight = 2;
      var y = renderer.calcY(params.pitch) + 2;
      var text;
      var size;
      if (params.tempo.preString) {
        text = renderText(renderer, { x, y, text: params.tempo.preString, type: "tempofont", klass: "abcjs-tempo", anchor: "start", noClass: true, "dominant-baseline": "ideographic", name: "pre" }, true);
        size = renderer.controller.getTextSize.calc(params.tempo.preString, "tempofont", "tempo", text);
        var preWidth = size.width;
        var charWidth = preWidth / params.tempo.preString.length;
        x += preWidth + charWidth;
      }
      if (params.note) {
        params.note.setX(x);
        for (var i = 0; i < params.note.children.length; i++)
          drawRelativeElement(renderer, params.note.children[i], x);
        x += params.note.w + 5;
        var str = "= " + params.tempo.bpm;
        text = renderText(renderer, { x, y, text: str, type: "tempofont", klass: "abcjs-tempo", anchor: "start", noClass: true, name: "beats" });
        size = renderer.controller.getTextSize.calc(str, "tempofont", "tempo", text);
        var postWidth = size.width;
        var charWidth2 = postWidth / str.length;
        x += postWidth + charWidth2;
      }
      if (params.tempo.postString) {
        renderText(renderer, { x, y, text: params.tempo.postString, type: "tempofont", klass: "abcjs-tempo", anchor: "start", noClass: true, name: "post" }, true);
      }
    }
    module.exports = drawTempo;
  }
});

// node_modules/abcjs/src/write/draw/absolute.js
var require_absolute = __commonJS({
  "node_modules/abcjs/src/write/draw/absolute.js"(exports, module) {
    var drawTempo = require_tempo();
    var drawRelativeElement = require_relative();
    var spacing = require_abc_spacing();
    var setClass = require_set_class();
    var elementGroup = require_group_elements();
    function drawAbsolute(renderer, params, bartop, selectables, staffPos) {
      if (params.invisible)
        return;
      var isTempo = params.children.length > 0 && params.children[0].type === "TempoElement";
      params.elemset = [];
      elementGroup.beginGroup(renderer.paper, renderer.controller);
      for (var i = 0; i < params.children.length; i++) {
        var child = params.children[i];
        switch (child.type) {
          case "TempoElement":
            drawTempo(renderer, child);
            break;
          default:
            drawRelativeElement(renderer, child, bartop);
        }
      }
      var klass = params.type;
      if (params.type === "note" || params.type === "rest") {
        params.counters = renderer.controller.classes.getCurrent();
        klass += " d" + Math.round(params.durationClass * 1e3) / 1e3;
        klass = klass.replace(/\./g, "-");
        if (params.abcelem.pitches) {
          for (var j = 0; j < params.abcelem.pitches.length; j++) {
            klass += " p" + params.abcelem.pitches[j].pitch;
          }
        }
      }
      var g = elementGroup.endGroup(klass, params.type);
      if (g) {
        if (isTempo) {
          params.startChar = params.abcelem.startChar;
          params.endChar = params.abcelem.endChar;
          selectables.add(params, g, false, staffPos);
        } else {
          params.elemset.push(g);
          var isSelectable = false;
          if (params.type === "note" || params.type === "tabNumber") {
            isSelectable = true;
          }
          selectables.add(params, g, isSelectable, staffPos);
        }
      } else if (params.elemset.length > 0)
        selectables.add(params, params.elemset[0], params.type === "note", staffPos);
      if (params.klass)
        setClass(params.elemset, "mark", "", "#00ff00");
      if (params.hint)
        setClass(params.elemset, "abcjs-hint", "", null);
      params.abcelem.abselem = params;
      if (params.heads && params.heads.length > 0) {
        params.notePositions = [];
        for (var jj = 0; jj < params.heads.length; jj++) {
          params.notePositions.push({
            x: params.heads[jj].x + params.heads[jj].w / 2,
            y: staffPos.zero - params.heads[jj].pitch * spacing.STEP
          });
        }
      }
    }
    module.exports = drawAbsolute;
  }
});

// node_modules/abcjs/src/write/draw/voice.js
var require_voice2 = __commonJS({
  "node_modules/abcjs/src/write/draw/voice.js"(exports, module) {
    var drawCrescendo = require_crescendo();
    var drawDynamics = require_dynamics();
    var drawTriplet = require_triplet2();
    var drawEnding = require_ending();
    var drawTie = require_tie();
    var drawBeam = require_beam2();
    var renderText = require_text2();
    var drawAbsolute = require_absolute();
    function drawVoice(renderer, params, bartop, selectables, staffPos) {
      var width = params.w - 1;
      renderer.staffbottom = params.staff.bottom;
      if (params.header) {
        var textEl = renderText(renderer, { x: renderer.padding.left, y: renderer.calcY(params.headerPosition), text: params.header, type: "voicefont", klass: "staff-extra voice-name", anchor: "start", centerVertically: true, name: "voice-name" }, true);
        selectables.wrapSvgEl({ el_type: "voiceName", startChar: -1, endChar: -1, text: params.header }, textEl);
      }
      var i;
      var child;
      var foundNote = false;
      for (i = 0; i < params.children.length; i++) {
        child = params.children[i];
        if (child.type === "note" || child.type === "rest")
          foundNote = true;
        var justInitializedMeasureNumber = false;
        if (child.type !== "staff-extra" && !renderer.controller.classes.isInMeasure()) {
          renderer.controller.classes.startMeasure();
          justInitializedMeasureNumber = true;
        }
        switch (child.type) {
          default:
            if (params.staff.isTabStaff) {
              child.invisible = false;
              if (child.type == "bar") {
                if (child.abcelem.lastBar) {
                  bartop = params.topLine;
                }
              }
            }
            drawAbsolute(renderer, child, params.barto || i === params.children.length - 1 ? bartop : 0, selectables, staffPos);
        }
        if (child.type === "note" || isNonSpacerRest(child))
          renderer.controller.classes.incrNote();
        if (child.type === "bar" && !justInitializedMeasureNumber && foundNote) {
          renderer.controller.classes.incrMeasure();
        }
      }
      renderer.controller.classes.startMeasure();
      for (i = 0; i < params.beams.length; i++) {
        var beam = params.beams[i];
        if (beam === "bar") {
          renderer.controller.classes.incrMeasure();
        } else
          drawBeam(renderer, beam, selectables);
      }
      renderer.controller.classes.startMeasure();
      for (i = 0; i < params.otherchildren.length; i++) {
        child = params.otherchildren[i];
        if (child === "bar") {
          renderer.controller.classes.incrMeasure();
        } else {
          switch (child.type) {
            case "CrescendoElem":
              child.elemset = drawCrescendo(renderer, child, selectables);
              break;
            case "DynamicDecoration":
              child.elemset = drawDynamics(renderer, child, selectables);
              break;
            case "TripletElem":
              drawTriplet(renderer, child, selectables);
              break;
            case "EndingElem":
              child.elemset = drawEnding(renderer, child, params.startx + 10, width, selectables);
              break;
            case "TieElem":
              child.elemset = drawTie(renderer, child, params.startx + 10, width, selectables);
              break;
            default:
              console.log(child);
              drawAbsolute(renderer, child, params.startx + 10, width, selectables, staffPos);
          }
        }
      }
    }
    function isNonSpacerRest(elem) {
      if (elem.type !== "rest")
        return false;
      if (elem.abcelem && elem.abcelem.rest && elem.abcelem.rest.type !== "spacer")
        return true;
      return false;
    }
    module.exports = drawVoice;
  }
});

// node_modules/abcjs/src/write/draw/staff.js
var require_staff = __commonJS({
  "node_modules/abcjs/src/write/draw/staff.js"(exports, module) {
    var printStaffLine = require_staff_line();
    function printStaff(renderer, startx, endx, numLines, linePitch, dy) {
      var klass = "abcjs-top-line";
      var pitch = 2;
      if (linePitch) {
        pitch = linePitch;
      }
      renderer.paper.openGroup({ prepend: true, klass: renderer.controller.classes.generate("abcjs-staff") });
      var firstYLine = 0;
      var lastYLine = 0;
      if (numLines === 1) {
        printStaffLine(renderer, startx, endx, 6, klass);
        firstYLine = renderer.calcY(10);
        lastYLine = renderer.calcY(2);
      } else {
        for (var i = numLines - 1; i >= 0; i--) {
          var curpitch = (i + 1) * pitch;
          lastYLine = renderer.calcY(curpitch);
          if (firstYLine === 0) {
            firstYLine = lastYLine;
          }
          printStaffLine(renderer, startx, endx, curpitch, klass, null, dy);
          klass = void 0;
        }
      }
      renderer.paper.closeGroup();
      return [firstYLine, lastYLine];
    }
    module.exports = printStaff;
  }
});

// node_modules/abcjs/src/write/draw/debug-box.js
var require_debug_box = __commonJS({
  "node_modules/abcjs/src/write/draw/debug-box.js"(exports, module) {
    function printDebugBox(renderer, attr, comment) {
      var box = renderer.paper.rectBeneath(attr);
      if (comment)
        renderer.paper.text(comment, { x: 0, y: attr.y + 7, "text-anchor": "start", "font-size": "14px", fill: "rgba(0,0,255,.4)", stroke: "rgba(0,0,255,.4)" });
      return box;
    }
    module.exports = printDebugBox;
  }
});

// node_modules/abcjs/src/write/draw/separator.js
var require_separator2 = __commonJS({
  "node_modules/abcjs/src/write/draw/separator.js"(exports, module) {
    function drawSeparator(renderer, width) {
      var fill = "rgba(0,0,0,255)";
      var stroke = "rgba(0,0,0,0)";
      var y = Math.round(renderer.y);
      var staffWidth = renderer.controller.width;
      var x1 = (staffWidth - width) / 2;
      var x2 = x1 + width;
      var pathString = "M " + x1 + " " + y + " L " + x2 + " " + y + " L " + x2 + " " + (y + 1) + " L " + x1 + " " + (y + 1) + " L " + x1 + " " + y + " z";
      renderer.paper.pathToBack({ path: pathString, stroke, fill, "class": renderer.controller.classes.generate("defined-text") });
    }
    module.exports = drawSeparator;
  }
});

// node_modules/abcjs/src/write/draw/non-music.js
var require_non_music = __commonJS({
  "node_modules/abcjs/src/write/draw/non-music.js"(exports, module) {
    var drawSeparator = require_separator2();
    var renderText = require_text2();
    function nonMusic(renderer, obj, selectables) {
      for (var i = 0; i < obj.rows.length; i++) {
        var row = obj.rows[i];
        if (row.absmove) {
          renderer.absolutemoveY(row.absmove);
        } else if (row.move) {
          renderer.moveY(row.move);
        } else if (row.text) {
          var x = row.left ? row.left : 0;
          var el = renderText(renderer, {
            x,
            y: renderer.y,
            text: row.text,
            type: row.font,
            klass: row.klass,
            name: row.name,
            anchor: row.anchor
          });
          if (row.absElemType) {
            selectables.wrapSvgEl({
              el_type: row.absElemType,
              name: row.name,
              startChar: row.startChar,
              endChar: row.endChar,
              text: row.text
            }, el);
          }
        } else if (row.separator) {
          drawSeparator(renderer, row.separator);
        } else if (row.startGroup) {
          renderer.paper.openGroup({ klass: row.klass, "data-name": row.name });
        } else if (row.endGroup) {
          var g = renderer.paper.closeGroup();
          if (row.absElemType)
            selectables.wrapSvgEl({
              el_type: row.absElemType,
              name: row.name,
              startChar: row.startChar,
              endChar: row.endChar,
              text: ""
            }, g);
        }
      }
    }
    module.exports = nonMusic;
  }
});

// node_modules/abcjs/src/write/draw/staff-group.js
var require_staff_group = __commonJS({
  "node_modules/abcjs/src/write/draw/staff-group.js"(exports, module) {
    var spacing = require_abc_spacing();
    var drawBrace = require_brace();
    var drawVoice = require_voice2();
    var printStaff = require_staff();
    var printDebugBox = require_debug_box();
    var printStem = require_print_stem();
    var nonMusic = require_non_music();
    function drawStaffGroup(renderer, params, selectables, lineNumber) {
      var colorIndex;
      addInvisibleMarker(renderer, "abcjs-top-of-system");
      var startY = renderer.y;
      for (var j = 0; j < params.staffs.length; j++) {
        var staff1 = params.staffs[j];
        renderer.moveY(spacing.STEP, staff1.top);
        staff1.absoluteY = renderer.y;
        if (renderer.showDebug) {
          if (renderer.showDebug.indexOf("box") >= 0) {
            boxAllElements(renderer, params.voices, staff1.voices);
          }
          if (renderer.showDebug.indexOf("grid") >= 0) {
            renderer.paper.dottedLine({ x1: renderer.padding.left, x2: renderer.padding.left + renderer.controller.width, y1: startY, y2: startY, stroke: "#0000ff" });
            printDebugBox(renderer, {
              x: renderer.padding.left,
              y: renderer.calcY(staff1.originalTop),
              width: renderer.controller.width,
              height: renderer.calcY(staff1.originalBottom) - renderer.calcY(staff1.originalTop),
              fill: renderer.foregroundColor,
              stroke: renderer.foregroundColor,
              "fill-opacity": 0.1,
              "stroke-opacity": 0.1
            });
            colorIndex = 0;
            debugPrintGridItem(staff1, "chordHeightAbove");
            debugPrintGridItem(staff1, "chordHeightBelow");
            debugPrintGridItem(staff1, "dynamicHeightAbove");
            debugPrintGridItem(staff1, "dynamicHeightBelow");
            debugPrintGridItem(staff1, "endingHeightAbove");
            debugPrintGridItem(staff1, "lyricHeightAbove");
            debugPrintGridItem(staff1, "lyricHeightBelow");
            debugPrintGridItem(staff1, "partHeightAbove");
            debugPrintGridItem(staff1, "tempoHeightAbove");
            debugPrintGridItem(staff1, "volumeHeightAbove");
            debugPrintGridItem(staff1, "volumeHeightBelow");
          }
        }
        renderer.moveY(spacing.STEP, -staff1.bottom);
        if (renderer.showDebug) {
          if (renderer.showDebug.indexOf("grid") >= 0) {
            renderer.paper.dottedLine({
              x1: renderer.padding.left,
              x2: renderer.padding.left + renderer.controller.width,
              y1: renderer.y,
              y2: renderer.y,
              stroke: "#0000aa"
            });
          }
        }
      }
      var topLine;
      var bottomLine;
      var linePitch = 2;
      var bartop = 0;
      for (var i = 0; i < params.voices.length; i++) {
        var staff = params.voices[i].staff;
        var tabName = params.voices[i].tabNameInfos;
        renderer.y = staff.absoluteY;
        renderer.controller.classes.incrVoice();
        if (!params.voices[i].duplicate) {
          if (!topLine)
            topLine = renderer.calcY(10);
          bottomLine = renderer.calcY(linePitch);
          if (staff.lines !== 0) {
            if (staff.linePitch) {
              linePitch = staff.linePitch;
            }
            renderer.controller.classes.newMeasure();
            var lines = printStaff(renderer, params.startx, params.w, staff.lines, staff.linePitch, staff.dy);
            bottomLine = lines[1];
            staff.bottomLine = bottomLine;
            staff.topLine = lines[0];
            if (staff.hasTab) {
              bartop = staff.topLine;
            }
            if (staff.hasStaff) {
              bartop = staff.hasStaff.topLine;
              params.voices[i].barto = true;
              params.voices[i].topLine = topLine;
            }
          }
          printBrace(renderer, staff.absoluteY, params.brace, i, selectables);
          printBrace(renderer, staff.absoluteY, params.bracket, i, selectables);
        }
        drawVoice(renderer, params.voices[i], bartop, selectables, {
          top: startY,
          zero: renderer.y,
          height: params.height * spacing.STEP
        });
        var tabNameHeight = 0;
        if (tabName) {
          var r = { rows: [] };
          r.rows.push({ absmove: bottomLine + 2 });
          var leftMargin = 8;
          r.rows.push({ left: params.startx + leftMargin, text: tabName.name, font: "tablabelfont", klass: "text instrument-name", anchor: "start" });
          r.rows.push({ move: tabName.textSize.height });
          nonMusic(renderer, r);
          tabNameHeight = tabName.textSize.height;
        }
        renderer.controller.classes.newMeasure();
        if (!params.voices[i].duplicate) {
          bartop = renderer.calcY(2 + tabNameHeight);
        }
      }
      renderer.controller.classes.newMeasure();
      var staffSize = params.staffs.length;
      if (staffSize > 1) {
        topLine = params.staffs[0].topLine;
        bottomLine = params.staffs[staffSize - 1].bottomLine;
        printStem(renderer, params.startx, 0.6, topLine, bottomLine, null);
      }
      renderer.y = startY;
      function debugPrintGridItem(staff2, key) {
        var colors = [
          "rgb(207,27,36)",
          "rgb(168,214,80)",
          "rgb(110,161,224)",
          "rgb(191,119,218)",
          "rgb(195,30,151)",
          "rgb(31,170,177)",
          "rgb(220,166,142)"
        ];
        if (staff2.positionY[key]) {
          var height = staff2.specialY[key] * spacing.STEP;
          if (key === "chordHeightAbove" && staff2.specialY.chordLines && staff2.specialY.chordLines.above)
            height *= staff2.specialY.chordLines.above;
          if (key === "chordHeightBelow" && staff2.specialY.chordLines && staff2.specialY.chordLines.below)
            height *= staff2.specialY.chordLines.below;
          printDebugBox(renderer, {
            x: renderer.padding.left,
            y: renderer.calcY(staff2.positionY[key]),
            width: renderer.controller.width,
            height,
            fill: colors[colorIndex],
            stroke: colors[colorIndex],
            "fill-opacity": 0.4,
            "stroke-opacity": 0.4
          }, key.substr(0, 4));
          colorIndex += 1;
          if (colorIndex > 6)
            colorIndex = 0;
        }
      }
    }
    function printBrace(renderer, absoluteY, brace, index, selectables) {
      if (brace) {
        for (var i = 0; i < brace.length; i++) {
          if (brace[i].isStartVoice(index)) {
            brace[i].startY = absoluteY - spacing.STEP * 10;
            brace[i].elemset = drawBrace(renderer, brace[i], selectables);
          }
        }
      }
    }
    function addInvisibleMarker(renderer, className) {
      var y = Math.round(renderer.y);
      renderer.paper.pathToBack({ path: "M 0 " + y + " L 0 0", stroke: "none", fill: "none", "stroke-opacity": 0, "fill-opacity": 0, "class": renderer.controller.classes.generate(className), "data-vertical": y });
    }
    function boxAllElements(renderer, voices, which) {
      for (var i = 0; i < which.length; i++) {
        var children = voices[which[i]].children;
        for (var j = 0; j < children.length; j++) {
          var elem = children[j];
          var coords = elem.getFixedCoords();
          if (elem.invisible || coords.t === void 0 || coords.b === void 0)
            continue;
          var height = (coords.t - coords.b) * spacing.STEP;
          printDebugBox(renderer, {
            x: coords.x,
            y: renderer.calcY(coords.t),
            width: coords.w,
            height,
            fill: "#88e888",
            "fill-opacity": 0.4,
            stroke: "#4aa93d",
            "stroke-opacity": 0.8
          });
          for (var k = 0; k < elem.children.length; k++) {
            var relElem = elem.children[k];
            var chord = relElem.getChordDim();
            if (chord) {
              var y = renderer.calcY(relElem.pitch);
              y += relElem.dim.font.size * relElem.getLane();
              printDebugBox(renderer, {
                x: chord.left,
                y,
                width: chord.right - chord.left,
                height: relElem.dim.font.size,
                fill: "none",
                stroke: "#4aa93d",
                "stroke-opacity": 0.8
              });
            }
          }
        }
      }
    }
    module.exports = drawStaffGroup;
  }
});

// node_modules/abcjs/src/write/draw/set-paper-size.js
var require_set_paper_size = __commonJS({
  "node_modules/abcjs/src/write/draw/set-paper-size.js"(exports, module) {
    function setPaperSize(renderer, maxwidth, scale, responsive) {
      var w = (maxwidth + renderer.padding.right) * scale;
      var h = (renderer.y + renderer.padding.bottom) * scale;
      if (renderer.isPrint)
        h = Math.max(h, 1056);
      if (renderer.ariaLabel !== "") {
        var text = "Sheet Music";
        if (renderer.abctune && renderer.abctune.metaText && renderer.abctune.metaText.title)
          text += ' for "' + renderer.abctune.metaText.title + '"';
        renderer.paper.setTitle(text);
        var label = renderer.ariaLabel ? renderer.ariaLabel : text;
        renderer.paper.setAttribute("aria-label", label);
      }
      var styles = [
        "-webkit-touch-callout: none;",
        "-webkit-user-select: none;",
        "-khtml-user-select: none;",
        "-moz-user-select: none;",
        "-ms-user-select: none;",
        "user-select: none;"
      ];
      renderer.paper.insertStyles(".abcjs-dragging-in-progress text, .abcjs-dragging-in-progress tspan {" + styles.join(" ") + "}");
      var parentStyles = { overflow: "hidden" };
      if (responsive === "resize") {
        renderer.paper.setResponsiveWidth(w, h);
      } else {
        parentStyles.width = "";
        parentStyles.height = h + "px";
        if (scale < 1) {
          parentStyles.width = w + "px";
          renderer.paper.setSize(w / scale, h / scale);
        } else
          renderer.paper.setSize(w, h);
      }
      renderer.paper.setScale(scale);
      renderer.paper.setParentStyles(parentStyles);
    }
    module.exports = setPaperSize;
  }
});

// node_modules/abcjs/src/write/draw/selectables.js
var require_selectables = __commonJS({
  "node_modules/abcjs/src/write/draw/selectables.js"(exports, module) {
    var highlight = require_highlight();
    var unhighlight = require_unhighlight();
    function Selectables(paper, selectTypes, tuneNumber) {
      this.elements = [];
      this.paper = paper;
      this.tuneNumber = tuneNumber;
      this.selectTypes = selectTypes;
    }
    Selectables.prototype.getElements = function() {
      return this.elements;
    };
    Selectables.prototype.add = function(absEl, svgEl, isNoteOrTabNumber, staffPos) {
      if (!this.canSelect(absEl))
        return;
      var params;
      if (this.selectTypes === void 0)
        params = { selectable: false, "data-index": this.elements.length };
      else
        params = { selectable: true, tabindex: 0, "data-index": this.elements.length };
      this.paper.setAttributeOnElement(svgEl, params);
      var sel = { absEl, svgEl, isDraggable: isNoteOrTabNumber };
      if (staffPos !== void 0)
        sel.staffPos = staffPos;
      this.elements.push(sel);
    };
    Selectables.prototype.canSelect = function(absEl) {
      if (this.selectTypes === false)
        return false;
      if (!absEl || !absEl.abcelem)
        return false;
      if (this.selectTypes === true)
        return true;
      if (this.selectTypes === void 0) {
        if (absEl.abcelem.el_type === "note" || absEl.abcelem.el_type === "tabNumber") {
          return true;
        }
        return false;
      }
      return this.selectTypes.indexOf(absEl.abcelem.el_type) >= 0;
    };
    Selectables.prototype.wrapSvgEl = function(abcelem, el) {
      var absEl = {
        tuneNumber: this.tuneNumber,
        abcelem,
        elemset: [el],
        highlight,
        unhighlight
      };
      this.add(absEl, el, false);
    };
    module.exports = Selectables;
  }
});

// node_modules/abcjs/src/write/draw/draw.js
var require_draw = __commonJS({
  "node_modules/abcjs/src/write/draw/draw.js"(exports, module) {
    var drawStaffGroup = require_staff_group();
    var setPaperSize = require_set_paper_size();
    var nonMusic = require_non_music();
    var spacing = require_abc_spacing();
    var Selectables = require_selectables();
    function draw(renderer, classes, abcTune, width, maxWidth, responsive, scale, selectTypes, tuneNumber, lineOffset) {
      var selectables = new Selectables(renderer.paper, selectTypes, tuneNumber);
      renderer.moveY(renderer.padding.top);
      nonMusic(renderer, abcTune.topText, selectables);
      renderer.moveY(renderer.spacing.music);
      var staffgroups = [];
      for (var line = 0; line < abcTune.lines.length; line++) {
        classes.incrLine();
        var abcLine = abcTune.lines[line];
        if (abcLine.staff) {
          if (abcLine.vskip) {
            renderer.moveY(abcLine.vskip);
          }
          if (staffgroups.length >= 1)
            addStaffPadding(renderer, renderer.spacing.staffSeparation, staffgroups[staffgroups.length - 1], abcLine.staffGroup);
          var staffgroup = engraveStaffLine(renderer, abcLine.staffGroup, selectables, line);
          staffgroup.line = lineOffset + line;
          staffgroups.push(staffgroup);
        } else if (abcLine.nonMusic) {
          nonMusic(renderer, abcLine.nonMusic, selectables);
        }
      }
      classes.reset();
      if (abcTune.bottomText && abcTune.bottomText.rows && abcTune.bottomText.rows.length > 0) {
        renderer.moveY(24);
        nonMusic(renderer, abcTune.bottomText, selectables);
      }
      setPaperSize(renderer, maxWidth, scale, responsive);
      return { staffgroups, selectables: selectables.getElements() };
    }
    function engraveStaffLine(renderer, staffGroup, selectables, lineNumber) {
      drawStaffGroup(renderer, staffGroup, selectables, lineNumber);
      var height = staffGroup.height * spacing.STEP;
      renderer.y += height;
      return staffGroup;
    }
    function addStaffPadding(renderer, staffSeparation, lastStaffGroup, thisStaffGroup) {
      var lastStaff = lastStaffGroup.staffs[lastStaffGroup.staffs.length - 1];
      var lastBottomLine = -(lastStaff.bottom - 2);
      var nextTopLine = thisStaffGroup.staffs[0].top - 10;
      var naturalSeparation = nextTopLine + lastBottomLine;
      var separationInPixels = naturalSeparation * spacing.STEP;
      if (separationInPixels < staffSeparation)
        renderer.moveY(staffSeparation - separationInPixels);
    }
    module.exports = draw;
  }
});

// node_modules/abcjs/src/write/abc_engraver_controller.js
var require_abc_engraver_controller = __commonJS({
  "node_modules/abcjs/src/write/abc_engraver_controller.js"(exports, module) {
    var spacing = require_abc_spacing();
    var AbstractEngraver = require_abc_abstract_engraver();
    var Renderer = require_abc_renderer();
    var FreeText = require_free_text();
    var Separator = require_separator();
    var Subtitle = require_subtitle();
    var TopText = require_top_text();
    var BottomText = require_bottom_text();
    var setupSelection = require_selection();
    var layout = require_layout();
    var Classes = require_classes();
    var GetFontAndAttr = require_get_font_and_attr();
    var GetTextSize = require_get_text_size();
    var draw = require_draw();
    var tablatures = require_abc_tablatures();
    var EngraverController = function(paper, params) {
      params = params || {};
      this.selectionColor = params.selectionColor;
      this.dragColor = params.dragColor ? params.dragColor : params.selectionColor;
      this.dragging = !!params.dragging;
      this.selectTypes = params.selectTypes;
      this.responsive = params.responsive;
      this.space = 3 * spacing.SPACE;
      this.initialClef = params.initialClef;
      this.scale = params.scale ? parseFloat(params.scale) : 0;
      this.classes = new Classes({ shouldAddClasses: params.add_classes });
      if (!(this.scale > 0.1))
        this.scale = void 0;
      if (params.staffwidth) {
        this.staffwidthScreen = params.staffwidth;
        this.staffwidthPrint = params.staffwidth;
      } else {
        this.staffwidthScreen = 740;
        this.staffwidthPrint = 680;
      }
      this.listeners = [];
      if (params.clickListener)
        this.addSelectListener(params.clickListener);
      this.renderer = new Renderer(paper);
      this.renderer.setPaddingOverride(params);
      if (params.showDebug)
        this.renderer.showDebug = params.showDebug;
      if (params.jazzchords)
        this.jazzchords = params.jazzchords;
      this.renderer.controller = this;
      this.renderer.foregroundColor = params.foregroundColor ? params.foregroundColor : "currentColor";
      if (params.ariaLabel !== void 0)
        this.renderer.ariaLabel = params.ariaLabel;
      this.renderer.minPadding = params.minPadding ? params.minPadding : 0;
      this.reset();
    };
    EngraverController.prototype.reset = function() {
      this.selected = [];
      this.staffgroups = [];
      if (this.engraver)
        this.engraver.reset();
      this.engraver = null;
      this.renderer.reset();
      this.dragTarget = null;
      this.dragIndex = -1;
      this.dragMouseStart = { x: -1, y: -1 };
      this.dragYStep = 0;
    };
    EngraverController.prototype.engraveABC = function(abctunes, tuneNumber, lineOffset) {
      if (abctunes[0] === void 0) {
        abctunes = [abctunes];
      }
      this.reset();
      for (var i = 0; i < abctunes.length; i++) {
        if (tuneNumber === void 0)
          tuneNumber = i;
        this.getFontAndAttr = new GetFontAndAttr(abctunes[i].formatting, this.classes);
        this.getTextSize = new GetTextSize(this.getFontAndAttr, this.renderer.paper);
        this.engraveTune(abctunes[i], tuneNumber, lineOffset);
      }
    };
    EngraverController.prototype.adjustNonScaledItems = function(scale) {
      this.width /= scale;
      this.renderer.adjustNonScaledItems(scale);
    };
    EngraverController.prototype.getMeasureWidths = function(abcTune) {
      this.reset();
      this.getFontAndAttr = new GetFontAndAttr(abcTune.formatting, this.classes);
      this.getTextSize = new GetTextSize(this.getFontAndAttr, this.renderer.paper);
      this.setupTune(abcTune, 0);
      this.constructTuneElements(abcTune);
      layout(this.renderer, abcTune, 0, this.space);
      var ret = [];
      var section;
      var needNewSection = true;
      for (var i = 0; i < abcTune.lines.length; i++) {
        var abcLine = abcTune.lines[i];
        if (abcLine.staff) {
          if (needNewSection) {
            section = {
              left: 0,
              measureWidths: [],
              total: 0
            };
            ret.push(section);
            needNewSection = false;
          }
          if (abcLine.staffGroup.voices.length > 0) {
            var voice = abcLine.staffGroup.voices[0];
            var foundNotStaffExtra = false;
            var lastXPosition = 0;
            for (var k = 0; k < voice.children.length; k++) {
              var child = voice.children[k];
              if (!foundNotStaffExtra && !child.isClef && !child.isKeySig) {
                foundNotStaffExtra = true;
                section.left = child.x;
                lastXPosition = child.x;
              }
              if (child.type === "bar") {
                section.measureWidths.push(child.x - lastXPosition);
                section.total += child.x - lastXPosition;
                lastXPosition = child.x;
              }
            }
          }
        } else
          needNewSection = true;
      }
      return ret;
    };
    EngraverController.prototype.setupTune = function(abcTune, tuneNumber) {
      this.classes.reset();
      if (abcTune.formatting.jazzchords !== void 0)
        this.jazzchords = abcTune.formatting.jazzchords;
      this.renderer.newTune(abcTune);
      this.engraver = new AbstractEngraver(this.getTextSize, tuneNumber, {
        bagpipes: abcTune.formatting.bagpipes,
        flatbeams: abcTune.formatting.flatbeams,
        graceSlurs: abcTune.formatting.graceSlurs !== false,
        percmap: abcTune.formatting.percmap,
        initialClef: this.initialClef,
        jazzchords: this.jazzchords
      });
      this.engraver.setStemHeight(this.renderer.spacing.stemHeight);
      this.engraver.measureLength = abcTune.getMeterFraction().num / abcTune.getMeterFraction().den;
      if (abcTune.formatting.staffwidth) {
        this.width = abcTune.formatting.staffwidth * 1.33;
      } else {
        this.width = this.renderer.isPrint ? this.staffwidthPrint : this.staffwidthScreen;
      }
      var scale = abcTune.formatting.scale ? abcTune.formatting.scale : this.scale;
      if (this.responsive === "resize")
        scale = void 0;
      if (scale === void 0)
        scale = this.renderer.isPrint ? 0.75 : 1;
      this.adjustNonScaledItems(scale);
      return scale;
    };
    EngraverController.prototype.constructTuneElements = function(abcTune) {
      abcTune.topText = new TopText(abcTune.metaText, abcTune.metaTextInfo, abcTune.formatting, abcTune.lines, this.width, this.renderer.isPrint, this.renderer.padding.left, this.renderer.spacing, this.getTextSize);
      var i;
      var abcLine;
      var hasPrintedTempo = false;
      var hasSeenNonSubtitle = false;
      for (i = 0; i < abcTune.lines.length; i++) {
        abcLine = abcTune.lines[i];
        if (abcLine.staff) {
          hasSeenNonSubtitle = true;
          abcLine.staffGroup = this.engraver.createABCLine(abcLine.staff, !hasPrintedTempo ? abcTune.metaText.tempo : null, i);
          hasPrintedTempo = true;
        } else if (abcLine.subtitle) {
          if (hasSeenNonSubtitle) {
            var center = this.width / 2 + this.renderer.padding.left;
            abcLine.nonMusic = new Subtitle(this.renderer.spacing.subtitle, abcTune.formatting, abcLine.subtitle, center, this.renderer.padding.left, this.getTextSize);
          }
        } else if (abcLine.text !== void 0) {
          hasSeenNonSubtitle = true;
          abcLine.nonMusic = new FreeText(abcLine.text, abcLine.vskip, this.getFontAndAttr, this.renderer.padding.left, this.width, this.getTextSize);
        } else if (abcLine.separator !== void 0 && abcLine.separator.lineLength) {
          hasSeenNonSubtitle = true;
          abcLine.nonMusic = new Separator(abcLine.separator.spaceAbove, abcLine.separator.lineLength, abcLine.separator.spaceBelow);
        }
      }
      abcTune.bottomText = new BottomText(abcTune.metaText, this.width, this.renderer.isPrint, this.renderer.padding.left, this.renderer.spacing, this.getTextSize);
    };
    EngraverController.prototype.engraveTune = function(abcTune, tuneNumber, lineOffset) {
      var scale = this.setupTune(abcTune, tuneNumber);
      this.constructTuneElements(abcTune);
      var maxWidth = layout(this.renderer, abcTune, this.width, this.space);
      if (abcTune.tablatures) {
        tablatures.layoutTablatures(this.renderer, abcTune);
      }
      var ret = draw(this.renderer, this.classes, abcTune, this.width, maxWidth, this.responsive, scale, this.selectTypes, tuneNumber, lineOffset);
      this.staffgroups = ret.staffgroups;
      this.selectables = ret.selectables;
      setupSelection(this);
    };
    EngraverController.prototype.getDim = function(historyEl) {
      if (!historyEl.dim) {
        var box = historyEl.svgEl.getBBox();
        historyEl.dim = { left: Math.round(box.x), top: Math.round(box.y), right: Math.round(box.x + box.width), bottom: Math.round(box.y + box.height) };
      }
      return historyEl.dim;
    };
    EngraverController.prototype.addSelectListener = function(clickListener) {
      this.listeners[this.listeners.length] = clickListener;
    };
    module.exports = EngraverController;
  }
});

// node_modules/abcjs/src/api/abc_tunebook_svg.js
var require_abc_tunebook_svg = __commonJS({
  "node_modules/abcjs/src/api/abc_tunebook_svg.js"(exports, module) {
    var tunebook = require_abc_tunebook();
    var Tune = require_abc_tune();
    var EngraverController = require_abc_engraver_controller();
    var Parse = require_abc_parse();
    var wrap = require_wrap_lines();
    var parseCommon = require_abc_common();
    var resizeDivs = {};
    function resizeOuter() {
      var width = window.innerWidth;
      for (var id in resizeDivs) {
        if (resizeDivs.hasOwnProperty(id)) {
          var outer = resizeDivs[id];
          var ofs = outer.offsetLeft;
          width -= ofs * 2;
          outer.style.width = width + "px";
        }
      }
    }
    try {
      window.addEventListener("resize", resizeOuter);
      window.addEventListener("orientationChange", resizeOuter);
    } catch (e) {
    }
    function renderOne(div, tune, params, tuneNumber, lineOffset) {
      if (params.viewportHorizontal) {
        div.innerHTML = '<div class="abcjs-inner"></div>';
        if (params.scrollHorizontal) {
          div.style.overflowX = "auto";
          div.style.overflowY = "hidden";
        } else
          div.style.overflow = "hidden";
        resizeDivs[div.id] = div;
        div = div.children[0];
      } else if (params.viewportVertical) {
        div.innerHTML = '<div class="abcjs-inner scroll-amount"></div>';
        div.style.overflowX = "hidden";
        div.style.overflowY = "auto";
        div = div.children[0];
      } else
        div.innerHTML = "";
      var engraver_controller = new EngraverController(div, params);
      engraver_controller.engraveABC(tune, tuneNumber, lineOffset);
      tune.engraver = engraver_controller;
      if (params.viewportVertical || params.viewportHorizontal) {
        var parent = div.parentNode;
        parent.style.width = div.style.width;
      }
    }
    function renderEachLineSeparately(div, tune, params, tuneNumber) {
      function initializeTuneLine(tune2) {
        var obj = new Tune();
        obj.formatting = tune2.formatting;
        obj.media = tune2.media;
        obj.version = tune2.version;
        return obj;
      }
      var tunes = [];
      var tuneLine;
      for (var i = 0; i < tune.lines.length; i++) {
        var line = tune.lines[i];
        if (!tuneLine)
          tuneLine = initializeTuneLine(tune);
        if (i === 0) {
          tuneLine.copyTopInfo(tune);
        }
        tuneLine.lines.push(line);
        if (line.staff) {
          tunes.push(tuneLine);
          tuneLine = void 0;
        }
      }
      if (tuneLine) {
        var lastLine = tunes[tunes.length - 1];
        for (var j = 0; j < tuneLine.lines.length; j++)
          lastLine.lines.push(tuneLine.lines[j]);
      }
      tuneLine = tunes[tunes.length - 1];
      tuneLine.copyBottomInfo(tune);
      var ep = {};
      for (var key in params) {
        if (params.hasOwnProperty(key)) {
          ep[key] = params[key];
        }
      }
      var origPaddingTop = ep.paddingtop;
      var origPaddingBottom = ep.paddingbottom;
      var currentScrollY = div.parentNode.scrollTop;
      var currentScrollX = div.parentNode.scrollLeft;
      div.innerHTML = "";
      var lineCount = 0;
      for (var k = 0; k < tunes.length; k++) {
        var lineEl = document.createElement("div");
        div.appendChild(lineEl);
        if (k === 0) {
          ep.paddingtop = origPaddingTop;
          ep.paddingbottom = 0;
        } else if (k === tunes.length - 1) {
          ep.paddingtop = 10;
          ep.paddingbottom = origPaddingBottom;
        } else {
          ep.paddingtop = 10;
          ep.paddingbottom = 0;
        }
        if (k < tunes.length - 1) {
          tunes[k].formatting = parseCommon.clone(tunes[k].formatting);
          tunes[k].formatting.stretchlast = true;
        }
        renderOne(lineEl, tunes[k], ep, tuneNumber, lineCount);
        lineCount += tunes[k].lines.length;
        if (k === 0)
          tune.engraver = tunes[k].engraver;
        else {
          if (!tune.engraver.staffgroups)
            tune.engraver.staffgroups = tunes[k].engraver.staffgroups;
          else if (tunes[k].engraver.staffgroups.length > 0)
            tune.engraver.staffgroups.push(tunes[k].engraver.staffgroups[0]);
        }
      }
      if (currentScrollX || currentScrollY) {
        div.parentNode.scrollTo(currentScrollX, currentScrollY);
      }
    }
    var renderAbc = function(output, abc, parserParams, engraverParams, renderParams) {
      var params = {};
      var key;
      if (parserParams) {
        for (key in parserParams) {
          if (parserParams.hasOwnProperty(key)) {
            params[key] = parserParams[key];
          }
        }
        if (params.warnings_id && params.tablature) {
          params.tablature.warning_id = params.warnings_id;
        }
      }
      if (engraverParams) {
        for (key in engraverParams) {
          if (engraverParams.hasOwnProperty(key)) {
            if (key === "listener") {
              if (engraverParams[key].highlight)
                params.clickListener = engraverParams[key].highlight;
            } else
              params[key] = engraverParams[key];
          }
        }
      }
      if (renderParams) {
        for (key in renderParams) {
          if (renderParams.hasOwnProperty(key)) {
            params[key] = renderParams[key];
          }
        }
      }
      function callback(div, tune, tuneNumber, abcString) {
        var removeDiv = false;
        if (div === "*") {
          removeDiv = true;
          div = document.createElement("div");
          div.setAttribute("style", "visibility: hidden;");
          document.body.appendChild(div);
        }
        if (params.afterParsing)
          params.afterParsing(tune, tuneNumber, abcString);
        if (!removeDiv && params.wrap && params.staffwidth) {
          tune = doLineWrapping(div, tune, tuneNumber, abcString, params);
          return tune;
        } else if (removeDiv || !params.oneSvgPerLine || tune.lines.length < 2)
          renderOne(div, tune, params, tuneNumber, 0);
        else
          renderEachLineSeparately(div, tune, params, tuneNumber);
        if (removeDiv)
          div.parentNode.removeChild(div);
        return null;
      }
      return tunebook.renderEngine(callback, output, abc, params);
    };
    function doLineWrapping(div, tune, tuneNumber, abcString, params) {
      var engraver_controller = new EngraverController(div, params);
      var widths = engraver_controller.getMeasureWidths(tune);
      var ret = wrap.calcLineWraps(tune, widths, params);
      if (ret.reParse) {
        var abcParser = new Parse();
        abcParser.parse(abcString, ret.revisedParams);
        tune = abcParser.getTune();
        var warnings = abcParser.getWarnings();
        if (warnings)
          tune.warnings = warnings;
      }
      if (!params.oneSvgPerLine || tune.lines.length < 2)
        renderOne(div, tune, ret.revisedParams, tuneNumber, 0);
      else
        renderEachLineSeparately(div, tune, ret.revisedParams, tuneNumber);
      tune.explanation = ret.explanation;
      return tune;
    }
    module.exports = renderAbc;
  }
});

// abc-to-svg.js
var require_abc_to_svg = __commonJS({
  "abc-to-svg.js"(exports, module) {
    var { parseHTML } = require_cjs2();
    var renderAbc = require_abc_tunebook_svg();
    var toSvg = async (abc) => {
      const html = '<!DOCTYPE html>\n<html><body><div id="sheet"></div></body></html>';
      const { document: document2 } = parseHTML(html);
      const el = document2.getElementById("sheet");
      globalThis.document = document2;
      renderAbc(el, abc);
      const svg = el.getElementsByTagName("svg")[0];
      svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      const viewBox = `0 0 ${svg.getAttribute("width")} ${svg.getAttribute("height")}`;
      svg.setAttribute("viewBox", viewBox);
      svg.removeAttribute("height");
      svg.removeAttribute("width");
      svg.removeAttribute("style");
      const style = svg.getElementsByTagName("style")[0];
      if (style) {
        svg.removeChild(style);
      }
      return svg.outerHTML;
    };
    module.exports = toSvg;
  }
});
export default require_abc_to_svg();
